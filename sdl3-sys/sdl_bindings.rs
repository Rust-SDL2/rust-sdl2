/* automatically generated by rust-bindgen */

pub const __LINUX__: u32 = 1;
pub const HAVE_STDARG_H: u32 = 1;
pub const HAVE_STDDEF_H: u32 = 1;
pub const HAVE_STDINT_H: u32 = 1;
pub const HAVE_GCC_SYNC_LOCK_TEST_AND_SET: u32 = 1;
pub const SDL_AUDIO_DRIVER_DUMMY: u32 = 1;
pub const SDL_JOYSTICK_DISABLED: u32 = 1;
pub const SDL_HAPTIC_DISABLED: u32 = 1;
pub const SDL_HIDAPI_DISABLED: u32 = 1;
pub const SDL_SENSOR_DISABLED: u32 = 1;
pub const SDL_LOADSO_DISABLED: u32 = 1;
pub const SDL_THREADS_DISABLED: u32 = 1;
pub const SDL_TIMERS_DISABLED: u32 = 1;
pub const SDL_VIDEO_DRIVER_DUMMY: u32 = 1;
pub const SDL_FILESYSTEM_DUMMY: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const SDL_PRIs64: &'static [u8; 3usize] = b"ld\0";
pub const SDL_PRIu64: &'static [u8; 3usize] = b"lu\0";
pub const SDL_PRIx64: &'static [u8; 3usize] = b"lx\0";
pub const SDL_PRIX64: &'static [u8; 3usize] = b"lX\0";
pub const SDL_PRIs32: &'static [u8; 2usize] = b"d\0";
pub const SDL_PRIu32: &'static [u8; 2usize] = b"u\0";
pub const SDL_PRIx32: &'static [u8; 2usize] = b"x\0";
pub const SDL_PRIX32: &'static [u8; 2usize] = b"X\0";
pub const M_PI: f64 = 3.141592653589793;
pub const SDL_ASSERT_LEVEL: u32 = 2;
pub const SDL_NULL_WHILE_LOOP_CONDITION: u32 = 0;
pub const SDL_LIL_ENDIAN: u32 = 1234;
pub const SDL_BIG_ENDIAN: u32 = 4321;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const SDL_BYTEORDER: u32 = 1234;
pub const SDL_MUTEX_TIMEDOUT: u32 = 1;
pub const SDL_RWOPS_UNKNOWN: u32 = 0;
pub const SDL_RWOPS_WINFILE: u32 = 1;
pub const SDL_RWOPS_STDFILE: u32 = 2;
pub const SDL_RWOPS_JNIFILE: u32 = 3;
pub const SDL_RWOPS_MEMORY: u32 = 4;
pub const SDL_RWOPS_MEMORY_RO: u32 = 5;
pub const RW_SEEK_SET: u32 = 0;
pub const RW_SEEK_CUR: u32 = 1;
pub const RW_SEEK_END: u32 = 2;
pub const SDL_AUDIO_MASK_BITSIZE: u32 = 255;
pub const SDL_AUDIO_MASK_DATATYPE: u32 = 256;
pub const SDL_AUDIO_MASK_ENDIAN: u32 = 4096;
pub const SDL_AUDIO_MASK_SIGNED: u32 = 32768;
pub const AUDIO_U8: u32 = 8;
pub const AUDIO_S8: u32 = 32776;
pub const AUDIO_U16LSB: u32 = 16;
pub const AUDIO_S16LSB: u32 = 32784;
pub const AUDIO_U16MSB: u32 = 4112;
pub const AUDIO_S16MSB: u32 = 36880;
pub const AUDIO_U16: u32 = 16;
pub const AUDIO_S16: u32 = 32784;
pub const AUDIO_S32LSB: u32 = 32800;
pub const AUDIO_S32MSB: u32 = 36896;
pub const AUDIO_S32: u32 = 32800;
pub const AUDIO_F32LSB: u32 = 33056;
pub const AUDIO_F32MSB: u32 = 37152;
pub const AUDIO_F32: u32 = 33056;
pub const AUDIO_U16SYS: u32 = 16;
pub const AUDIO_S16SYS: u32 = 32784;
pub const AUDIO_S32SYS: u32 = 32800;
pub const AUDIO_F32SYS: u32 = 33056;
pub const SDL_AUDIO_ALLOW_FREQUENCY_CHANGE: u32 = 1;
pub const SDL_AUDIO_ALLOW_FORMAT_CHANGE: u32 = 2;
pub const SDL_AUDIO_ALLOW_CHANNELS_CHANGE: u32 = 4;
pub const SDL_AUDIO_ALLOW_SAMPLES_CHANGE: u32 = 8;
pub const SDL_AUDIO_ALLOW_ANY_CHANGE: u32 = 15;
pub const SDL_AUDIOCVT_MAX_FILTERS: u32 = 9;
pub const SDL_MIX_MAXVOLUME: u32 = 128;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _MM_HINT_ET0: u32 = 7;
pub const _MM_HINT_ET1: u32 = 6;
pub const _MM_HINT_T0: u32 = 3;
pub const _MM_HINT_T1: u32 = 2;
pub const _MM_HINT_T2: u32 = 1;
pub const _MM_HINT_NTA: u32 = 0;
pub const _MM_EXCEPT_INVALID: u32 = 1;
pub const _MM_EXCEPT_DENORM: u32 = 2;
pub const _MM_EXCEPT_DIV_ZERO: u32 = 4;
pub const _MM_EXCEPT_OVERFLOW: u32 = 8;
pub const _MM_EXCEPT_UNDERFLOW: u32 = 16;
pub const _MM_EXCEPT_INEXACT: u32 = 32;
pub const _MM_EXCEPT_MASK: u32 = 63;
pub const _MM_MASK_INVALID: u32 = 128;
pub const _MM_MASK_DENORM: u32 = 256;
pub const _MM_MASK_DIV_ZERO: u32 = 512;
pub const _MM_MASK_OVERFLOW: u32 = 1024;
pub const _MM_MASK_UNDERFLOW: u32 = 2048;
pub const _MM_MASK_INEXACT: u32 = 4096;
pub const _MM_MASK_MASK: u32 = 8064;
pub const _MM_ROUND_NEAREST: u32 = 0;
pub const _MM_ROUND_DOWN: u32 = 8192;
pub const _MM_ROUND_UP: u32 = 16384;
pub const _MM_ROUND_TOWARD_ZERO: u32 = 24576;
pub const _MM_ROUND_MASK: u32 = 24576;
pub const _MM_FLUSH_ZERO_MASK: u32 = 32768;
pub const _MM_FLUSH_ZERO_ON: u32 = 32768;
pub const _MM_FLUSH_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_ON: u32 = 64;
pub const _MM_DENORMALS_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_MASK: u32 = 64;
pub const SDL_CACHELINE_SIZE: u32 = 128;
pub const SDL_ALPHA_OPAQUE: u32 = 255;
pub const SDL_ALPHA_TRANSPARENT: u32 = 0;
pub const SDL_SWSURFACE: u32 = 0;
pub const SDL_PREALLOC: u32 = 1;
pub const SDL_RLEACCEL: u32 = 2;
pub const SDL_DONTFREE: u32 = 4;
pub const SDL_SIMD_ALIGNED: u32 = 8;
pub const SDL_WINDOWPOS_UNDEFINED_MASK: u32 = 536805376;
pub const SDL_WINDOWPOS_CENTERED_MASK: u32 = 805240832;
pub const SDLK_SCANCODE_MASK: u32 = 1073741824;
pub const SDL_BUTTON_LEFT: u32 = 1;
pub const SDL_BUTTON_MIDDLE: u32 = 2;
pub const SDL_BUTTON_RIGHT: u32 = 3;
pub const SDL_BUTTON_X1: u32 = 4;
pub const SDL_BUTTON_X2: u32 = 5;
pub const SDL_IPHONE_MAX_GFORCE: f64 = 5.0;
pub const SDL_JOYSTICK_AXIS_MAX: u32 = 32767;
pub const SDL_JOYSTICK_AXIS_MIN: i32 = -32768;
pub const SDL_HAT_CENTERED: u32 = 0;
pub const SDL_HAT_UP: u32 = 1;
pub const SDL_HAT_RIGHT: u32 = 2;
pub const SDL_HAT_DOWN: u32 = 4;
pub const SDL_HAT_LEFT: u32 = 8;
pub const SDL_HAT_RIGHTUP: u32 = 3;
pub const SDL_HAT_RIGHTDOWN: u32 = 6;
pub const SDL_HAT_LEFTUP: u32 = 9;
pub const SDL_HAT_LEFTDOWN: u32 = 12;
pub const SDL_STANDARD_GRAVITY: f64 = 9.80665;
pub const SDL_RELEASED: u32 = 0;
pub const SDL_PRESSED: u32 = 1;
pub const SDL_TEXTEDITINGEVENT_TEXT_SIZE: u32 = 32;
pub const SDL_TEXTINPUTEVENT_TEXT_SIZE: u32 = 32;
pub const SDL_QUERY: i32 = -1;
pub const SDL_IGNORE: u32 = 0;
pub const SDL_DISABLE: u32 = 0;
pub const SDL_ENABLE: u32 = 1;
pub const SDL_HAPTIC_CONSTANT: u32 = 1;
pub const SDL_HAPTIC_SINE: u32 = 2;
pub const SDL_HAPTIC_LEFTRIGHT: u32 = 4;
pub const SDL_HAPTIC_TRIANGLE: u32 = 8;
pub const SDL_HAPTIC_SAWTOOTHUP: u32 = 16;
pub const SDL_HAPTIC_SAWTOOTHDOWN: u32 = 32;
pub const SDL_HAPTIC_RAMP: u32 = 64;
pub const SDL_HAPTIC_SPRING: u32 = 128;
pub const SDL_HAPTIC_DAMPER: u32 = 256;
pub const SDL_HAPTIC_INERTIA: u32 = 512;
pub const SDL_HAPTIC_FRICTION: u32 = 1024;
pub const SDL_HAPTIC_CUSTOM: u32 = 2048;
pub const SDL_HAPTIC_GAIN: u32 = 4096;
pub const SDL_HAPTIC_AUTOCENTER: u32 = 8192;
pub const SDL_HAPTIC_STATUS: u32 = 16384;
pub const SDL_HAPTIC_PAUSE: u32 = 32768;
pub const SDL_HAPTIC_POLAR: u32 = 0;
pub const SDL_HAPTIC_CARTESIAN: u32 = 1;
pub const SDL_HAPTIC_SPHERICAL: u32 = 2;
pub const SDL_HAPTIC_STEERING_AXIS: u32 = 3;
pub const SDL_HAPTIC_INFINITY: u32 = 4294967295;
pub const SDL_HINT_ACCELEROMETER_AS_JOYSTICK: &'static [u8; 30usize] =
    b"SDL_ACCELEROMETER_AS_JOYSTICK\0";
pub const SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED: &'static [u8; 32usize] =
    b"SDL_ALLOW_ALT_TAB_WHILE_GRABBED\0";
pub const SDL_HINT_ALLOW_TOPMOST: &'static [u8; 18usize] = b"SDL_ALLOW_TOPMOST\0";
pub const SDL_HINT_ANDROID_APK_EXPANSION_MAIN_FILE_VERSION: &'static [u8; 44usize] =
    b"SDL_ANDROID_APK_EXPANSION_MAIN_FILE_VERSION\0";
pub const SDL_HINT_ANDROID_APK_EXPANSION_PATCH_FILE_VERSION: &'static [u8; 45usize] =
    b"SDL_ANDROID_APK_EXPANSION_PATCH_FILE_VERSION\0";
pub const SDL_HINT_ANDROID_BLOCK_ON_PAUSE: &'static [u8; 27usize] = b"SDL_ANDROID_BLOCK_ON_PAUSE\0";
pub const SDL_HINT_ANDROID_BLOCK_ON_PAUSE_PAUSEAUDIO: &'static [u8; 38usize] =
    b"SDL_ANDROID_BLOCK_ON_PAUSE_PAUSEAUDIO\0";
pub const SDL_HINT_ANDROID_TRAP_BACK_BUTTON: &'static [u8; 29usize] =
    b"SDL_ANDROID_TRAP_BACK_BUTTON\0";
pub const SDL_HINT_APP_NAME: &'static [u8; 13usize] = b"SDL_APP_NAME\0";
pub const SDL_HINT_APPLE_TV_CONTROLLER_UI_EVENTS: &'static [u8; 34usize] =
    b"SDL_APPLE_TV_CONTROLLER_UI_EVENTS\0";
pub const SDL_HINT_APPLE_TV_REMOTE_ALLOW_ROTATION: &'static [u8; 35usize] =
    b"SDL_APPLE_TV_REMOTE_ALLOW_ROTATION\0";
pub const SDL_HINT_AUDIO_CATEGORY: &'static [u8; 19usize] = b"SDL_AUDIO_CATEGORY\0";
pub const SDL_HINT_AUDIO_DEVICE_APP_NAME: &'static [u8; 26usize] = b"SDL_AUDIO_DEVICE_APP_NAME\0";
pub const SDL_HINT_AUDIO_DEVICE_STREAM_NAME: &'static [u8; 29usize] =
    b"SDL_AUDIO_DEVICE_STREAM_NAME\0";
pub const SDL_HINT_AUDIO_DEVICE_STREAM_ROLE: &'static [u8; 29usize] =
    b"SDL_AUDIO_DEVICE_STREAM_ROLE\0";
pub const SDL_HINT_AUDIO_RESAMPLING_MODE: &'static [u8; 26usize] = b"SDL_AUDIO_RESAMPLING_MODE\0";
pub const SDL_HINT_AUTO_UPDATE_JOYSTICKS: &'static [u8; 26usize] = b"SDL_AUTO_UPDATE_JOYSTICKS\0";
pub const SDL_HINT_AUTO_UPDATE_SENSORS: &'static [u8; 24usize] = b"SDL_AUTO_UPDATE_SENSORS\0";
pub const SDL_HINT_BMP_SAVE_LEGACY_FORMAT: &'static [u8; 27usize] = b"SDL_BMP_SAVE_LEGACY_FORMAT\0";
pub const SDL_HINT_DISPLAY_USABLE_BOUNDS: &'static [u8; 26usize] = b"SDL_DISPLAY_USABLE_BOUNDS\0";
pub const SDL_HINT_EMSCRIPTEN_ASYNCIFY: &'static [u8; 24usize] = b"SDL_EMSCRIPTEN_ASYNCIFY\0";
pub const SDL_HINT_EMSCRIPTEN_KEYBOARD_ELEMENT: &'static [u8; 32usize] =
    b"SDL_EMSCRIPTEN_KEYBOARD_ELEMENT\0";
pub const SDL_HINT_ENABLE_STEAM_CONTROLLERS: &'static [u8; 29usize] =
    b"SDL_ENABLE_STEAM_CONTROLLERS\0";
pub const SDL_HINT_EVENT_LOGGING: &'static [u8; 18usize] = b"SDL_EVENT_LOGGING\0";
pub const SDL_HINT_FRAMEBUFFER_ACCELERATION: &'static [u8; 29usize] =
    b"SDL_FRAMEBUFFER_ACCELERATION\0";
pub const SDL_HINT_GAMECONTROLLERCONFIG: &'static [u8; 25usize] = b"SDL_GAMECONTROLLERCONFIG\0";
pub const SDL_HINT_GAMECONTROLLERCONFIG_FILE: &'static [u8; 30usize] =
    b"SDL_GAMECONTROLLERCONFIG_FILE\0";
pub const SDL_HINT_GAMECONTROLLERTYPE: &'static [u8; 23usize] = b"SDL_GAMECONTROLLERTYPE\0";
pub const SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES: &'static [u8; 34usize] =
    b"SDL_GAMECONTROLLER_IGNORE_DEVICES\0";
pub const SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT: &'static [u8; 41usize] =
    b"SDL_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT\0";
pub const SDL_HINT_GAMECONTROLLER_USE_BUTTON_LABELS: &'static [u8; 37usize] =
    b"SDL_GAMECONTROLLER_USE_BUTTON_LABELS\0";
pub const SDL_HINT_GRAB_KEYBOARD: &'static [u8; 18usize] = b"SDL_GRAB_KEYBOARD\0";
pub const SDL_HINT_IDLE_TIMER_DISABLED: &'static [u8; 28usize] = b"SDL_IOS_IDLE_TIMER_DISABLED\0";
pub const SDL_HINT_IME_INTERNAL_EDITING: &'static [u8; 25usize] = b"SDL_IME_INTERNAL_EDITING\0";
pub const SDL_HINT_IME_SHOW_UI: &'static [u8; 16usize] = b"SDL_IME_SHOW_UI\0";
pub const SDL_HINT_IOS_HIDE_HOME_INDICATOR: &'static [u8; 28usize] =
    b"SDL_IOS_HIDE_HOME_INDICATOR\0";
pub const SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS: &'static [u8; 37usize] =
    b"SDL_JOYSTICK_ALLOW_BACKGROUND_EVENTS\0";
pub const SDL_HINT_JOYSTICK_HIDAPI: &'static [u8; 20usize] = b"SDL_JOYSTICK_HIDAPI\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_GAMECUBE: &'static [u8; 29usize] =
    b"SDL_JOYSTICK_HIDAPI_GAMECUBE\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_JOY_CONS: &'static [u8; 29usize] =
    b"SDL_JOYSTICK_HIDAPI_JOY_CONS\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_LUNA: &'static [u8; 25usize] = b"SDL_JOYSTICK_HIDAPI_LUNA\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_PS4: &'static [u8; 24usize] = b"SDL_JOYSTICK_HIDAPI_PS4\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_PS4_RUMBLE: &'static [u8; 31usize] =
    b"SDL_JOYSTICK_HIDAPI_PS4_RUMBLE\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_PS5: &'static [u8; 24usize] = b"SDL_JOYSTICK_HIDAPI_PS5\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_PS5_PLAYER_LED: &'static [u8; 35usize] =
    b"SDL_JOYSTICK_HIDAPI_PS5_PLAYER_LED\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_PS5_RUMBLE: &'static [u8; 31usize] =
    b"SDL_JOYSTICK_HIDAPI_PS5_RUMBLE\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_STADIA: &'static [u8; 27usize] = b"SDL_JOYSTICK_HIDAPI_STADIA\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_STEAM: &'static [u8; 26usize] = b"SDL_JOYSTICK_HIDAPI_STEAM\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_SWITCH: &'static [u8; 27usize] = b"SDL_JOYSTICK_HIDAPI_SWITCH\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_SWITCH_HOME_LED: &'static [u8; 36usize] =
    b"SDL_JOYSTICK_HIDAPI_SWITCH_HOME_LED\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_XBOX: &'static [u8; 25usize] = b"SDL_JOYSTICK_HIDAPI_XBOX\0";
pub const SDL_HINT_JOYSTICK_RAWINPUT: &'static [u8; 22usize] = b"SDL_JOYSTICK_RAWINPUT\0";
pub const SDL_HINT_JOYSTICK_RAWINPUT_CORRELATE_XINPUT: &'static [u8; 39usize] =
    b"SDL_JOYSTICK_RAWINPUT_CORRELATE_XINPUT\0";
pub const SDL_HINT_JOYSTICK_THREAD: &'static [u8; 20usize] = b"SDL_JOYSTICK_THREAD\0";
pub const SDL_HINT_KMSDRM_REQUIRE_DRM_MASTER: &'static [u8; 30usize] =
    b"SDL_KMSDRM_REQUIRE_DRM_MASTER\0";
pub const SDL_HINT_JOYSTICK_DEVICE: &'static [u8; 20usize] = b"SDL_JOYSTICK_DEVICE\0";
pub const SDL_HINT_LINUX_JOYSTICK_CLASSIC: &'static [u8; 27usize] = b"SDL_LINUX_JOYSTICK_CLASSIC\0";
pub const SDL_HINT_LINUX_JOYSTICK_DEADZONES: &'static [u8; 29usize] =
    b"SDL_LINUX_JOYSTICK_DEADZONES\0";
pub const SDL_HINT_MAC_BACKGROUND_APP: &'static [u8; 23usize] = b"SDL_MAC_BACKGROUND_APP\0";
pub const SDL_HINT_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK: &'static [u8; 39usize] =
    b"SDL_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK\0";
pub const SDL_HINT_MOUSE_DOUBLE_CLICK_RADIUS: &'static [u8; 30usize] =
    b"SDL_MOUSE_DOUBLE_CLICK_RADIUS\0";
pub const SDL_HINT_MOUSE_DOUBLE_CLICK_TIME: &'static [u8; 28usize] =
    b"SDL_MOUSE_DOUBLE_CLICK_TIME\0";
pub const SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH: &'static [u8; 29usize] =
    b"SDL_MOUSE_FOCUS_CLICKTHROUGH\0";
pub const SDL_HINT_MOUSE_NORMAL_SPEED_SCALE: &'static [u8; 29usize] =
    b"SDL_MOUSE_NORMAL_SPEED_SCALE\0";
pub const SDL_HINT_MOUSE_RELATIVE_MODE_WARP: &'static [u8; 29usize] =
    b"SDL_MOUSE_RELATIVE_MODE_WARP\0";
pub const SDL_HINT_MOUSE_RELATIVE_SCALING: &'static [u8; 27usize] = b"SDL_MOUSE_RELATIVE_SCALING\0";
pub const SDL_HINT_MOUSE_RELATIVE_SPEED_SCALE: &'static [u8; 31usize] =
    b"SDL_MOUSE_RELATIVE_SPEED_SCALE\0";
pub const SDL_HINT_MOUSE_TOUCH_EVENTS: &'static [u8; 23usize] = b"SDL_MOUSE_TOUCH_EVENTS\0";
pub const SDL_HINT_NO_SIGNAL_HANDLERS: &'static [u8; 23usize] = b"SDL_NO_SIGNAL_HANDLERS\0";
pub const SDL_HINT_OPENGL_ES_DRIVER: &'static [u8; 21usize] = b"SDL_OPENGL_ES_DRIVER\0";
pub const SDL_HINT_ORIENTATIONS: &'static [u8; 21usize] = b"SDL_IOS_ORIENTATIONS\0";
pub const SDL_HINT_POLL_SENTINEL: &'static [u8; 18usize] = b"SDL_POLL_SENTINEL\0";
pub const SDL_HINT_PREFERRED_LOCALES: &'static [u8; 22usize] = b"SDL_PREFERRED_LOCALES\0";
pub const SDL_HINT_QTWAYLAND_CONTENT_ORIENTATION: &'static [u8; 34usize] =
    b"SDL_QTWAYLAND_CONTENT_ORIENTATION\0";
pub const SDL_HINT_QTWAYLAND_WINDOW_FLAGS: &'static [u8; 27usize] = b"SDL_QTWAYLAND_WINDOW_FLAGS\0";
pub const SDL_HINT_RENDER_BATCHING: &'static [u8; 20usize] = b"SDL_RENDER_BATCHING\0";
pub const SDL_HINT_RENDER_LINE_METHOD: &'static [u8; 23usize] = b"SDL_RENDER_LINE_METHOD\0";
pub const SDL_HINT_RENDER_DIRECT3D11_DEBUG: &'static [u8; 28usize] =
    b"SDL_RENDER_DIRECT3D11_DEBUG\0";
pub const SDL_HINT_RENDER_DIRECT3D_THREADSAFE: &'static [u8; 31usize] =
    b"SDL_RENDER_DIRECT3D_THREADSAFE\0";
pub const SDL_HINT_RENDER_DRIVER: &'static [u8; 18usize] = b"SDL_RENDER_DRIVER\0";
pub const SDL_HINT_RENDER_LOGICAL_SIZE_MODE: &'static [u8; 29usize] =
    b"SDL_RENDER_LOGICAL_SIZE_MODE\0";
pub const SDL_HINT_RENDER_OPENGL_SHADERS: &'static [u8; 26usize] = b"SDL_RENDER_OPENGL_SHADERS\0";
pub const SDL_HINT_RENDER_SCALE_QUALITY: &'static [u8; 25usize] = b"SDL_RENDER_SCALE_QUALITY\0";
pub const SDL_HINT_RENDER_VSYNC: &'static [u8; 17usize] = b"SDL_RENDER_VSYNC\0";
pub const SDL_HINT_RETURN_KEY_HIDES_IME: &'static [u8; 25usize] = b"SDL_RETURN_KEY_HIDES_IME\0";
pub const SDL_HINT_RPI_VIDEO_LAYER: &'static [u8; 20usize] = b"SDL_RPI_VIDEO_LAYER\0";
pub const SDL_HINT_SCREENSAVER_INHIBIT_ACTIVITY_NAME: &'static [u8; 38usize] =
    b"SDL_SCREENSAVER_INHIBIT_ACTIVITY_NAME\0";
pub const SDL_HINT_THREAD_FORCE_REALTIME_TIME_CRITICAL: &'static [u8; 40usize] =
    b"SDL_THREAD_FORCE_REALTIME_TIME_CRITICAL\0";
pub const SDL_HINT_THREAD_PRIORITY_POLICY: &'static [u8; 27usize] = b"SDL_THREAD_PRIORITY_POLICY\0";
pub const SDL_HINT_THREAD_STACK_SIZE: &'static [u8; 22usize] = b"SDL_THREAD_STACK_SIZE\0";
pub const SDL_HINT_TIMER_RESOLUTION: &'static [u8; 21usize] = b"SDL_TIMER_RESOLUTION\0";
pub const SDL_HINT_TOUCH_MOUSE_EVENTS: &'static [u8; 23usize] = b"SDL_TOUCH_MOUSE_EVENTS\0";
pub const SDL_HINT_TV_REMOTE_AS_JOYSTICK: &'static [u8; 26usize] = b"SDL_TV_REMOTE_AS_JOYSTICK\0";
pub const SDL_HINT_VIDEO_ALLOW_SCREENSAVER: &'static [u8; 28usize] =
    b"SDL_VIDEO_ALLOW_SCREENSAVER\0";
pub const SDL_HINT_VIDEO_DOUBLE_BUFFER: &'static [u8; 24usize] = b"SDL_VIDEO_DOUBLE_BUFFER\0";
pub const SDL_HINT_VIDEO_EGL_ALLOW_TRANSPARENCY: &'static [u8; 33usize] =
    b"SDL_VIDEO_EGL_ALLOW_TRANSPARENCY\0";
pub const SDL_HINT_VIDEO_EXTERNAL_CONTEXT: &'static [u8; 27usize] = b"SDL_VIDEO_EXTERNAL_CONTEXT\0";
pub const SDL_HINT_VIDEO_HIGHDPI_DISABLED: &'static [u8; 27usize] = b"SDL_VIDEO_HIGHDPI_DISABLED\0";
pub const SDL_HINT_VIDEO_MAC_FULLSCREEN_SPACES: &'static [u8; 32usize] =
    b"SDL_VIDEO_MAC_FULLSCREEN_SPACES\0";
pub const SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS: &'static [u8; 33usize] =
    b"SDL_VIDEO_MINIMIZE_ON_FOCUS_LOSS\0";
pub const SDL_HINT_VIDEO_WAYLAND_ALLOW_LIBDECOR: &'static [u8; 33usize] =
    b"SDL_VIDEO_WAYLAND_ALLOW_LIBDECOR\0";
pub const SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT: &'static [u8; 36usize] =
    b"SDL_VIDEO_WINDOW_SHARE_PIXEL_FORMAT\0";
pub const SDL_HINT_VIDEO_WIN_D3DCOMPILER: &'static [u8; 26usize] = b"SDL_VIDEO_WIN_D3DCOMPILER\0";
pub const SDL_HINT_VIDEO_X11_FORCE_EGL: &'static [u8; 24usize] = b"SDL_VIDEO_X11_FORCE_EGL\0";
pub const SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR: &'static [u8; 39usize] =
    b"SDL_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR\0";
pub const SDL_HINT_VIDEO_X11_NET_WM_PING: &'static [u8; 26usize] = b"SDL_VIDEO_X11_NET_WM_PING\0";
pub const SDL_HINT_VIDEO_X11_WINDOW_VISUALID: &'static [u8; 30usize] =
    b"SDL_VIDEO_X11_WINDOW_VISUALID\0";
pub const SDL_HINT_VIDEO_X11_XINERAMA: &'static [u8; 23usize] = b"SDL_VIDEO_X11_XINERAMA\0";
pub const SDL_HINT_VIDEO_X11_XRANDR: &'static [u8; 21usize] = b"SDL_VIDEO_X11_XRANDR\0";
pub const SDL_HINT_VIDEO_X11_XVIDMODE: &'static [u8; 23usize] = b"SDL_VIDEO_X11_XVIDMODE\0";
pub const SDL_HINT_WAVE_FACT_CHUNK: &'static [u8; 20usize] = b"SDL_WAVE_FACT_CHUNK\0";
pub const SDL_HINT_WAVE_RIFF_CHUNK_SIZE: &'static [u8; 25usize] = b"SDL_WAVE_RIFF_CHUNK_SIZE\0";
pub const SDL_HINT_WAVE_TRUNCATION: &'static [u8; 20usize] = b"SDL_WAVE_TRUNCATION\0";
pub const SDL_HINT_WINDOWS_DISABLE_THREAD_NAMING: &'static [u8; 34usize] =
    b"SDL_WINDOWS_DISABLE_THREAD_NAMING\0";
pub const SDL_HINT_WINDOWS_ENABLE_MESSAGELOOP: &'static [u8; 31usize] =
    b"SDL_WINDOWS_ENABLE_MESSAGELOOP\0";
pub const SDL_HINT_WINDOWS_FORCE_MUTEX_CRITICAL_SECTIONS: &'static [u8; 42usize] =
    b"SDL_WINDOWS_FORCE_MUTEX_CRITICAL_SECTIONS\0";
pub const SDL_HINT_WINDOWS_FORCE_SEMAPHORE_KERNEL: &'static [u8; 35usize] =
    b"SDL_WINDOWS_FORCE_SEMAPHORE_KERNEL\0";
pub const SDL_HINT_WINDOWS_INTRESOURCE_ICON: &'static [u8; 29usize] =
    b"SDL_WINDOWS_INTRESOURCE_ICON\0";
pub const SDL_HINT_WINDOWS_INTRESOURCE_ICON_SMALL: &'static [u8; 35usize] =
    b"SDL_WINDOWS_INTRESOURCE_ICON_SMALL\0";
pub const SDL_HINT_WINDOWS_NO_CLOSE_ON_ALT_F4: &'static [u8; 31usize] =
    b"SDL_WINDOWS_NO_CLOSE_ON_ALT_F4\0";
pub const SDL_HINT_WINDOWS_USE_D3D9EX: &'static [u8; 23usize] = b"SDL_WINDOWS_USE_D3D9EX\0";
pub const SDL_HINT_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN: &'static [u8; 44usize] =
    b"SDL_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN\0";
pub const SDL_HINT_WINDOW_NO_ACTIVATION_WHEN_SHOWN: &'static [u8; 36usize] =
    b"SDL_WINDOW_NO_ACTIVATION_WHEN_SHOWN\0";
pub const SDL_HINT_WINRT_HANDLE_BACK_BUTTON: &'static [u8; 29usize] =
    b"SDL_WINRT_HANDLE_BACK_BUTTON\0";
pub const SDL_HINT_WINRT_PRIVACY_POLICY_LABEL: &'static [u8; 31usize] =
    b"SDL_WINRT_PRIVACY_POLICY_LABEL\0";
pub const SDL_HINT_WINRT_PRIVACY_POLICY_URL: &'static [u8; 29usize] =
    b"SDL_WINRT_PRIVACY_POLICY_URL\0";
pub const SDL_HINT_X11_FORCE_OVERRIDE_REDIRECT: &'static [u8; 32usize] =
    b"SDL_X11_FORCE_OVERRIDE_REDIRECT\0";
pub const SDL_HINT_XINPUT_ENABLED: &'static [u8; 19usize] = b"SDL_XINPUT_ENABLED\0";
pub const SDL_HINT_XINPUT_USE_OLD_JOYSTICK_MAPPING: &'static [u8; 36usize] =
    b"SDL_XINPUT_USE_OLD_JOYSTICK_MAPPING\0";
pub const SDL_HINT_AUDIO_INCLUDE_MONITORS: &'static [u8; 27usize] = b"SDL_AUDIO_INCLUDE_MONITORS\0";
pub const SDL_MAX_LOG_MESSAGE: u32 = 4096;
pub const SDL_NONSHAPEABLE_WINDOW: i32 = -1;
pub const SDL_INVALID_SHAPE_ARGUMENT: i32 = -2;
pub const SDL_WINDOW_LACKS_SHAPE: i32 = -3;
pub const SDL_MAJOR_VERSION: u32 = 2;
pub const SDL_MINOR_VERSION: u32 = 0;
pub const SDL_PATCHLEVEL: u32 = 20;
pub const SDL_INIT_TIMER: u32 = 1;
pub const SDL_INIT_AUDIO: u32 = 16;
pub const SDL_INIT_VIDEO: u32 = 32;
pub const SDL_INIT_JOYSTICK: u32 = 512;
pub const SDL_INIT_HAPTIC: u32 = 4096;
pub const SDL_INIT_GAMECONTROLLER: u32 = 8192;
pub const SDL_INIT_EVENTS: u32 = 16384;
pub const SDL_INIT_SENSOR: u32 = 32768;
pub const SDL_INIT_NOPARACHUTE: u32 = 1048576;
pub const SDL_INIT_EVERYTHING: u32 = 62001;
pub const XlibSpecificationRelease: u32 = 6;
pub const X_PROTOCOL: u32 = 11;
pub const X_PROTOCOL_REVISION: u32 = 0;
pub const None: u32 = 0;
pub const ParentRelative: u32 = 1;
pub const CopyFromParent: u32 = 0;
pub const PointerWindow: u32 = 0;
pub const InputFocus: u32 = 1;
pub const PointerRoot: u32 = 1;
pub const AnyPropertyType: u32 = 0;
pub const AnyKey: u32 = 0;
pub const AnyButton: u32 = 0;
pub const AllTemporary: u32 = 0;
pub const CurrentTime: u32 = 0;
pub const NoSymbol: u32 = 0;
pub const NoEventMask: u32 = 0;
pub const KeyPressMask: u32 = 1;
pub const KeyReleaseMask: u32 = 2;
pub const ButtonPressMask: u32 = 4;
pub const ButtonReleaseMask: u32 = 8;
pub const EnterWindowMask: u32 = 16;
pub const LeaveWindowMask: u32 = 32;
pub const PointerMotionMask: u32 = 64;
pub const PointerMotionHintMask: u32 = 128;
pub const Button1MotionMask: u32 = 256;
pub const Button2MotionMask: u32 = 512;
pub const Button3MotionMask: u32 = 1024;
pub const Button4MotionMask: u32 = 2048;
pub const Button5MotionMask: u32 = 4096;
pub const ButtonMotionMask: u32 = 8192;
pub const KeymapStateMask: u32 = 16384;
pub const ExposureMask: u32 = 32768;
pub const VisibilityChangeMask: u32 = 65536;
pub const StructureNotifyMask: u32 = 131072;
pub const ResizeRedirectMask: u32 = 262144;
pub const SubstructureNotifyMask: u32 = 524288;
pub const SubstructureRedirectMask: u32 = 1048576;
pub const FocusChangeMask: u32 = 2097152;
pub const PropertyChangeMask: u32 = 4194304;
pub const ColormapChangeMask: u32 = 8388608;
pub const OwnerGrabButtonMask: u32 = 16777216;
pub const KeyPress: u32 = 2;
pub const KeyRelease: u32 = 3;
pub const ButtonPress: u32 = 4;
pub const ButtonRelease: u32 = 5;
pub const MotionNotify: u32 = 6;
pub const EnterNotify: u32 = 7;
pub const LeaveNotify: u32 = 8;
pub const FocusIn: u32 = 9;
pub const FocusOut: u32 = 10;
pub const KeymapNotify: u32 = 11;
pub const Expose: u32 = 12;
pub const GraphicsExpose: u32 = 13;
pub const NoExpose: u32 = 14;
pub const VisibilityNotify: u32 = 15;
pub const CreateNotify: u32 = 16;
pub const DestroyNotify: u32 = 17;
pub const UnmapNotify: u32 = 18;
pub const MapNotify: u32 = 19;
pub const MapRequest: u32 = 20;
pub const ReparentNotify: u32 = 21;
pub const ConfigureNotify: u32 = 22;
pub const ConfigureRequest: u32 = 23;
pub const GravityNotify: u32 = 24;
pub const ResizeRequest: u32 = 25;
pub const CirculateNotify: u32 = 26;
pub const CirculateRequest: u32 = 27;
pub const PropertyNotify: u32 = 28;
pub const SelectionClear: u32 = 29;
pub const SelectionRequest: u32 = 30;
pub const SelectionNotify: u32 = 31;
pub const ColormapNotify: u32 = 32;
pub const ClientMessage: u32 = 33;
pub const MappingNotify: u32 = 34;
pub const GenericEvent: u32 = 35;
pub const LASTEvent: u32 = 36;
pub const ShiftMask: u32 = 1;
pub const LockMask: u32 = 2;
pub const ControlMask: u32 = 4;
pub const Mod1Mask: u32 = 8;
pub const Mod2Mask: u32 = 16;
pub const Mod3Mask: u32 = 32;
pub const Mod4Mask: u32 = 64;
pub const Mod5Mask: u32 = 128;
pub const ShiftMapIndex: u32 = 0;
pub const LockMapIndex: u32 = 1;
pub const ControlMapIndex: u32 = 2;
pub const Mod1MapIndex: u32 = 3;
pub const Mod2MapIndex: u32 = 4;
pub const Mod3MapIndex: u32 = 5;
pub const Mod4MapIndex: u32 = 6;
pub const Mod5MapIndex: u32 = 7;
pub const Button1Mask: u32 = 256;
pub const Button2Mask: u32 = 512;
pub const Button3Mask: u32 = 1024;
pub const Button4Mask: u32 = 2048;
pub const Button5Mask: u32 = 4096;
pub const AnyModifier: u32 = 32768;
pub const Button1: u32 = 1;
pub const Button2: u32 = 2;
pub const Button3: u32 = 3;
pub const Button4: u32 = 4;
pub const Button5: u32 = 5;
pub const NotifyNormal: u32 = 0;
pub const NotifyGrab: u32 = 1;
pub const NotifyUngrab: u32 = 2;
pub const NotifyWhileGrabbed: u32 = 3;
pub const NotifyHint: u32 = 1;
pub const NotifyAncestor: u32 = 0;
pub const NotifyVirtual: u32 = 1;
pub const NotifyInferior: u32 = 2;
pub const NotifyNonlinear: u32 = 3;
pub const NotifyNonlinearVirtual: u32 = 4;
pub const NotifyPointer: u32 = 5;
pub const NotifyPointerRoot: u32 = 6;
pub const NotifyDetailNone: u32 = 7;
pub const VisibilityUnobscured: u32 = 0;
pub const VisibilityPartiallyObscured: u32 = 1;
pub const VisibilityFullyObscured: u32 = 2;
pub const PlaceOnTop: u32 = 0;
pub const PlaceOnBottom: u32 = 1;
pub const FamilyInternet: u32 = 0;
pub const FamilyDECnet: u32 = 1;
pub const FamilyChaos: u32 = 2;
pub const FamilyInternet6: u32 = 6;
pub const FamilyServerInterpreted: u32 = 5;
pub const PropertyNewValue: u32 = 0;
pub const PropertyDelete: u32 = 1;
pub const ColormapUninstalled: u32 = 0;
pub const ColormapInstalled: u32 = 1;
pub const GrabModeSync: u32 = 0;
pub const GrabModeAsync: u32 = 1;
pub const GrabSuccess: u32 = 0;
pub const AlreadyGrabbed: u32 = 1;
pub const GrabInvalidTime: u32 = 2;
pub const GrabNotViewable: u32 = 3;
pub const GrabFrozen: u32 = 4;
pub const AsyncPointer: u32 = 0;
pub const SyncPointer: u32 = 1;
pub const ReplayPointer: u32 = 2;
pub const AsyncKeyboard: u32 = 3;
pub const SyncKeyboard: u32 = 4;
pub const ReplayKeyboard: u32 = 5;
pub const AsyncBoth: u32 = 6;
pub const SyncBoth: u32 = 7;
pub const RevertToParent: u32 = 2;
pub const Success: u32 = 0;
pub const BadRequest: u32 = 1;
pub const BadValue: u32 = 2;
pub const BadWindow: u32 = 3;
pub const BadPixmap: u32 = 4;
pub const BadAtom: u32 = 5;
pub const BadCursor: u32 = 6;
pub const BadFont: u32 = 7;
pub const BadMatch: u32 = 8;
pub const BadDrawable: u32 = 9;
pub const BadAccess: u32 = 10;
pub const BadAlloc: u32 = 11;
pub const BadColor: u32 = 12;
pub const BadGC: u32 = 13;
pub const BadIDChoice: u32 = 14;
pub const BadName: u32 = 15;
pub const BadLength: u32 = 16;
pub const BadImplementation: u32 = 17;
pub const FirstExtensionError: u32 = 128;
pub const LastExtensionError: u32 = 255;
pub const InputOutput: u32 = 1;
pub const InputOnly: u32 = 2;
pub const CWBackPixmap: u32 = 1;
pub const CWBackPixel: u32 = 2;
pub const CWBorderPixmap: u32 = 4;
pub const CWBorderPixel: u32 = 8;
pub const CWBitGravity: u32 = 16;
pub const CWWinGravity: u32 = 32;
pub const CWBackingStore: u32 = 64;
pub const CWBackingPlanes: u32 = 128;
pub const CWBackingPixel: u32 = 256;
pub const CWOverrideRedirect: u32 = 512;
pub const CWSaveUnder: u32 = 1024;
pub const CWEventMask: u32 = 2048;
pub const CWDontPropagate: u32 = 4096;
pub const CWColormap: u32 = 8192;
pub const CWCursor: u32 = 16384;
pub const CWX: u32 = 1;
pub const CWY: u32 = 2;
pub const CWWidth: u32 = 4;
pub const CWHeight: u32 = 8;
pub const CWBorderWidth: u32 = 16;
pub const CWSibling: u32 = 32;
pub const CWStackMode: u32 = 64;
pub const ForgetGravity: u32 = 0;
pub const NorthWestGravity: u32 = 1;
pub const NorthGravity: u32 = 2;
pub const NorthEastGravity: u32 = 3;
pub const WestGravity: u32 = 4;
pub const CenterGravity: u32 = 5;
pub const EastGravity: u32 = 6;
pub const SouthWestGravity: u32 = 7;
pub const SouthGravity: u32 = 8;
pub const SouthEastGravity: u32 = 9;
pub const StaticGravity: u32 = 10;
pub const UnmapGravity: u32 = 0;
pub const NotUseful: u32 = 0;
pub const WhenMapped: u32 = 1;
pub const Always: u32 = 2;
pub const IsUnmapped: u32 = 0;
pub const IsUnviewable: u32 = 1;
pub const IsViewable: u32 = 2;
pub const SetModeInsert: u32 = 0;
pub const SetModeDelete: u32 = 1;
pub const DestroyAll: u32 = 0;
pub const RetainPermanent: u32 = 1;
pub const RetainTemporary: u32 = 2;
pub const Above: u32 = 0;
pub const Below: u32 = 1;
pub const TopIf: u32 = 2;
pub const BottomIf: u32 = 3;
pub const Opposite: u32 = 4;
pub const RaiseLowest: u32 = 0;
pub const LowerHighest: u32 = 1;
pub const PropModeReplace: u32 = 0;
pub const PropModePrepend: u32 = 1;
pub const PropModeAppend: u32 = 2;
pub const GXclear: u32 = 0;
pub const GXand: u32 = 1;
pub const GXandReverse: u32 = 2;
pub const GXcopy: u32 = 3;
pub const GXandInverted: u32 = 4;
pub const GXnoop: u32 = 5;
pub const GXxor: u32 = 6;
pub const GXor: u32 = 7;
pub const GXnor: u32 = 8;
pub const GXequiv: u32 = 9;
pub const GXinvert: u32 = 10;
pub const GXorReverse: u32 = 11;
pub const GXcopyInverted: u32 = 12;
pub const GXorInverted: u32 = 13;
pub const GXnand: u32 = 14;
pub const GXset: u32 = 15;
pub const LineSolid: u32 = 0;
pub const LineOnOffDash: u32 = 1;
pub const LineDoubleDash: u32 = 2;
pub const CapNotLast: u32 = 0;
pub const CapButt: u32 = 1;
pub const CapRound: u32 = 2;
pub const CapProjecting: u32 = 3;
pub const JoinMiter: u32 = 0;
pub const JoinRound: u32 = 1;
pub const JoinBevel: u32 = 2;
pub const FillSolid: u32 = 0;
pub const FillTiled: u32 = 1;
pub const FillStippled: u32 = 2;
pub const FillOpaqueStippled: u32 = 3;
pub const EvenOddRule: u32 = 0;
pub const WindingRule: u32 = 1;
pub const ClipByChildren: u32 = 0;
pub const IncludeInferiors: u32 = 1;
pub const Unsorted: u32 = 0;
pub const YSorted: u32 = 1;
pub const YXSorted: u32 = 2;
pub const YXBanded: u32 = 3;
pub const CoordModeOrigin: u32 = 0;
pub const CoordModePrevious: u32 = 1;
pub const Complex: u32 = 0;
pub const Nonconvex: u32 = 1;
pub const Convex: u32 = 2;
pub const ArcChord: u32 = 0;
pub const ArcPieSlice: u32 = 1;
pub const GCFunction: u32 = 1;
pub const GCPlaneMask: u32 = 2;
pub const GCForeground: u32 = 4;
pub const GCBackground: u32 = 8;
pub const GCLineWidth: u32 = 16;
pub const GCLineStyle: u32 = 32;
pub const GCCapStyle: u32 = 64;
pub const GCJoinStyle: u32 = 128;
pub const GCFillStyle: u32 = 256;
pub const GCFillRule: u32 = 512;
pub const GCTile: u32 = 1024;
pub const GCStipple: u32 = 2048;
pub const GCTileStipXOrigin: u32 = 4096;
pub const GCTileStipYOrigin: u32 = 8192;
pub const GCFont: u32 = 16384;
pub const GCSubwindowMode: u32 = 32768;
pub const GCGraphicsExposures: u32 = 65536;
pub const GCClipXOrigin: u32 = 131072;
pub const GCClipYOrigin: u32 = 262144;
pub const GCClipMask: u32 = 524288;
pub const GCDashOffset: u32 = 1048576;
pub const GCDashList: u32 = 2097152;
pub const GCArcMode: u32 = 4194304;
pub const GCLastBit: u32 = 22;
pub const FontLeftToRight: u32 = 0;
pub const FontRightToLeft: u32 = 1;
pub const FontChange: u32 = 255;
pub const XYBitmap: u32 = 0;
pub const XYPixmap: u32 = 1;
pub const ZPixmap: u32 = 2;
pub const AllocNone: u32 = 0;
pub const AllocAll: u32 = 1;
pub const DoRed: u32 = 1;
pub const DoGreen: u32 = 2;
pub const DoBlue: u32 = 4;
pub const CursorShape: u32 = 0;
pub const TileShape: u32 = 1;
pub const StippleShape: u32 = 2;
pub const AutoRepeatModeOff: u32 = 0;
pub const AutoRepeatModeOn: u32 = 1;
pub const AutoRepeatModeDefault: u32 = 2;
pub const LedModeOff: u32 = 0;
pub const LedModeOn: u32 = 1;
pub const KBKeyClickPercent: u32 = 1;
pub const KBBellPercent: u32 = 2;
pub const KBBellPitch: u32 = 4;
pub const KBBellDuration: u32 = 8;
pub const KBLed: u32 = 16;
pub const KBLedMode: u32 = 32;
pub const KBKey: u32 = 64;
pub const KBAutoRepeatMode: u32 = 128;
pub const MappingSuccess: u32 = 0;
pub const MappingBusy: u32 = 1;
pub const MappingFailed: u32 = 2;
pub const MappingModifier: u32 = 0;
pub const MappingKeyboard: u32 = 1;
pub const MappingPointer: u32 = 2;
pub const DontPreferBlanking: u32 = 0;
pub const PreferBlanking: u32 = 1;
pub const DefaultBlanking: u32 = 2;
pub const DisableScreenSaver: u32 = 0;
pub const DisableScreenInterval: u32 = 0;
pub const DontAllowExposures: u32 = 0;
pub const AllowExposures: u32 = 1;
pub const DefaultExposures: u32 = 2;
pub const ScreenSaverReset: u32 = 0;
pub const ScreenSaverActive: u32 = 1;
pub const HostInsert: u32 = 0;
pub const HostDelete: u32 = 1;
pub const EnableAccess: u32 = 1;
pub const DisableAccess: u32 = 0;
pub const StaticGray: u32 = 0;
pub const GrayScale: u32 = 1;
pub const StaticColor: u32 = 2;
pub const PseudoColor: u32 = 3;
pub const TrueColor: u32 = 4;
pub const DirectColor: u32 = 5;
pub const LSBFirst: u32 = 0;
pub const MSBFirst: u32 = 1;
pub const NeedFunctionPrototypes: u32 = 1;
pub const NeedVarargsPrototypes: u32 = 1;
pub const NeedNestedPrototypes: u32 = 1;
pub const FUNCPROTO: u32 = 15;
pub const NeedWidePrototypes: u32 = 0;
pub const X_HAVE_UTF8_STRING: u32 = 1;
pub const True: u32 = 1;
pub const False: u32 = 0;
pub const QueuedAlready: u32 = 0;
pub const QueuedAfterReading: u32 = 1;
pub const QueuedAfterFlush: u32 = 2;
pub const XNRequiredCharSet: &'static [u8; 16usize] = b"requiredCharSet\0";
pub const XNQueryOrientation: &'static [u8; 17usize] = b"queryOrientation\0";
pub const XNBaseFontName: &'static [u8; 13usize] = b"baseFontName\0";
pub const XNOMAutomatic: &'static [u8; 12usize] = b"omAutomatic\0";
pub const XNMissingCharSet: &'static [u8; 15usize] = b"missingCharSet\0";
pub const XNDefaultString: &'static [u8; 14usize] = b"defaultString\0";
pub const XNOrientation: &'static [u8; 12usize] = b"orientation\0";
pub const XNDirectionalDependentDrawing: &'static [u8; 28usize] = b"directionalDependentDrawing\0";
pub const XNContextualDrawing: &'static [u8; 18usize] = b"contextualDrawing\0";
pub const XNFontInfo: &'static [u8; 9usize] = b"fontInfo\0";
pub const XIMPreeditArea: u32 = 1;
pub const XIMPreeditCallbacks: u32 = 2;
pub const XIMPreeditPosition: u32 = 4;
pub const XIMPreeditNothing: u32 = 8;
pub const XIMPreeditNone: u32 = 16;
pub const XIMStatusArea: u32 = 256;
pub const XIMStatusCallbacks: u32 = 512;
pub const XIMStatusNothing: u32 = 1024;
pub const XIMStatusNone: u32 = 2048;
pub const XNVaNestedList: &'static [u8; 15usize] = b"XNVaNestedList\0";
pub const XNQueryInputStyle: &'static [u8; 16usize] = b"queryInputStyle\0";
pub const XNClientWindow: &'static [u8; 13usize] = b"clientWindow\0";
pub const XNInputStyle: &'static [u8; 11usize] = b"inputStyle\0";
pub const XNFocusWindow: &'static [u8; 12usize] = b"focusWindow\0";
pub const XNResourceName: &'static [u8; 13usize] = b"resourceName\0";
pub const XNResourceClass: &'static [u8; 14usize] = b"resourceClass\0";
pub const XNGeometryCallback: &'static [u8; 17usize] = b"geometryCallback\0";
pub const XNDestroyCallback: &'static [u8; 16usize] = b"destroyCallback\0";
pub const XNFilterEvents: &'static [u8; 13usize] = b"filterEvents\0";
pub const XNPreeditStartCallback: &'static [u8; 21usize] = b"preeditStartCallback\0";
pub const XNPreeditDoneCallback: &'static [u8; 20usize] = b"preeditDoneCallback\0";
pub const XNPreeditDrawCallback: &'static [u8; 20usize] = b"preeditDrawCallback\0";
pub const XNPreeditCaretCallback: &'static [u8; 21usize] = b"preeditCaretCallback\0";
pub const XNPreeditStateNotifyCallback: &'static [u8; 27usize] = b"preeditStateNotifyCallback\0";
pub const XNPreeditAttributes: &'static [u8; 18usize] = b"preeditAttributes\0";
pub const XNStatusStartCallback: &'static [u8; 20usize] = b"statusStartCallback\0";
pub const XNStatusDoneCallback: &'static [u8; 19usize] = b"statusDoneCallback\0";
pub const XNStatusDrawCallback: &'static [u8; 19usize] = b"statusDrawCallback\0";
pub const XNStatusAttributes: &'static [u8; 17usize] = b"statusAttributes\0";
pub const XNArea: &'static [u8; 5usize] = b"area\0";
pub const XNAreaNeeded: &'static [u8; 11usize] = b"areaNeeded\0";
pub const XNSpotLocation: &'static [u8; 13usize] = b"spotLocation\0";
pub const XNColormap: &'static [u8; 9usize] = b"colorMap\0";
pub const XNStdColormap: &'static [u8; 12usize] = b"stdColorMap\0";
pub const XNForeground: &'static [u8; 11usize] = b"foreground\0";
pub const XNBackground: &'static [u8; 11usize] = b"background\0";
pub const XNBackgroundPixmap: &'static [u8; 17usize] = b"backgroundPixmap\0";
pub const XNFontSet: &'static [u8; 8usize] = b"fontSet\0";
pub const XNLineSpace: &'static [u8; 10usize] = b"lineSpace\0";
pub const XNCursor: &'static [u8; 7usize] = b"cursor\0";
pub const XNQueryIMValuesList: &'static [u8; 18usize] = b"queryIMValuesList\0";
pub const XNQueryICValuesList: &'static [u8; 18usize] = b"queryICValuesList\0";
pub const XNVisiblePosition: &'static [u8; 16usize] = b"visiblePosition\0";
pub const XNR6PreeditCallback: &'static [u8; 18usize] = b"r6PreeditCallback\0";
pub const XNStringConversionCallback: &'static [u8; 25usize] = b"stringConversionCallback\0";
pub const XNStringConversion: &'static [u8; 17usize] = b"stringConversion\0";
pub const XNResetState: &'static [u8; 11usize] = b"resetState\0";
pub const XNHotKey: &'static [u8; 7usize] = b"hotKey\0";
pub const XNHotKeyState: &'static [u8; 12usize] = b"hotKeyState\0";
pub const XNPreeditState: &'static [u8; 13usize] = b"preeditState\0";
pub const XNSeparatorofNestedList: &'static [u8; 22usize] = b"separatorofNestedList\0";
pub const XBufferOverflow: i32 = -1;
pub const XLookupNone: u32 = 1;
pub const XLookupChars: u32 = 2;
pub const XLookupKeySym: u32 = 3;
pub const XLookupBoth: u32 = 4;
pub const XIMReverse: u32 = 1;
pub const XIMUnderline: u32 = 2;
pub const XIMHighlight: u32 = 4;
pub const XIMPrimary: u32 = 32;
pub const XIMSecondary: u32 = 64;
pub const XIMTertiary: u32 = 128;
pub const XIMVisibleToForward: u32 = 256;
pub const XIMVisibleToBackword: u32 = 512;
pub const XIMVisibleToCenter: u32 = 1024;
pub const XIMPreeditUnKnown: u32 = 0;
pub const XIMPreeditEnable: u32 = 1;
pub const XIMPreeditDisable: u32 = 2;
pub const XIMInitialState: u32 = 1;
pub const XIMPreserveState: u32 = 2;
pub const XIMStringConversionLeftEdge: u32 = 1;
pub const XIMStringConversionRightEdge: u32 = 2;
pub const XIMStringConversionTopEdge: u32 = 4;
pub const XIMStringConversionBottomEdge: u32 = 8;
pub const XIMStringConversionConcealed: u32 = 16;
pub const XIMStringConversionWrapped: u32 = 32;
pub const XIMStringConversionBuffer: u32 = 1;
pub const XIMStringConversionLine: u32 = 2;
pub const XIMStringConversionWord: u32 = 3;
pub const XIMStringConversionChar: u32 = 4;
pub const XIMStringConversionSubstitution: u32 = 1;
pub const XIMStringConversionRetrieval: u32 = 2;
pub const XIMHotKeyStateON: u32 = 1;
pub const XIMHotKeyStateOFF: u32 = 2;
pub const XATOM_H: u32 = 1;
extern "C" {
    #[doc = " Get the name of the platform."]
    #[doc = ""]
    #[doc = " Here are the names returned for some (but not all) supported platforms:"]
    #[doc = ""]
    #[doc = " - \"Windows\""]
    #[doc = " - \"Mac OS X\""]
    #[doc = " - \"Linux\""]
    #[doc = " - \"iOS\""]
    #[doc = " - \"Android\""]
    #[doc = ""]
    #[doc = " \\returns the name of the platform. If the correct platform name is not"]
    #[doc = "          available, returns a string beginning with the text \"Unknown\"."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_GetPlatform() -> *const libc::c_char;
}
pub type size_t = libc::c_ulong;
pub type wchar_t = libc::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: libc::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type __u_char = libc::c_uchar;
pub type __u_short = libc::c_ushort;
pub type __u_int = libc::c_uint;
pub type __u_long = libc::c_ulong;
pub type __int8_t = libc::c_schar;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_long;
pub type __uint64_t = libc::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = libc::c_long;
pub type __u_quad_t = libc::c_ulong;
pub type __intmax_t = libc::c_long;
pub type __uintmax_t = libc::c_ulong;
pub type __dev_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __ino64_t = libc::c_ulong;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __pid_t = libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __fsid_t {
    pub __val: [libc::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = libc::c_long;
pub type __rlim_t = libc::c_ulong;
pub type __rlim64_t = libc::c_ulong;
pub type __id_t = libc::c_uint;
pub type __time_t = libc::c_long;
pub type __useconds_t = libc::c_uint;
pub type __suseconds_t = libc::c_long;
pub type __suseconds64_t = libc::c_long;
pub type __daddr_t = libc::c_int;
pub type __key_t = libc::c_int;
pub type __clockid_t = libc::c_int;
pub type __timer_t = *mut libc::c_void;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __blkcnt64_t = libc::c_long;
pub type __fsblkcnt_t = libc::c_ulong;
pub type __fsblkcnt64_t = libc::c_ulong;
pub type __fsfilcnt_t = libc::c_ulong;
pub type __fsfilcnt64_t = libc::c_ulong;
pub type __fsword_t = libc::c_long;
pub type __ssize_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type __syscall_ulong_t = libc::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut libc::c_char;
pub type __intptr_t = libc::c_long;
pub type __socklen_t = libc::c_uint;
pub type __sig_atomic_t = libc::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = libc::c_schar;
pub type int_fast16_t = libc::c_long;
pub type int_fast32_t = libc::c_long;
pub type int_fast64_t = libc::c_long;
pub type uint_fast8_t = libc::c_uchar;
pub type uint_fast16_t = libc::c_ulong;
pub type uint_fast32_t = libc::c_ulong;
pub type uint_fast64_t = libc::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_bool {
    SDL_FALSE = 0,
    SDL_TRUE = 1,
}
pub type Sint8 = i8;
pub type Uint8 = u8;
pub type Sint16 = i16;
pub type Uint16 = u16;
pub type Sint32 = i32;
pub type Uint32 = u32;
pub type Sint64 = i64;
pub type Uint64 = u64;
pub type SDL_compile_time_assert_uint8 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_sint8 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_uint16 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_sint16 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_uint32 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_sint32 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_uint64 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_sint64 = [libc::c_int; 1usize];
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_DUMMY_ENUM {
    DUMMY_ENUM_VALUE = 0,
}
pub type SDL_compile_time_assert_enum = [libc::c_int; 1usize];
extern "C" {
    pub fn SDL_malloc(size: size_t) -> *mut libc::c_void;
}
extern "C" {
    pub fn SDL_calloc(nmemb: size_t, size: size_t) -> *mut libc::c_void;
}
extern "C" {
    pub fn SDL_realloc(mem: *mut libc::c_void, size: size_t) -> *mut libc::c_void;
}
extern "C" {
    pub fn SDL_free(mem: *mut libc::c_void);
}
pub type SDL_malloc_func =
    ::core::option::Option<unsafe extern "C" fn(size: size_t) -> *mut libc::c_void>;
pub type SDL_calloc_func =
    ::core::option::Option<unsafe extern "C" fn(nmemb: size_t, size: size_t) -> *mut libc::c_void>;
pub type SDL_realloc_func = ::core::option::Option<
    unsafe extern "C" fn(mem: *mut libc::c_void, size: size_t) -> *mut libc::c_void,
>;
pub type SDL_free_func = ::core::option::Option<unsafe extern "C" fn(mem: *mut libc::c_void)>;
extern "C" {
    #[doc = " Get the current set of SDL memory functions"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.7."]
    pub fn SDL_GetMemoryFunctions(
        malloc_func: *mut SDL_malloc_func,
        calloc_func: *mut SDL_calloc_func,
        realloc_func: *mut SDL_realloc_func,
        free_func: *mut SDL_free_func,
    );
}
extern "C" {
    #[doc = " Replace SDL's memory allocation functions with a custom set"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.7."]
    pub fn SDL_SetMemoryFunctions(
        malloc_func: SDL_malloc_func,
        calloc_func: SDL_calloc_func,
        realloc_func: SDL_realloc_func,
        free_func: SDL_free_func,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the number of outstanding (unfreed) allocations"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.7."]
    pub fn SDL_GetNumAllocations() -> libc::c_int;
}
extern "C" {
    pub fn SDL_getenv(name: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_setenv(
        name: *const libc::c_char,
        value: *const libc::c_char,
        overwrite: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn SDL_qsort(
        base: *mut libc::c_void,
        nmemb: size_t,
        size: size_t,
        compare: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const libc::c_void,
                arg2: *const libc::c_void,
            ) -> libc::c_int,
        >,
    );
}
extern "C" {
    pub fn SDL_abs(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_isalpha(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_isalnum(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_isblank(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_iscntrl(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_isdigit(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_isxdigit(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_ispunct(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_isspace(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_isupper(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_islower(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_isprint(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_isgraph(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_toupper(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_tolower(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_crc32(crc: Uint32, data: *const libc::c_void, len: size_t) -> Uint32;
}
extern "C" {
    pub fn SDL_memset(dst: *mut libc::c_void, c: libc::c_int, len: size_t) -> *mut libc::c_void;
}
extern "C" {
    pub fn SDL_memcpy(
        dst: *mut libc::c_void,
        src: *const libc::c_void,
        len: size_t,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn SDL_memmove(
        dst: *mut libc::c_void,
        src: *const libc::c_void,
        len: size_t,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn SDL_memcmp(s1: *const libc::c_void, s2: *const libc::c_void, len: size_t)
        -> libc::c_int;
}
extern "C" {
    pub fn SDL_wcslen(wstr: *const wchar_t) -> size_t;
}
extern "C" {
    pub fn SDL_wcslcpy(dst: *mut wchar_t, src: *const wchar_t, maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn SDL_wcslcat(dst: *mut wchar_t, src: *const wchar_t, maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn SDL_wcsdup(wstr: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn SDL_wcsstr(haystack: *const wchar_t, needle: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn SDL_wcscmp(str1: *const wchar_t, str2: *const wchar_t) -> libc::c_int;
}
extern "C" {
    pub fn SDL_wcsncmp(str1: *const wchar_t, str2: *const wchar_t, maxlen: size_t) -> libc::c_int;
}
extern "C" {
    pub fn SDL_wcscasecmp(str1: *const wchar_t, str2: *const wchar_t) -> libc::c_int;
}
extern "C" {
    pub fn SDL_wcsncasecmp(str1: *const wchar_t, str2: *const wchar_t, len: size_t) -> libc::c_int;
}
extern "C" {
    pub fn SDL_strlen(str: *const libc::c_char) -> size_t;
}
extern "C" {
    pub fn SDL_strlcpy(dst: *mut libc::c_char, src: *const libc::c_char, maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn SDL_utf8strlcpy(
        dst: *mut libc::c_char,
        src: *const libc::c_char,
        dst_bytes: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn SDL_strlcat(dst: *mut libc::c_char, src: *const libc::c_char, maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn SDL_strdup(str: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_strrev(str: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_strupr(str: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_strlwr(str: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_strchr(str: *const libc::c_char, c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_strrchr(str: *const libc::c_char, c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_strstr(
        haystack: *const libc::c_char,
        needle: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_strtokr(
        s1: *mut libc::c_char,
        s2: *const libc::c_char,
        saveptr: *mut *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_utf8strlen(str: *const libc::c_char) -> size_t;
}
extern "C" {
    pub fn SDL_itoa(
        value: libc::c_int,
        str: *mut libc::c_char,
        radix: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_uitoa(
        value: libc::c_uint,
        str: *mut libc::c_char,
        radix: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_ltoa(
        value: libc::c_long,
        str: *mut libc::c_char,
        radix: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_ultoa(
        value: libc::c_ulong,
        str: *mut libc::c_char,
        radix: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_lltoa(
        value: Sint64,
        str: *mut libc::c_char,
        radix: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_ulltoa(
        value: Uint64,
        str: *mut libc::c_char,
        radix: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_atoi(str: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn SDL_atof(str: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn SDL_strtol(
        str: *const libc::c_char,
        endp: *mut *mut libc::c_char,
        base: libc::c_int,
    ) -> libc::c_long;
}
extern "C" {
    pub fn SDL_strtoul(
        str: *const libc::c_char,
        endp: *mut *mut libc::c_char,
        base: libc::c_int,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn SDL_strtoll(
        str: *const libc::c_char,
        endp: *mut *mut libc::c_char,
        base: libc::c_int,
    ) -> Sint64;
}
extern "C" {
    pub fn SDL_strtoull(
        str: *const libc::c_char,
        endp: *mut *mut libc::c_char,
        base: libc::c_int,
    ) -> Uint64;
}
extern "C" {
    pub fn SDL_strtod(str: *const libc::c_char, endp: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn SDL_strcmp(str1: *const libc::c_char, str2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn SDL_strncmp(
        str1: *const libc::c_char,
        str2: *const libc::c_char,
        maxlen: size_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn SDL_strcasecmp(str1: *const libc::c_char, str2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn SDL_strncasecmp(
        str1: *const libc::c_char,
        str2: *const libc::c_char,
        len: size_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn SDL_sscanf(text: *const libc::c_char, fmt: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn SDL_vsscanf(
        text: *const libc::c_char,
        fmt: *const libc::c_char,
        ap: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn SDL_snprintf(
        text: *mut libc::c_char,
        maxlen: size_t,
        fmt: *const libc::c_char,
        ...
    ) -> libc::c_int;
}
extern "C" {
    pub fn SDL_vsnprintf(
        text: *mut libc::c_char,
        maxlen: size_t,
        fmt: *const libc::c_char,
        ap: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn SDL_asprintf(strp: *mut *mut libc::c_char, fmt: *const libc::c_char, ...)
        -> libc::c_int;
}
extern "C" {
    pub fn SDL_vasprintf(
        strp: *mut *mut libc::c_char,
        fmt: *const libc::c_char,
        ap: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Use this function to compute arc cosine of `x`."]
    #[doc = ""]
    #[doc = " The definition of `y = acos(x)` is `x = cos(y)`."]
    #[doc = ""]
    #[doc = " Domain: `-1 <= x <= 1`"]
    #[doc = ""]
    #[doc = " Range: `0 <= y <= Pi`"]
    #[doc = ""]
    #[doc = " \\param x floating point value, in radians."]
    #[doc = " \\returns arc cosine of `x`."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.2."]
    pub fn SDL_acos(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_acosf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_asin(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_asinf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_atan(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_atanf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_atan2(y: f64, x: f64) -> f64;
}
extern "C" {
    pub fn SDL_atan2f(y: f32, x: f32) -> f32;
}
extern "C" {
    pub fn SDL_ceil(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_ceilf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_copysign(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn SDL_copysignf(x: f32, y: f32) -> f32;
}
extern "C" {
    pub fn SDL_cos(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_cosf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_exp(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_expf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_fabs(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_fabsf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_floor(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_floorf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_trunc(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_truncf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_fmod(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn SDL_fmodf(x: f32, y: f32) -> f32;
}
extern "C" {
    pub fn SDL_log(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_logf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_log10(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_log10f(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_pow(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn SDL_powf(x: f32, y: f32) -> f32;
}
extern "C" {
    pub fn SDL_round(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_roundf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_lround(x: f64) -> libc::c_long;
}
extern "C" {
    pub fn SDL_lroundf(x: f32) -> libc::c_long;
}
extern "C" {
    pub fn SDL_scalbn(x: f64, n: libc::c_int) -> f64;
}
extern "C" {
    pub fn SDL_scalbnf(x: f32, n: libc::c_int) -> f32;
}
extern "C" {
    pub fn SDL_sin(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_sinf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_sqrt(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_sqrtf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_tan(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_tanf(x: f32) -> f32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SDL_iconv_t {
    _unused: [u8; 0],
}
pub type SDL_iconv_t = *mut _SDL_iconv_t;
extern "C" {
    pub fn SDL_iconv_open(
        tocode: *const libc::c_char,
        fromcode: *const libc::c_char,
    ) -> SDL_iconv_t;
}
extern "C" {
    pub fn SDL_iconv_close(cd: SDL_iconv_t) -> libc::c_int;
}
extern "C" {
    pub fn SDL_iconv(
        cd: SDL_iconv_t,
        inbuf: *mut *const libc::c_char,
        inbytesleft: *mut size_t,
        outbuf: *mut *mut libc::c_char,
        outbytesleft: *mut size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " This function converts a string between encodings in one pass, returning a"]
    #[doc = " string that must be freed with SDL_free() or NULL on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_iconv_string(
        tocode: *const libc::c_char,
        fromcode: *const libc::c_char,
        inbuf: *const libc::c_char,
        inbytesleft: size_t,
    ) -> *mut libc::c_char;
}
#[doc = "  The prototype for the application's main() function"]
pub type SDL_main_func = ::core::option::Option<
    unsafe extern "C" fn(argc: libc::c_int, argv: *mut *mut libc::c_char) -> libc::c_int,
>;
extern "C" {
    pub fn SDL_main(argc: libc::c_int, argv: *mut *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Circumvent failure of SDL_Init() when not using SDL_main() as an entry"]
    #[doc = " point."]
    #[doc = ""]
    #[doc = " This function is defined in SDL_main.h, along with the preprocessor rule to"]
    #[doc = " redefine main() as SDL_main(). Thus to ensure that your main() function"]
    #[doc = " will not be changed it is necessary to define SDL_MAIN_HANDLED before"]
    #[doc = " including SDL.h."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_Init"]
    pub fn SDL_SetMainReady();
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_AssertState {
    #[doc = "< Retry the assert immediately."]
    SDL_ASSERTION_RETRY = 0,
    #[doc = "< Make the debugger trigger a breakpoint."]
    SDL_ASSERTION_BREAK = 1,
    #[doc = "< Terminate the program."]
    SDL_ASSERTION_ABORT = 2,
    #[doc = "< Ignore the assert."]
    SDL_ASSERTION_IGNORE = 3,
    #[doc = "< Ignore the assert from now on."]
    SDL_ASSERTION_ALWAYS_IGNORE = 4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_AssertData {
    pub always_ignore: libc::c_int,
    pub trigger_count: libc::c_uint,
    pub condition: *const libc::c_char,
    pub filename: *const libc::c_char,
    pub linenum: libc::c_int,
    pub function: *const libc::c_char,
    pub next: *const SDL_AssertData,
}
#[test]
fn bindgen_test_layout_SDL_AssertData() {
    assert_eq!(
        ::core::mem::size_of::<SDL_AssertData>(),
        48usize,
        concat!("Size of: ", stringify!(SDL_AssertData))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_AssertData>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_AssertData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AssertData>())).always_ignore as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AssertData),
            "::",
            stringify!(always_ignore)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AssertData>())).trigger_count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AssertData),
            "::",
            stringify!(trigger_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AssertData>())).condition as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AssertData),
            "::",
            stringify!(condition)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AssertData>())).filename as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AssertData),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AssertData>())).linenum as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AssertData),
            "::",
            stringify!(linenum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AssertData>())).function as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AssertData),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AssertData>())).next as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AssertData),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub fn SDL_ReportAssertion(
        arg1: *mut SDL_AssertData,
        arg2: *const libc::c_char,
        arg3: *const libc::c_char,
        arg4: libc::c_int,
    ) -> SDL_AssertState;
}
#[doc = " A callback that fires when an SDL assertion fails."]
#[doc = ""]
#[doc = " \\param data a pointer to the SDL_AssertData structure corresponding to the"]
#[doc = "             current assertion"]
#[doc = " \\param userdata what was passed as `userdata` to SDL_SetAssertionHandler()"]
#[doc = " \\returns an SDL_AssertState value indicating how to handle the failure."]
pub type SDL_AssertionHandler = ::core::option::Option<
    unsafe extern "C" fn(
        data: *const SDL_AssertData,
        userdata: *mut libc::c_void,
    ) -> SDL_AssertState,
>;
extern "C" {
    #[doc = " Set an application-defined assertion handler."]
    #[doc = ""]
    #[doc = " This function allows an application to show its own assertion UI and/or"]
    #[doc = " force the response to an assertion failure. If the application doesn't"]
    #[doc = " provide this, SDL will try to do the right thing, popping up a"]
    #[doc = " system-specific GUI dialog, and probably minimizing any fullscreen windows."]
    #[doc = ""]
    #[doc = " This callback may fire from any thread, but it runs wrapped in a mutex, so"]
    #[doc = " it will only fire from one thread at a time."]
    #[doc = ""]
    #[doc = " This callback is NOT reset to SDL's internal handler upon SDL_Quit()!"]
    #[doc = ""]
    #[doc = " \\param handler the SDL_AssertionHandler function to call when an assertion"]
    #[doc = "                fails or NULL for the default handler"]
    #[doc = " \\param userdata a pointer that is passed to `handler`"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetAssertionHandler"]
    pub fn SDL_SetAssertionHandler(handler: SDL_AssertionHandler, userdata: *mut libc::c_void);
}
extern "C" {
    #[doc = " Get the default assertion handler."]
    #[doc = ""]
    #[doc = " This returns the function pointer that is called by default when an"]
    #[doc = " assertion is triggered. This is an internal function provided by SDL, that"]
    #[doc = " is used for assertions when SDL_SetAssertionHandler() hasn't been used to"]
    #[doc = " provide a different function."]
    #[doc = ""]
    #[doc = " \\returns the default SDL_AssertionHandler that is called when an assert"]
    #[doc = "          triggers."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.2."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetAssertionHandler"]
    pub fn SDL_GetDefaultAssertionHandler() -> SDL_AssertionHandler;
}
extern "C" {
    #[doc = " Get the current assertion handler."]
    #[doc = ""]
    #[doc = " This returns the function pointer that is called when an assertion is"]
    #[doc = " triggered. This is either the value last passed to"]
    #[doc = " SDL_SetAssertionHandler(), or if no application-specified function is set,"]
    #[doc = " is equivalent to calling SDL_GetDefaultAssertionHandler()."]
    #[doc = ""]
    #[doc = " The parameter `puserdata` is a pointer to a void*, which will store the"]
    #[doc = " \"userdata\" pointer that was passed to SDL_SetAssertionHandler(). This value"]
    #[doc = " will always be NULL for the default handler. If you don't care about this"]
    #[doc = " data, it is safe to pass a NULL pointer to this function to ignore it."]
    #[doc = ""]
    #[doc = " \\param puserdata pointer which is filled with the \"userdata\" pointer that"]
    #[doc = "                  was passed to SDL_SetAssertionHandler()"]
    #[doc = " \\returns the SDL_AssertionHandler that is called when an assert triggers."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.2."]
    #[doc = ""]
    #[doc = " \\sa SDL_SetAssertionHandler"]
    pub fn SDL_GetAssertionHandler(puserdata: *mut *mut libc::c_void) -> SDL_AssertionHandler;
}
extern "C" {
    #[doc = " Get a list of all assertion failures."]
    #[doc = ""]
    #[doc = " This function gets all assertions triggered since the last call to"]
    #[doc = " SDL_ResetAssertionReport(), or the start of the program."]
    #[doc = ""]
    #[doc = " The proper way to examine this data looks something like this:"]
    #[doc = ""]
    #[doc = " ```c"]
    #[doc = " const SDL_AssertData *item = SDL_GetAssertionReport();"]
    #[doc = " while (item) {"]
    #[doc = "    printf(\"'%s', %s (%s:%d), triggered %u times, always ignore: %s.\\\\n\","]
    #[doc = "           item->condition, item->function, item->filename,"]
    #[doc = "           item->linenum, item->trigger_count,"]
    #[doc = "           item->always_ignore ? \"yes\" : \"no\");"]
    #[doc = "    item = item->next;"]
    #[doc = " }"]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " \\returns a list of all failed assertions or NULL if the list is empty. This"]
    #[doc = "          memory should not be modified or freed by the application."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_ResetAssertionReport"]
    pub fn SDL_GetAssertionReport() -> *const SDL_AssertData;
}
extern "C" {
    #[doc = " Clear the list of all assertion failures."]
    #[doc = ""]
    #[doc = " This function will clear the list of all assertions triggered up to that"]
    #[doc = " point. Immediately following this call, SDL_GetAssertionReport will return"]
    #[doc = " no items. In addition, any previously-triggered assertions will be reset to"]
    #[doc = " a trigger_count of zero, and their always_ignore state will be false."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetAssertionReport"]
    pub fn SDL_ResetAssertionReport();
}
pub type SDL_SpinLock = libc::c_int;
extern "C" {
    #[doc = " Try to lock a spin lock by setting it to a non-zero value."]
    #[doc = ""]
    #[doc = " ***Please note that spinlocks are dangerous if you don't know what you're"]
    #[doc = " doing. Please be careful using any sort of spinlock!***"]
    #[doc = ""]
    #[doc = " \\param lock a pointer to a lock variable"]
    #[doc = " \\returns SDL_TRUE if the lock succeeded, SDL_FALSE if the lock is already"]
    #[doc = "          held."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_AtomicLock"]
    #[doc = " \\sa SDL_AtomicUnlock"]
    pub fn SDL_AtomicTryLock(lock: *mut SDL_SpinLock) -> SDL_bool;
}
extern "C" {
    #[doc = " Lock a spin lock by setting it to a non-zero value."]
    #[doc = ""]
    #[doc = " ***Please note that spinlocks are dangerous if you don't know what you're"]
    #[doc = " doing. Please be careful using any sort of spinlock!***"]
    #[doc = ""]
    #[doc = " \\param lock a pointer to a lock variable"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_AtomicTryLock"]
    #[doc = " \\sa SDL_AtomicUnlock"]
    pub fn SDL_AtomicLock(lock: *mut SDL_SpinLock);
}
extern "C" {
    #[doc = " Unlock a spin lock by setting it to 0."]
    #[doc = ""]
    #[doc = " Always returns immediately."]
    #[doc = ""]
    #[doc = " ***Please note that spinlocks are dangerous if you don't know what you're"]
    #[doc = " doing. Please be careful using any sort of spinlock!***"]
    #[doc = ""]
    #[doc = " \\param lock a pointer to a lock variable"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_AtomicLock"]
    #[doc = " \\sa SDL_AtomicTryLock"]
    pub fn SDL_AtomicUnlock(lock: *mut SDL_SpinLock);
}
extern "C" {
    #[doc = " Memory barriers are designed to prevent reads and writes from being"]
    #[doc = " reordered by the compiler and being seen out of order on multi-core CPUs."]
    #[doc = ""]
    #[doc = " A typical pattern would be for thread A to write some data and a flag, and"]
    #[doc = " for thread B to read the flag and get the data. In this case you would"]
    #[doc = " insert a release barrier between writing the data and the flag,"]
    #[doc = " guaranteeing that the data write completes no later than the flag is"]
    #[doc = " written, and you would insert an acquire barrier between reading the flag"]
    #[doc = " and reading the data, to ensure that all the reads associated with the flag"]
    #[doc = " have completed."]
    #[doc = ""]
    #[doc = " In this pattern you should always see a release barrier paired with an"]
    #[doc = " acquire barrier and you should gate the data reads/writes with a single"]
    #[doc = " flag variable."]
    #[doc = ""]
    #[doc = " For more information on these semantics, take a look at the blog post:"]
    #[doc = " http://preshing.com/20120913/acquire-and-release-semantics"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.6."]
    pub fn SDL_MemoryBarrierReleaseFunction();
}
extern "C" {
    pub fn SDL_MemoryBarrierAcquireFunction();
}
#[doc = " \\brief A type representing an atomic integer value.  It is a struct"]
#[doc = "        so people don't accidentally use numeric operations on it."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_atomic_t {
    pub value: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_atomic_t() {
    assert_eq!(
        ::core::mem::size_of::<SDL_atomic_t>(),
        4usize,
        concat!("Size of: ", stringify!(SDL_atomic_t))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_atomic_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_atomic_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_atomic_t>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_atomic_t),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Set an atomic variable to a new value if it is currently an old value."]
    #[doc = ""]
    #[doc = " ***Note: If you don't know what this function is for, you shouldn't use"]
    #[doc = " it!***"]
    #[doc = ""]
    #[doc = " \\param a a pointer to an SDL_atomic_t variable to be modified"]
    #[doc = " \\param oldval the old value"]
    #[doc = " \\param newval the new value"]
    #[doc = " \\returns SDL_TRUE if the atomic variable was set, SDL_FALSE otherwise."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_AtomicCASPtr"]
    #[doc = " \\sa SDL_AtomicGet"]
    #[doc = " \\sa SDL_AtomicSet"]
    pub fn SDL_AtomicCAS(
        a: *mut SDL_atomic_t,
        oldval: libc::c_int,
        newval: libc::c_int,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = " Set an atomic variable to a value."]
    #[doc = ""]
    #[doc = " This function also acts as a full memory barrier."]
    #[doc = ""]
    #[doc = " ***Note: If you don't know what this function is for, you shouldn't use"]
    #[doc = " it!***"]
    #[doc = ""]
    #[doc = " \\param a a pointer to an SDL_atomic_t variable to be modified"]
    #[doc = " \\param v the desired value"]
    #[doc = " \\returns the previous value of the atomic variable."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.2."]
    #[doc = ""]
    #[doc = " \\sa SDL_AtomicGet"]
    pub fn SDL_AtomicSet(a: *mut SDL_atomic_t, v: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the value of an atomic variable."]
    #[doc = ""]
    #[doc = " ***Note: If you don't know what this function is for, you shouldn't use"]
    #[doc = " it!***"]
    #[doc = ""]
    #[doc = " \\param a a pointer to an SDL_atomic_t variable"]
    #[doc = " \\returns the current value of an atomic variable."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.2."]
    #[doc = ""]
    #[doc = " \\sa SDL_AtomicSet"]
    pub fn SDL_AtomicGet(a: *mut SDL_atomic_t) -> libc::c_int;
}
extern "C" {
    #[doc = " Add to an atomic variable."]
    #[doc = ""]
    #[doc = " This function also acts as a full memory barrier."]
    #[doc = ""]
    #[doc = " ***Note: If you don't know what this function is for, you shouldn't use"]
    #[doc = " it!***"]
    #[doc = ""]
    #[doc = " \\param a a pointer to an SDL_atomic_t variable to be modified"]
    #[doc = " \\param v the desired value to add"]
    #[doc = " \\returns the previous value of the atomic variable."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.2."]
    #[doc = ""]
    #[doc = " \\sa SDL_AtomicDecRef"]
    #[doc = " \\sa SDL_AtomicIncRef"]
    pub fn SDL_AtomicAdd(a: *mut SDL_atomic_t, v: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Set a pointer to a new value if it is currently an old value."]
    #[doc = ""]
    #[doc = " ***Note: If you don't know what this function is for, you shouldn't use"]
    #[doc = " it!***"]
    #[doc = ""]
    #[doc = " \\param a a pointer to a pointer"]
    #[doc = " \\param oldval the old pointer value"]
    #[doc = " \\param newval the new pointer value"]
    #[doc = " \\returns SDL_TRUE if the pointer was set, SDL_FALSE otherwise."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_AtomicCAS"]
    #[doc = " \\sa SDL_AtomicGetPtr"]
    #[doc = " \\sa SDL_AtomicSetPtr"]
    pub fn SDL_AtomicCASPtr(
        a: *mut *mut libc::c_void,
        oldval: *mut libc::c_void,
        newval: *mut libc::c_void,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = " Set a pointer to a value atomically."]
    #[doc = ""]
    #[doc = " ***Note: If you don't know what this function is for, you shouldn't use"]
    #[doc = " it!***"]
    #[doc = ""]
    #[doc = " \\param a a pointer to a pointer"]
    #[doc = " \\param v the desired pointer value"]
    #[doc = " \\returns the previous value of the pointer."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.2."]
    #[doc = ""]
    #[doc = " \\sa SDL_AtomicCASPtr"]
    #[doc = " \\sa SDL_AtomicGetPtr"]
    pub fn SDL_AtomicSetPtr(a: *mut *mut libc::c_void, v: *mut libc::c_void) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Get the value of a pointer atomically."]
    #[doc = ""]
    #[doc = " ***Note: If you don't know what this function is for, you shouldn't use"]
    #[doc = " it!***"]
    #[doc = ""]
    #[doc = " \\param a a pointer to a pointer"]
    #[doc = " \\returns the current value of a pointer."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.2."]
    #[doc = ""]
    #[doc = " \\sa SDL_AtomicCASPtr"]
    #[doc = " \\sa SDL_AtomicSetPtr"]
    pub fn SDL_AtomicGetPtr(a: *mut *mut libc::c_void) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Set the SDL error message for the current thread."]
    #[doc = ""]
    #[doc = " Calling this function will replace any previous error message that was set."]
    #[doc = ""]
    #[doc = " This function always returns -1, since SDL frequently uses -1 to signify an"]
    #[doc = " failing result, leading to this idiom:"]
    #[doc = ""]
    #[doc = " ```c"]
    #[doc = " if (error_code) {"]
    #[doc = "     return SDL_SetError(\"This operation has failed: %d\", error_code);"]
    #[doc = " }"]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " \\param fmt a printf()-style message format string"]
    #[doc = " \\param ... additional parameters matching % tokens in the `fmt` string, if"]
    #[doc = "            any"]
    #[doc = " \\returns always -1."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_ClearError"]
    #[doc = " \\sa SDL_GetError"]
    pub fn SDL_SetError(fmt: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    #[doc = " Retrieve a message about the last error that occurred on the current"]
    #[doc = " thread."]
    #[doc = ""]
    #[doc = " It is possible for multiple errors to occur before calling SDL_GetError()."]
    #[doc = " Only the last error is returned."]
    #[doc = ""]
    #[doc = " The message is only applicable when an SDL function has signaled an error."]
    #[doc = " You must check the return values of SDL function calls to determine when to"]
    #[doc = " appropriately call SDL_GetError(). You should *not* use the results of"]
    #[doc = " SDL_GetError() to decide if an error has occurred! Sometimes SDL will set"]
    #[doc = " an error string even when reporting success."]
    #[doc = ""]
    #[doc = " SDL will *not* clear the error string for successful API calls. You *must*"]
    #[doc = " check return values for failure cases before you can assume the error"]
    #[doc = " string applies."]
    #[doc = ""]
    #[doc = " Error strings are set per-thread, so an error set in a different thread"]
    #[doc = " will not interfere with the current thread's operation."]
    #[doc = ""]
    #[doc = " The returned string is internally allocated and must not be freed by the"]
    #[doc = " application."]
    #[doc = ""]
    #[doc = " \\returns a message with information about the specific error that occurred,"]
    #[doc = "          or an empty string if there hasn't been an error message set since"]
    #[doc = "          the last call to SDL_ClearError(). The message is only applicable"]
    #[doc = "          when an SDL function has signaled an error. You must check the"]
    #[doc = "          return values of SDL function calls to determine when to"]
    #[doc = "          appropriately call SDL_GetError()."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_ClearError"]
    #[doc = " \\sa SDL_SetError"]
    pub fn SDL_GetError() -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the last error message that was set for the current thread."]
    #[doc = ""]
    #[doc = " This allows the caller to copy the error string into a provided buffer, but"]
    #[doc = " otherwise operates exactly the same as SDL_GetError()."]
    #[doc = ""]
    #[doc = " \\param errstr A buffer to fill with the last error message that was set for"]
    #[doc = "               the current thread"]
    #[doc = " \\param maxlen The size of the buffer pointed to by the errstr parameter"]
    #[doc = " \\returns the pointer passed in as the `errstr` parameter."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.14."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetError"]
    pub fn SDL_GetErrorMsg(errstr: *mut libc::c_char, maxlen: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Clear any previous error message for this thread."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetError"]
    #[doc = " \\sa SDL_SetError"]
    pub fn SDL_ClearError();
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_errorcode {
    SDL_ENOMEM = 0,
    SDL_EFREAD = 1,
    SDL_EFWRITE = 2,
    SDL_EFSEEK = 3,
    SDL_UNSUPPORTED = 4,
    SDL_LASTERROR = 5,
}
extern "C" {
    pub fn SDL_Error(code: SDL_errorcode) -> libc::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_mutex {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create a new mutex."]
    #[doc = ""]
    #[doc = " All newly-created mutexes begin in the _unlocked_ state."]
    #[doc = ""]
    #[doc = " Calls to SDL_LockMutex() will not return while the mutex is locked by"]
    #[doc = " another thread. See SDL_TryLockMutex() to attempt to lock without blocking."]
    #[doc = ""]
    #[doc = " SDL mutexes are reentrant."]
    #[doc = ""]
    #[doc = " \\returns the initialized and unlocked mutex or NULL on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_DestroyMutex"]
    #[doc = " \\sa SDL_LockMutex"]
    #[doc = " \\sa SDL_TryLockMutex"]
    #[doc = " \\sa SDL_UnlockMutex"]
    pub fn SDL_CreateMutex() -> *mut SDL_mutex;
}
extern "C" {
    #[doc = " Lock the mutex."]
    #[doc = ""]
    #[doc = " This will block until the mutex is available, which is to say it is in the"]
    #[doc = " unlocked state and the OS has chosen the caller as the next thread to lock"]
    #[doc = " it. Of all threads waiting to lock the mutex, only one may do so at a time."]
    #[doc = ""]
    #[doc = " It is legal for the owning thread to lock an already-locked mutex. It must"]
    #[doc = " unlock it the same number of times before it is actually made available for"]
    #[doc = " other threads in the system (this is known as a \"recursive mutex\")."]
    #[doc = ""]
    #[doc = " \\param mutex the mutex to lock"]
    #[doc = " \\return 0, or -1 on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_LockMutex(mutex: *mut SDL_mutex) -> libc::c_int;
}
extern "C" {
    #[doc = " Try to lock a mutex without blocking."]
    #[doc = ""]
    #[doc = " This works just like SDL_LockMutex(), but if the mutex is not available,"]
    #[doc = " this function returns `SDL_MUTEX_TIMEOUT` immediately."]
    #[doc = ""]
    #[doc = " This technique is useful if you need exclusive access to a resource but"]
    #[doc = " don't want to wait for it, and will return to it to try again later."]
    #[doc = ""]
    #[doc = " \\param mutex the mutex to try to lock"]
    #[doc = " \\returns 0, `SDL_MUTEX_TIMEDOUT`, or -1 on error; call SDL_GetError() for"]
    #[doc = "          more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateMutex"]
    #[doc = " \\sa SDL_DestroyMutex"]
    #[doc = " \\sa SDL_LockMutex"]
    #[doc = " \\sa SDL_UnlockMutex"]
    pub fn SDL_TryLockMutex(mutex: *mut SDL_mutex) -> libc::c_int;
}
extern "C" {
    #[doc = " Unlock the mutex."]
    #[doc = ""]
    #[doc = " It is legal for the owning thread to lock an already-locked mutex. It must"]
    #[doc = " unlock it the same number of times before it is actually made available for"]
    #[doc = " other threads in the system (this is known as a \"recursive mutex\")."]
    #[doc = ""]
    #[doc = " It is an error to unlock a mutex that has not been locked by the current"]
    #[doc = " thread, and doing so results in undefined behavior."]
    #[doc = ""]
    #[doc = " It is also an error to unlock a mutex that isn't locked at all."]
    #[doc = ""]
    #[doc = " \\param mutex the mutex to unlock."]
    #[doc = " \\returns 0, or -1 on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_UnlockMutex(mutex: *mut SDL_mutex) -> libc::c_int;
}
extern "C" {
    #[doc = " Destroy a mutex created with SDL_CreateMutex()."]
    #[doc = ""]
    #[doc = " This function must be called on any mutex that is no longer needed. Failure"]
    #[doc = " to destroy a mutex will result in a system memory or resource leak. While"]
    #[doc = " it is safe to destroy a mutex that is _unlocked_, it is not safe to attempt"]
    #[doc = " to destroy a locked mutex, and may result in undefined behavior depending"]
    #[doc = " on the platform."]
    #[doc = ""]
    #[doc = " \\param mutex the mutex to destroy"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateMutex"]
    #[doc = " \\sa SDL_LockMutex"]
    #[doc = " \\sa SDL_TryLockMutex"]
    #[doc = " \\sa SDL_UnlockMutex"]
    pub fn SDL_DestroyMutex(mutex: *mut SDL_mutex);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_semaphore {
    _unused: [u8; 0],
}
pub type SDL_sem = SDL_semaphore;
extern "C" {
    #[doc = " Create a semaphore."]
    #[doc = ""]
    #[doc = " This function creates a new semaphore and initializes it with the value"]
    #[doc = " `initial_value`. Each wait operation on the semaphore will atomically"]
    #[doc = " decrement the semaphore value and potentially block if the semaphore value"]
    #[doc = " is 0. Each post operation will atomically increment the semaphore value and"]
    #[doc = " wake waiting threads and allow them to retry the wait operation."]
    #[doc = ""]
    #[doc = " \\param initial_value the starting value of the semaphore"]
    #[doc = " \\returns a new semaphore or NULL on failure; call SDL_GetError() for more"]
    #[doc = "          information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_DestroySemaphore"]
    #[doc = " \\sa SDL_SemPost"]
    #[doc = " \\sa SDL_SemTryWait"]
    #[doc = " \\sa SDL_SemValue"]
    #[doc = " \\sa SDL_SemWait"]
    #[doc = " \\sa SDL_SemWaitTimeout"]
    pub fn SDL_CreateSemaphore(initial_value: Uint32) -> *mut SDL_sem;
}
extern "C" {
    #[doc = " Destroy a semaphore."]
    #[doc = ""]
    #[doc = " It is not safe to destroy a semaphore if there are threads currently"]
    #[doc = " waiting on it."]
    #[doc = ""]
    #[doc = " \\param sem the semaphore to destroy"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateSemaphore"]
    #[doc = " \\sa SDL_SemPost"]
    #[doc = " \\sa SDL_SemTryWait"]
    #[doc = " \\sa SDL_SemValue"]
    #[doc = " \\sa SDL_SemWait"]
    #[doc = " \\sa SDL_SemWaitTimeout"]
    pub fn SDL_DestroySemaphore(sem: *mut SDL_sem);
}
extern "C" {
    #[doc = " Wait until a semaphore has a positive value and then decrements it."]
    #[doc = ""]
    #[doc = " This function suspends the calling thread until either the semaphore"]
    #[doc = " pointed to by `sem` has a positive value or the call is interrupted by a"]
    #[doc = " signal or error. If the call is successful it will atomically decrement the"]
    #[doc = " semaphore value."]
    #[doc = ""]
    #[doc = " This function is the equivalent of calling SDL_SemWaitTimeout() with a time"]
    #[doc = " length of `SDL_MUTEX_MAXWAIT`."]
    #[doc = ""]
    #[doc = " \\param sem the semaphore wait on"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateSemaphore"]
    #[doc = " \\sa SDL_DestroySemaphore"]
    #[doc = " \\sa SDL_SemPost"]
    #[doc = " \\sa SDL_SemTryWait"]
    #[doc = " \\sa SDL_SemValue"]
    #[doc = " \\sa SDL_SemWait"]
    #[doc = " \\sa SDL_SemWaitTimeout"]
    pub fn SDL_SemWait(sem: *mut SDL_sem) -> libc::c_int;
}
extern "C" {
    #[doc = " See if a semaphore has a positive value and decrement it if it does."]
    #[doc = ""]
    #[doc = " This function checks to see if the semaphore pointed to by `sem` has a"]
    #[doc = " positive value and atomically decrements the semaphore value if it does. If"]
    #[doc = " the semaphore doesn't have a positive value, the function immediately"]
    #[doc = " returns SDL_MUTEX_TIMEDOUT."]
    #[doc = ""]
    #[doc = " \\param sem the semaphore to wait on"]
    #[doc = " \\returns 0 if the wait succeeds, `SDL_MUTEX_TIMEDOUT` if the wait would"]
    #[doc = "          block, or a negative error code on failure; call SDL_GetError()"]
    #[doc = "          for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateSemaphore"]
    #[doc = " \\sa SDL_DestroySemaphore"]
    #[doc = " \\sa SDL_SemPost"]
    #[doc = " \\sa SDL_SemValue"]
    #[doc = " \\sa SDL_SemWait"]
    #[doc = " \\sa SDL_SemWaitTimeout"]
    pub fn SDL_SemTryWait(sem: *mut SDL_sem) -> libc::c_int;
}
extern "C" {
    #[doc = " Wait until a semaphore has a positive value and then decrements it."]
    #[doc = ""]
    #[doc = " This function suspends the calling thread until either the semaphore"]
    #[doc = " pointed to by `sem` has a positive value, the call is interrupted by a"]
    #[doc = " signal or error, or the specified time has elapsed. If the call is"]
    #[doc = " successful it will atomically decrement the semaphore value."]
    #[doc = ""]
    #[doc = " \\param sem the semaphore to wait on"]
    #[doc = " \\param ms the length of the timeout, in milliseconds"]
    #[doc = " \\returns 0 if the wait succeeds, `SDL_MUTEX_TIMEDOUT` if the wait does not"]
    #[doc = "          succeed in the allotted time, or a negative error code on failure;"]
    #[doc = "          call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateSemaphore"]
    #[doc = " \\sa SDL_DestroySemaphore"]
    #[doc = " \\sa SDL_SemPost"]
    #[doc = " \\sa SDL_SemTryWait"]
    #[doc = " \\sa SDL_SemValue"]
    #[doc = " \\sa SDL_SemWait"]
    pub fn SDL_SemWaitTimeout(sem: *mut SDL_sem, ms: Uint32) -> libc::c_int;
}
extern "C" {
    #[doc = " Atomically increment a semaphore's value and wake waiting threads."]
    #[doc = ""]
    #[doc = " \\param sem the semaphore to increment"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateSemaphore"]
    #[doc = " \\sa SDL_DestroySemaphore"]
    #[doc = " \\sa SDL_SemTryWait"]
    #[doc = " \\sa SDL_SemValue"]
    #[doc = " \\sa SDL_SemWait"]
    #[doc = " \\sa SDL_SemWaitTimeout"]
    pub fn SDL_SemPost(sem: *mut SDL_sem) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the current value of a semaphore."]
    #[doc = ""]
    #[doc = " \\param sem the semaphore to query"]
    #[doc = " \\returns the current value of the semaphore."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateSemaphore"]
    pub fn SDL_SemValue(sem: *mut SDL_sem) -> Uint32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_cond {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create a condition variable."]
    #[doc = ""]
    #[doc = " \\returns a new condition variable or NULL on failure; call SDL_GetError()"]
    #[doc = "          for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CondBroadcast"]
    #[doc = " \\sa SDL_CondSignal"]
    #[doc = " \\sa SDL_CondWait"]
    #[doc = " \\sa SDL_CondWaitTimeout"]
    #[doc = " \\sa SDL_DestroyCond"]
    pub fn SDL_CreateCond() -> *mut SDL_cond;
}
extern "C" {
    #[doc = " Destroy a condition variable."]
    #[doc = ""]
    #[doc = " \\param cond the condition variable to destroy"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CondBroadcast"]
    #[doc = " \\sa SDL_CondSignal"]
    #[doc = " \\sa SDL_CondWait"]
    #[doc = " \\sa SDL_CondWaitTimeout"]
    #[doc = " \\sa SDL_CreateCond"]
    pub fn SDL_DestroyCond(cond: *mut SDL_cond);
}
extern "C" {
    #[doc = " Restart one of the threads that are waiting on the condition variable."]
    #[doc = ""]
    #[doc = " \\param cond the condition variable to signal"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CondBroadcast"]
    #[doc = " \\sa SDL_CondWait"]
    #[doc = " \\sa SDL_CondWaitTimeout"]
    #[doc = " \\sa SDL_CreateCond"]
    #[doc = " \\sa SDL_DestroyCond"]
    pub fn SDL_CondSignal(cond: *mut SDL_cond) -> libc::c_int;
}
extern "C" {
    #[doc = " Restart all threads that are waiting on the condition variable."]
    #[doc = ""]
    #[doc = " \\param cond the condition variable to signal"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CondSignal"]
    #[doc = " \\sa SDL_CondWait"]
    #[doc = " \\sa SDL_CondWaitTimeout"]
    #[doc = " \\sa SDL_CreateCond"]
    #[doc = " \\sa SDL_DestroyCond"]
    pub fn SDL_CondBroadcast(cond: *mut SDL_cond) -> libc::c_int;
}
extern "C" {
    #[doc = " Wait until a condition variable is signaled."]
    #[doc = ""]
    #[doc = " This function unlocks the specified `mutex` and waits for another thread to"]
    #[doc = " call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable"]
    #[doc = " `cond`. Once the condition variable is signaled, the mutex is re-locked and"]
    #[doc = " the function returns."]
    #[doc = ""]
    #[doc = " The mutex must be locked before calling this function."]
    #[doc = ""]
    #[doc = " This function is the equivalent of calling SDL_CondWaitTimeout() with a"]
    #[doc = " time length of `SDL_MUTEX_MAXWAIT`."]
    #[doc = ""]
    #[doc = " \\param cond the condition variable to wait on"]
    #[doc = " \\param mutex the mutex used to coordinate thread access"]
    #[doc = " \\returns 0 when it is signaled or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CondBroadcast"]
    #[doc = " \\sa SDL_CondSignal"]
    #[doc = " \\sa SDL_CondWaitTimeout"]
    #[doc = " \\sa SDL_CreateCond"]
    #[doc = " \\sa SDL_DestroyCond"]
    pub fn SDL_CondWait(cond: *mut SDL_cond, mutex: *mut SDL_mutex) -> libc::c_int;
}
extern "C" {
    #[doc = " Wait until a condition variable is signaled or a certain time has passed."]
    #[doc = ""]
    #[doc = " This function unlocks the specified `mutex` and waits for another thread to"]
    #[doc = " call SDL_CondSignal() or SDL_CondBroadcast() on the condition variable"]
    #[doc = " `cond`, or for the specified time to elapse. Once the condition variable is"]
    #[doc = " signaled or the time elapsed, the mutex is re-locked and the function"]
    #[doc = " returns."]
    #[doc = ""]
    #[doc = " The mutex must be locked before calling this function."]
    #[doc = ""]
    #[doc = " \\param cond the condition variable to wait on"]
    #[doc = " \\param mutex the mutex used to coordinate thread access"]
    #[doc = " \\param ms the maximum time to wait, in milliseconds, or `SDL_MUTEX_MAXWAIT`"]
    #[doc = "           to wait indefinitely"]
    #[doc = " \\returns 0 if the condition variable is signaled, `SDL_MUTEX_TIMEDOUT` if"]
    #[doc = "          the condition is not signaled in the allotted time, or a negative"]
    #[doc = "          error code on failure; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CondBroadcast"]
    #[doc = " \\sa SDL_CondSignal"]
    #[doc = " \\sa SDL_CondWait"]
    #[doc = " \\sa SDL_CreateCond"]
    #[doc = " \\sa SDL_DestroyCond"]
    pub fn SDL_CondWaitTimeout(
        cond: *mut SDL_cond,
        mutex: *mut SDL_mutex,
        ms: Uint32,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Thread {
    _unused: [u8; 0],
}
pub type SDL_threadID = libc::c_ulong;
pub type SDL_TLSID = libc::c_uint;
#[repr(u32)]
#[doc = "  The SDL thread priority."]
#[doc = ""]
#[doc = "  SDL will make system changes as necessary in order to apply the thread priority."]
#[doc = "  Code which attempts to control thread state related to priority should be aware"]
#[doc = "  that calling SDL_SetThreadPriority may alter such state."]
#[doc = "  SDL_HINT_THREAD_PRIORITY_POLICY can be used to control aspects of this behavior."]
#[doc = ""]
#[doc = "  \\note On many systems you require special privileges to set high or time critical priority."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_ThreadPriority {
    SDL_THREAD_PRIORITY_LOW = 0,
    SDL_THREAD_PRIORITY_NORMAL = 1,
    SDL_THREAD_PRIORITY_HIGH = 2,
    SDL_THREAD_PRIORITY_TIME_CRITICAL = 3,
}
#[doc = " The function passed to SDL_CreateThread()."]
#[doc = ""]
#[doc = " \\param data what was passed as `data` to SDL_CreateThread()"]
#[doc = " \\returns a value that can be reported through SDL_WaitThread()."]
pub type SDL_ThreadFunction =
    ::core::option::Option<unsafe extern "C" fn(data: *mut libc::c_void) -> libc::c_int>;
extern "C" {
    #[doc = " Create a new thread with a default stack size."]
    #[doc = ""]
    #[doc = " This is equivalent to calling:"]
    #[doc = ""]
    #[doc = " ```c"]
    #[doc = " SDL_CreateThreadWithStackSize(fn, name, 0, data);"]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " \\param fn the SDL_ThreadFunction function to call in the new thread"]
    #[doc = " \\param name the name of the thread"]
    #[doc = " \\param data a pointer that is passed to `fn`"]
    #[doc = " \\returns an opaque pointer to the new thread object on success, NULL if the"]
    #[doc = "          new thread could not be created; call SDL_GetError() for more"]
    #[doc = "          information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateThreadWithStackSize"]
    #[doc = " \\sa SDL_WaitThread"]
    pub fn SDL_CreateThread(
        fn_: SDL_ThreadFunction,
        name: *const libc::c_char,
        data: *mut libc::c_void,
    ) -> *mut SDL_Thread;
}
extern "C" {
    #[doc = " Create a new thread with a specific stack size."]
    #[doc = ""]
    #[doc = " SDL makes an attempt to report `name` to the system, so that debuggers can"]
    #[doc = " display it. Not all platforms support this."]
    #[doc = ""]
    #[doc = " Thread naming is a little complicated: Most systems have very small limits"]
    #[doc = " for the string length (Haiku has 32 bytes, Linux currently has 16, Visual"]
    #[doc = " C++ 6.0 has _nine_!), and possibly other arbitrary rules. You'll have to"]
    #[doc = " see what happens with your system's debugger. The name should be UTF-8 (but"]
    #[doc = " using the naming limits of C identifiers is a better bet). There are no"]
    #[doc = " requirements for thread naming conventions, so long as the string is"]
    #[doc = " null-terminated UTF-8, but these guidelines are helpful in choosing a name:"]
    #[doc = ""]
    #[doc = " https://stackoverflow.com/questions/149932/naming-conventions-for-threads"]
    #[doc = ""]
    #[doc = " If a system imposes requirements, SDL will try to munge the string for it"]
    #[doc = " (truncate, etc), but the original string contents will be available from"]
    #[doc = " SDL_GetThreadName()."]
    #[doc = ""]
    #[doc = " The size (in bytes) of the new stack can be specified. Zero means \"use the"]
    #[doc = " system default\" which might be wildly different between platforms. x86"]
    #[doc = " Linux generally defaults to eight megabytes, an embedded device might be a"]
    #[doc = " few kilobytes instead. You generally need to specify a stack that is a"]
    #[doc = " multiple of the system's page size (in many cases, this is 4 kilobytes, but"]
    #[doc = " check your system documentation)."]
    #[doc = ""]
    #[doc = " In SDL 2.1, stack size will be folded into the original SDL_CreateThread"]
    #[doc = " function, but for backwards compatibility, this is currently a separate"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " \\param fn the SDL_ThreadFunction function to call in the new thread"]
    #[doc = " \\param name the name of the thread"]
    #[doc = " \\param stacksize the size, in bytes, to allocate for the new thread stack."]
    #[doc = " \\param data a pointer that is passed to `fn`"]
    #[doc = " \\returns an opaque pointer to the new thread object on success, NULL if the"]
    #[doc = "          new thread could not be created; call SDL_GetError() for more"]
    #[doc = "          information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.9."]
    #[doc = ""]
    #[doc = " \\sa SDL_WaitThread"]
    pub fn SDL_CreateThreadWithStackSize(
        fn_: SDL_ThreadFunction,
        name: *const libc::c_char,
        stacksize: size_t,
        data: *mut libc::c_void,
    ) -> *mut SDL_Thread;
}
extern "C" {
    #[doc = " Get the thread name as it was specified in SDL_CreateThread()."]
    #[doc = ""]
    #[doc = " This is internal memory, not to be freed by the caller, and remains valid"]
    #[doc = " until the specified thread is cleaned up by SDL_WaitThread()."]
    #[doc = ""]
    #[doc = " \\param thread the thread to query"]
    #[doc = " \\returns a pointer to a UTF-8 string that names the specified thread, or"]
    #[doc = "          NULL if it doesn't have a name."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateThread"]
    pub fn SDL_GetThreadName(thread: *mut SDL_Thread) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the thread identifier for the current thread."]
    #[doc = ""]
    #[doc = " This thread identifier is as reported by the underlying operating system."]
    #[doc = " If SDL is running on a platform that does not support threads the return"]
    #[doc = " value will always be zero."]
    #[doc = ""]
    #[doc = " This function also returns a valid thread ID when called from the main"]
    #[doc = " thread."]
    #[doc = ""]
    #[doc = " \\returns the ID of the current thread."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetThreadID"]
    pub fn SDL_ThreadID() -> SDL_threadID;
}
extern "C" {
    #[doc = " Get the thread identifier for the specified thread."]
    #[doc = ""]
    #[doc = " This thread identifier is as reported by the underlying operating system."]
    #[doc = " If SDL is running on a platform that does not support threads the return"]
    #[doc = " value will always be zero."]
    #[doc = ""]
    #[doc = " \\param thread the thread to query"]
    #[doc = " \\returns the ID of the specified thread, or the ID of the current thread if"]
    #[doc = "          `thread` is NULL."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_ThreadID"]
    pub fn SDL_GetThreadID(thread: *mut SDL_Thread) -> SDL_threadID;
}
extern "C" {
    #[doc = " Set the priority for the current thread."]
    #[doc = ""]
    #[doc = " Note that some platforms will not let you alter the priority (or at least,"]
    #[doc = " promote the thread to a higher priority) at all, and some require you to be"]
    #[doc = " an administrator account. Be prepared for this to fail."]
    #[doc = ""]
    #[doc = " \\param priority the SDL_ThreadPriority to set"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_SetThreadPriority(priority: SDL_ThreadPriority) -> libc::c_int;
}
extern "C" {
    #[doc = " Wait for a thread to finish."]
    #[doc = ""]
    #[doc = " Threads that haven't been detached will remain (as a \"zombie\") until this"]
    #[doc = " function cleans them up. Not doing so is a resource leak."]
    #[doc = ""]
    #[doc = " Once a thread has been cleaned up through this function, the SDL_Thread"]
    #[doc = " that references it becomes invalid and should not be referenced again. As"]
    #[doc = " such, only one thread may call SDL_WaitThread() on another."]
    #[doc = ""]
    #[doc = " The return code for the thread function is placed in the area pointed to by"]
    #[doc = " `status`, if `status` is not NULL."]
    #[doc = ""]
    #[doc = " You may not wait on a thread that has been used in a call to"]
    #[doc = " SDL_DetachThread(). Use either that function or this one, but not both, or"]
    #[doc = " behavior is undefined."]
    #[doc = ""]
    #[doc = " It is safe to pass a NULL thread to this function; it is a no-op."]
    #[doc = ""]
    #[doc = " Note that the thread pointer is freed by this function and is not valid"]
    #[doc = " afterward."]
    #[doc = ""]
    #[doc = " \\param thread the SDL_Thread pointer that was returned from the"]
    #[doc = "               SDL_CreateThread() call that started this thread"]
    #[doc = " \\param status pointer to an integer that will receive the value returned"]
    #[doc = "               from the thread function by its 'return', or NULL to not"]
    #[doc = "               receive such value back."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateThread"]
    #[doc = " \\sa SDL_DetachThread"]
    pub fn SDL_WaitThread(thread: *mut SDL_Thread, status: *mut libc::c_int);
}
extern "C" {
    #[doc = " Let a thread clean up on exit without intervention."]
    #[doc = ""]
    #[doc = " A thread may be \"detached\" to signify that it should not remain until"]
    #[doc = " another thread has called SDL_WaitThread() on it. Detaching a thread is"]
    #[doc = " useful for long-running threads that nothing needs to synchronize with or"]
    #[doc = " further manage. When a detached thread is done, it simply goes away."]
    #[doc = ""]
    #[doc = " There is no way to recover the return code of a detached thread. If you"]
    #[doc = " need this, don't detach the thread and instead use SDL_WaitThread()."]
    #[doc = ""]
    #[doc = " Once a thread is detached, you should usually assume the SDL_Thread isn't"]
    #[doc = " safe to reference again, as it will become invalid immediately upon the"]
    #[doc = " detached thread's exit, instead of remaining until someone has called"]
    #[doc = " SDL_WaitThread() to finally clean it up. As such, don't detach the same"]
    #[doc = " thread more than once."]
    #[doc = ""]
    #[doc = " If a thread has already exited when passed to SDL_DetachThread(), it will"]
    #[doc = " stop waiting for a call to SDL_WaitThread() and clean up immediately. It is"]
    #[doc = " not safe to detach a thread that might be used with SDL_WaitThread()."]
    #[doc = ""]
    #[doc = " You may not call SDL_WaitThread() on a thread that has been detached. Use"]
    #[doc = " either that function or this one, but not both, or behavior is undefined."]
    #[doc = ""]
    #[doc = " It is safe to pass NULL to this function; it is a no-op."]
    #[doc = ""]
    #[doc = " \\param thread the SDL_Thread pointer that was returned from the"]
    #[doc = "               SDL_CreateThread() call that started this thread"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.2."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateThread"]
    #[doc = " \\sa SDL_WaitThread"]
    pub fn SDL_DetachThread(thread: *mut SDL_Thread);
}
extern "C" {
    #[doc = " Create a piece of thread-local storage."]
    #[doc = ""]
    #[doc = " This creates an identifier that is globally visible to all threads but"]
    #[doc = " refers to data that is thread-specific."]
    #[doc = ""]
    #[doc = " \\returns the newly created thread local storage identifier or 0 on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_TLSGet"]
    #[doc = " \\sa SDL_TLSSet"]
    pub fn SDL_TLSCreate() -> SDL_TLSID;
}
extern "C" {
    #[doc = " Get the current thread's value associated with a thread local storage ID."]
    #[doc = ""]
    #[doc = " \\param id the thread local storage ID"]
    #[doc = " \\returns the value associated with the ID for the current thread or NULL if"]
    #[doc = "          no value has been set; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_TLSCreate"]
    #[doc = " \\sa SDL_TLSSet"]
    pub fn SDL_TLSGet(id: SDL_TLSID) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Set the current thread's value associated with a thread local storage ID."]
    #[doc = ""]
    #[doc = " The function prototype for `destructor` is:"]
    #[doc = ""]
    #[doc = " ```c"]
    #[doc = " void destructor(void *value)"]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " where its parameter `value` is what was passed as `value` to SDL_TLSSet()."]
    #[doc = ""]
    #[doc = " \\param id the thread local storage ID"]
    #[doc = " \\param value the value to associate with the ID for the current thread"]
    #[doc = " \\param destructor a function called when the thread exits, to free the"]
    #[doc = "                   value"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_TLSCreate"]
    #[doc = " \\sa SDL_TLSGet"]
    pub fn SDL_TLSSet(
        id: SDL_TLSID,
        value: *const libc::c_void,
        destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void)>,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Cleanup all TLS data for this thread."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.16."]
    pub fn SDL_TLSCleanup();
}
#[doc = " This is the read/write operation structure -- very basic."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_RWops {
    #[doc = "  Return the size of the file in this rwops, or -1 if unknown"]
    pub size: ::core::option::Option<unsafe extern "C" fn(context: *mut SDL_RWops) -> Sint64>,
    #[doc = "  Seek to \\c offset relative to \\c whence, one of stdio's whence values:"]
    #[doc = "  RW_SEEK_SET, RW_SEEK_CUR, RW_SEEK_END"]
    #[doc = ""]
    #[doc = "  \\return the final offset in the data stream, or -1 on error."]
    pub seek: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut SDL_RWops,
            offset: Sint64,
            whence: libc::c_int,
        ) -> Sint64,
    >,
    #[doc = "  Read up to \\c maxnum objects each of size \\c size from the data"]
    #[doc = "  stream to the area pointed at by \\c ptr."]
    #[doc = ""]
    #[doc = "  \\return the number of objects read, or 0 at error or end of file."]
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut SDL_RWops,
            ptr: *mut libc::c_void,
            size: size_t,
            maxnum: size_t,
        ) -> size_t,
    >,
    #[doc = "  Write exactly \\c num objects each of size \\c size from the area"]
    #[doc = "  pointed at by \\c ptr to data stream."]
    #[doc = ""]
    #[doc = "  \\return the number of objects written, or 0 at error or end of file."]
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut SDL_RWops,
            ptr: *const libc::c_void,
            size: size_t,
            num: size_t,
        ) -> size_t,
    >,
    #[doc = "  Close and free an allocated SDL_RWops structure."]
    #[doc = ""]
    #[doc = "  \\return 0 if successful or -1 on write error when flushing data."]
    pub close: ::core::option::Option<unsafe extern "C" fn(context: *mut SDL_RWops) -> libc::c_int>,
    pub type_: Uint32,
    pub hidden: SDL_RWops__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_RWops__bindgen_ty_1 {
    pub mem: SDL_RWops__bindgen_ty_1__bindgen_ty_1,
    pub unknown: SDL_RWops__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_1 {
    pub base: *mut Uint8,
    pub here: *mut Uint8,
    pub stop: *mut Uint8,
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>())).base as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>())).here as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(here)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>())).stop as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(stop)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_2 {
    pub data1: *mut libc::c_void,
    pub data2: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>())).data1 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(data1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>())).data2 as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(data2)
        )
    );
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SDL_RWops__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_RWops__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_RWops__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_RWops__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1>())).mem as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1),
            "::",
            stringify!(mem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_RWops__bindgen_ty_1>())).unknown as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1),
            "::",
            stringify!(unknown)
        )
    );
}
#[test]
fn bindgen_test_layout_SDL_RWops() {
    assert_eq!(
        ::core::mem::size_of::<SDL_RWops>(),
        72usize,
        concat!("Size of: ", stringify!(SDL_RWops))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_RWops>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_RWops))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_RWops>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_RWops>())).seek as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_RWops>())).read as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_RWops>())).write as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_RWops>())).close as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_RWops>())).type_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_RWops>())).hidden as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(hidden)
        )
    );
}
extern "C" {
    #[doc = " Use this function to create a new SDL_RWops structure for reading from"]
    #[doc = " and/or writing to a named file."]
    #[doc = ""]
    #[doc = " The `mode` string is treated roughly the same as in a call to the C"]
    #[doc = " library's fopen(), even if SDL doesn't happen to use fopen() behind the"]
    #[doc = " scenes."]
    #[doc = ""]
    #[doc = " Available `mode` strings:"]
    #[doc = ""]
    #[doc = " - \"r\": Open a file for reading. The file must exist."]
    #[doc = " - \"w\": Create an empty file for writing. If a file with the same name"]
    #[doc = "   already exists its content is erased and the file is treated as a new"]
    #[doc = "   empty file."]
    #[doc = " - \"a\": Append to a file. Writing operations append data at the end of the"]
    #[doc = "   file. The file is created if it does not exist."]
    #[doc = " - \"r+\": Open a file for update both reading and writing. The file must"]
    #[doc = "   exist."]
    #[doc = " - \"w+\": Create an empty file for both reading and writing. If a file with"]
    #[doc = "   the same name already exists its content is erased and the file is"]
    #[doc = "   treated as a new empty file."]
    #[doc = " - \"a+\": Open a file for reading and appending. All writing operations are"]
    #[doc = "   performed at the end of the file, protecting the previous content to be"]
    #[doc = "   overwritten. You can reposition (fseek, rewind) the internal pointer to"]
    #[doc = "   anywhere in the file for reading, but writing operations will move it"]
    #[doc = "   back to the end of file. The file is created if it does not exist."]
    #[doc = ""]
    #[doc = " **NOTE**: In order to open a file as a binary file, a \"b\" character has to"]
    #[doc = " be included in the `mode` string. This additional \"b\" character can either"]
    #[doc = " be appended at the end of the string (thus making the following compound"]
    #[doc = " modes: \"rb\", \"wb\", \"ab\", \"r+b\", \"w+b\", \"a+b\") or be inserted between the"]
    #[doc = " letter and the \"+\" sign for the mixed modes (\"rb+\", \"wb+\", \"ab+\")."]
    #[doc = " Additional characters may follow the sequence, although they should have no"]
    #[doc = " effect. For example, \"t\" is sometimes appended to make explicit the file is"]
    #[doc = " a text file."]
    #[doc = ""]
    #[doc = " This function supports Unicode filenames, but they must be encoded in UTF-8"]
    #[doc = " format, regardless of the underlying operating system."]
    #[doc = ""]
    #[doc = " As a fallback, SDL_RWFromFile() will transparently open a matching filename"]
    #[doc = " in an Android app's `assets`."]
    #[doc = ""]
    #[doc = " Closing the SDL_RWops will close the file handle SDL is holding internally."]
    #[doc = ""]
    #[doc = " \\param file a UTF-8 string representing the filename to open"]
    #[doc = " \\param mode an ASCII string representing the mode to be used for opening"]
    #[doc = "             the file."]
    #[doc = " \\returns a pointer to the SDL_RWops structure that is created, or NULL on"]
    #[doc = "          failure; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_RWclose"]
    #[doc = " \\sa SDL_RWFromConstMem"]
    #[doc = " \\sa SDL_RWFromFP"]
    #[doc = " \\sa SDL_RWFromMem"]
    #[doc = " \\sa SDL_RWread"]
    #[doc = " \\sa SDL_RWseek"]
    #[doc = " \\sa SDL_RWtell"]
    #[doc = " \\sa SDL_RWwrite"]
    pub fn SDL_RWFromFile(file: *const libc::c_char, mode: *const libc::c_char) -> *mut SDL_RWops;
}
extern "C" {
    #[doc = " Use this function to create an SDL_RWops structure from a standard I/O file"]
    #[doc = " pointer (stdio.h's `FILE*`)."]
    #[doc = ""]
    #[doc = " This function is not available on Windows, since files opened in an"]
    #[doc = " application on that platform cannot be used by a dynamically linked"]
    #[doc = " library."]
    #[doc = ""]
    #[doc = " On some platforms, the first parameter is a `void*`, on others, it's a"]
    #[doc = " `FILE*`, depending on what system headers are available to SDL. It is"]
    #[doc = " always intended to be the `FILE*` type from the C runtime's stdio.h."]
    #[doc = ""]
    #[doc = " \\param fp the `FILE*` that feeds the SDL_RWops stream"]
    #[doc = " \\param autoclose SDL_TRUE to close the `FILE*` when closing the SDL_RWops,"]
    #[doc = "                  SDL_FALSE to leave the `FILE*` open when the RWops is"]
    #[doc = "                  closed"]
    #[doc = " \\returns a pointer to the SDL_RWops structure that is created, or NULL on"]
    #[doc = "          failure; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_RWclose"]
    #[doc = " \\sa SDL_RWFromConstMem"]
    #[doc = " \\sa SDL_RWFromFile"]
    #[doc = " \\sa SDL_RWFromMem"]
    #[doc = " \\sa SDL_RWread"]
    #[doc = " \\sa SDL_RWseek"]
    #[doc = " \\sa SDL_RWtell"]
    #[doc = " \\sa SDL_RWwrite"]
    pub fn SDL_RWFromFP(fp: *mut libc::c_void, autoclose: SDL_bool) -> *mut SDL_RWops;
}
extern "C" {
    #[doc = " Use this function to prepare a read-write memory buffer for use with"]
    #[doc = " SDL_RWops."]
    #[doc = ""]
    #[doc = " This function sets up an SDL_RWops struct based on a memory area of a"]
    #[doc = " certain size, for both read and write access."]
    #[doc = ""]
    #[doc = " This memory buffer is not copied by the RWops; the pointer you provide must"]
    #[doc = " remain valid until you close the stream. Closing the stream will not free"]
    #[doc = " the original buffer."]
    #[doc = ""]
    #[doc = " If you need to make sure the RWops never writes to the memory buffer, you"]
    #[doc = " should use SDL_RWFromConstMem() with a read-only buffer of memory instead."]
    #[doc = ""]
    #[doc = " \\param mem a pointer to a buffer to feed an SDL_RWops stream"]
    #[doc = " \\param size the buffer size, in bytes"]
    #[doc = " \\returns a pointer to a new SDL_RWops structure, or NULL if it fails; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_RWclose"]
    #[doc = " \\sa SDL_RWFromConstMem"]
    #[doc = " \\sa SDL_RWFromFile"]
    #[doc = " \\sa SDL_RWFromFP"]
    #[doc = " \\sa SDL_RWFromMem"]
    #[doc = " \\sa SDL_RWread"]
    #[doc = " \\sa SDL_RWseek"]
    #[doc = " \\sa SDL_RWtell"]
    #[doc = " \\sa SDL_RWwrite"]
    pub fn SDL_RWFromMem(mem: *mut libc::c_void, size: libc::c_int) -> *mut SDL_RWops;
}
extern "C" {
    #[doc = " Use this function to prepare a read-only memory buffer for use with RWops."]
    #[doc = ""]
    #[doc = " This function sets up an SDL_RWops struct based on a memory area of a"]
    #[doc = " certain size. It assumes the memory area is not writable."]
    #[doc = ""]
    #[doc = " Attempting to write to this RWops stream will report an error without"]
    #[doc = " writing to the memory buffer."]
    #[doc = ""]
    #[doc = " This memory buffer is not copied by the RWops; the pointer you provide must"]
    #[doc = " remain valid until you close the stream. Closing the stream will not free"]
    #[doc = " the original buffer."]
    #[doc = ""]
    #[doc = " If you need to write to a memory buffer, you should use SDL_RWFromMem()"]
    #[doc = " with a writable buffer of memory instead."]
    #[doc = ""]
    #[doc = " \\param mem a pointer to a read-only buffer to feed an SDL_RWops stream"]
    #[doc = " \\param size the buffer size, in bytes"]
    #[doc = " \\returns a pointer to a new SDL_RWops structure, or NULL if it fails; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_RWclose"]
    #[doc = " \\sa SDL_RWFromConstMem"]
    #[doc = " \\sa SDL_RWFromFile"]
    #[doc = " \\sa SDL_RWFromFP"]
    #[doc = " \\sa SDL_RWFromMem"]
    #[doc = " \\sa SDL_RWread"]
    #[doc = " \\sa SDL_RWseek"]
    #[doc = " \\sa SDL_RWtell"]
    pub fn SDL_RWFromConstMem(mem: *const libc::c_void, size: libc::c_int) -> *mut SDL_RWops;
}
extern "C" {
    #[doc = " Use this function to allocate an empty, unpopulated SDL_RWops structure."]
    #[doc = ""]
    #[doc = " Applications do not need to use this function unless they are providing"]
    #[doc = " their own SDL_RWops implementation. If you just need a SDL_RWops to"]
    #[doc = " read/write a common data source, you should use the built-in"]
    #[doc = " implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc."]
    #[doc = ""]
    #[doc = " You must free the returned pointer with SDL_FreeRW(). Depending on your"]
    #[doc = " operating system and compiler, there may be a difference between the"]
    #[doc = " malloc() and free() your program uses and the versions SDL calls"]
    #[doc = " internally. Trying to mix the two can cause crashing such as segmentation"]
    #[doc = " faults. Since all SDL_RWops must free themselves when their **close**"]
    #[doc = " method is called, all SDL_RWops must be allocated through this function, so"]
    #[doc = " they can all be freed correctly with SDL_FreeRW()."]
    #[doc = ""]
    #[doc = " \\returns a pointer to the allocated memory on success, or NULL on failure;"]
    #[doc = "          call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_FreeRW"]
    pub fn SDL_AllocRW() -> *mut SDL_RWops;
}
extern "C" {
    #[doc = " Use this function to free an SDL_RWops structure allocated by"]
    #[doc = " SDL_AllocRW()."]
    #[doc = ""]
    #[doc = " Applications do not need to use this function unless they are providing"]
    #[doc = " their own SDL_RWops implementation. If you just need a SDL_RWops to"]
    #[doc = " read/write a common data source, you should use the built-in"]
    #[doc = " implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc, and"]
    #[doc = " call the **close** method on those SDL_RWops pointers when you are done"]
    #[doc = " with them."]
    #[doc = ""]
    #[doc = " Only use SDL_FreeRW() on pointers returned by SDL_AllocRW(). The pointer is"]
    #[doc = " invalid as soon as this function returns. Any extra memory allocated during"]
    #[doc = " creation of the SDL_RWops is not freed by SDL_FreeRW(); the programmer must"]
    #[doc = " be responsible for managing that memory in their **close** method."]
    #[doc = ""]
    #[doc = " \\param area the SDL_RWops structure to be freed"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_AllocRW"]
    pub fn SDL_FreeRW(area: *mut SDL_RWops);
}
extern "C" {
    #[doc = " Use this function to get the size of the data stream in an SDL_RWops."]
    #[doc = ""]
    #[doc = " Prior to SDL 2.0.10, this function was a macro."]
    #[doc = ""]
    #[doc = " \\param context the SDL_RWops to get the size of the data stream from"]
    #[doc = " \\returns the size of the data stream in the SDL_RWops on success, -1 if"]
    #[doc = "          unknown or a negative error code on failure; call SDL_GetError()"]
    #[doc = "          for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.10."]
    pub fn SDL_RWsize(context: *mut SDL_RWops) -> Sint64;
}
extern "C" {
    #[doc = " Seek within an SDL_RWops data stream."]
    #[doc = ""]
    #[doc = " This function seeks to byte `offset`, relative to `whence`."]
    #[doc = ""]
    #[doc = " `whence` may be any of the following values:"]
    #[doc = ""]
    #[doc = " - `RW_SEEK_SET`: seek from the beginning of data"]
    #[doc = " - `RW_SEEK_CUR`: seek relative to current read point"]
    #[doc = " - `RW_SEEK_END`: seek relative to the end of data"]
    #[doc = ""]
    #[doc = " If this stream can not seek, it will return -1."]
    #[doc = ""]
    #[doc = " SDL_RWseek() is actually a wrapper function that calls the SDL_RWops's"]
    #[doc = " `seek` method appropriately, to simplify application development."]
    #[doc = ""]
    #[doc = " Prior to SDL 2.0.10, this function was a macro."]
    #[doc = ""]
    #[doc = " \\param context a pointer to an SDL_RWops structure"]
    #[doc = " \\param offset an offset in bytes, relative to **whence** location; can be"]
    #[doc = "               negative"]
    #[doc = " \\param whence any of `RW_SEEK_SET`, `RW_SEEK_CUR`, `RW_SEEK_END`"]
    #[doc = " \\returns the final offset in the data stream after the seek or -1 on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.10."]
    #[doc = ""]
    #[doc = " \\sa SDL_RWclose"]
    #[doc = " \\sa SDL_RWFromConstMem"]
    #[doc = " \\sa SDL_RWFromFile"]
    #[doc = " \\sa SDL_RWFromFP"]
    #[doc = " \\sa SDL_RWFromMem"]
    #[doc = " \\sa SDL_RWread"]
    #[doc = " \\sa SDL_RWtell"]
    #[doc = " \\sa SDL_RWwrite"]
    pub fn SDL_RWseek(context: *mut SDL_RWops, offset: Sint64, whence: libc::c_int) -> Sint64;
}
extern "C" {
    #[doc = " Determine the current read/write offset in an SDL_RWops data stream."]
    #[doc = ""]
    #[doc = " SDL_RWtell is actually a wrapper function that calls the SDL_RWops's `seek`"]
    #[doc = " method, with an offset of 0 bytes from `RW_SEEK_CUR`, to simplify"]
    #[doc = " application development."]
    #[doc = ""]
    #[doc = " Prior to SDL 2.0.10, this function was a macro."]
    #[doc = ""]
    #[doc = " \\param context a SDL_RWops data stream object from which to get the current"]
    #[doc = "                offset"]
    #[doc = " \\returns the current offset in the stream, or -1 if the information can not"]
    #[doc = "          be determined."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.10."]
    #[doc = ""]
    #[doc = " \\sa SDL_RWclose"]
    #[doc = " \\sa SDL_RWFromConstMem"]
    #[doc = " \\sa SDL_RWFromFile"]
    #[doc = " \\sa SDL_RWFromFP"]
    #[doc = " \\sa SDL_RWFromMem"]
    #[doc = " \\sa SDL_RWread"]
    #[doc = " \\sa SDL_RWseek"]
    #[doc = " \\sa SDL_RWwrite"]
    pub fn SDL_RWtell(context: *mut SDL_RWops) -> Sint64;
}
extern "C" {
    #[doc = " Read from a data source."]
    #[doc = ""]
    #[doc = " This function reads up to `maxnum` objects each of size `size` from the"]
    #[doc = " data source to the area pointed at by `ptr`. This function may read less"]
    #[doc = " objects than requested. It will return zero when there has been an error or"]
    #[doc = " the data stream is completely read."]
    #[doc = ""]
    #[doc = " SDL_RWread() is actually a function wrapper that calls the SDL_RWops's"]
    #[doc = " `read` method appropriately, to simplify application development."]
    #[doc = ""]
    #[doc = " Prior to SDL 2.0.10, this function was a macro."]
    #[doc = ""]
    #[doc = " \\param context a pointer to an SDL_RWops structure"]
    #[doc = " \\param ptr a pointer to a buffer to read data into"]
    #[doc = " \\param size the size of each object to read, in bytes"]
    #[doc = " \\param maxnum the maximum number of objects to be read"]
    #[doc = " \\returns the number of objects read, or 0 at error or end of file; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.10."]
    #[doc = ""]
    #[doc = " \\sa SDL_RWclose"]
    #[doc = " \\sa SDL_RWFromConstMem"]
    #[doc = " \\sa SDL_RWFromFile"]
    #[doc = " \\sa SDL_RWFromFP"]
    #[doc = " \\sa SDL_RWFromMem"]
    #[doc = " \\sa SDL_RWseek"]
    #[doc = " \\sa SDL_RWwrite"]
    pub fn SDL_RWread(
        context: *mut SDL_RWops,
        ptr: *mut libc::c_void,
        size: size_t,
        maxnum: size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Write to an SDL_RWops data stream."]
    #[doc = ""]
    #[doc = " This function writes exactly `num` objects each of size `size` from the"]
    #[doc = " area pointed at by `ptr` to the stream. If this fails for any reason, it'll"]
    #[doc = " return less than `num` to demonstrate how far the write progressed. On"]
    #[doc = " success, it returns `num`."]
    #[doc = ""]
    #[doc = " SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's"]
    #[doc = " `write` method appropriately, to simplify application development."]
    #[doc = ""]
    #[doc = " Prior to SDL 2.0.10, this function was a macro."]
    #[doc = ""]
    #[doc = " \\param context a pointer to an SDL_RWops structure"]
    #[doc = " \\param ptr a pointer to a buffer containing data to write"]
    #[doc = " \\param size the size of an object to write, in bytes"]
    #[doc = " \\param num the number of objects to write"]
    #[doc = " \\returns the number of objects written, which will be less than **num** on"]
    #[doc = "          error; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.10."]
    #[doc = ""]
    #[doc = " \\sa SDL_RWclose"]
    #[doc = " \\sa SDL_RWFromConstMem"]
    #[doc = " \\sa SDL_RWFromFile"]
    #[doc = " \\sa SDL_RWFromFP"]
    #[doc = " \\sa SDL_RWFromMem"]
    #[doc = " \\sa SDL_RWread"]
    #[doc = " \\sa SDL_RWseek"]
    pub fn SDL_RWwrite(
        context: *mut SDL_RWops,
        ptr: *const libc::c_void,
        size: size_t,
        num: size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Close and free an allocated SDL_RWops structure."]
    #[doc = ""]
    #[doc = " SDL_RWclose() closes and cleans up the SDL_RWops stream. It releases any"]
    #[doc = " resources used by the stream and frees the SDL_RWops itself with"]
    #[doc = " SDL_FreeRW(). This returns 0 on success, or -1 if the stream failed to"]
    #[doc = " flush to its output (e.g. to disk)."]
    #[doc = ""]
    #[doc = " Note that if this fails to flush the stream to disk, this function reports"]
    #[doc = " an error, but the SDL_RWops is still invalid once this function returns."]
    #[doc = ""]
    #[doc = " Prior to SDL 2.0.10, this function was a macro."]
    #[doc = ""]
    #[doc = " \\param context SDL_RWops structure to close"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.10."]
    #[doc = ""]
    #[doc = " \\sa SDL_RWFromConstMem"]
    #[doc = " \\sa SDL_RWFromFile"]
    #[doc = " \\sa SDL_RWFromFP"]
    #[doc = " \\sa SDL_RWFromMem"]
    #[doc = " \\sa SDL_RWread"]
    #[doc = " \\sa SDL_RWseek"]
    #[doc = " \\sa SDL_RWwrite"]
    pub fn SDL_RWclose(context: *mut SDL_RWops) -> libc::c_int;
}
extern "C" {
    #[doc = " Load all the data from an SDL data stream."]
    #[doc = ""]
    #[doc = " The data is allocated with a zero byte at the end (null terminated) for"]
    #[doc = " convenience. This extra byte is not included in the value reported via"]
    #[doc = " `datasize`."]
    #[doc = ""]
    #[doc = " The data should be freed with SDL_free()."]
    #[doc = ""]
    #[doc = " \\param src the SDL_RWops to read all available data from"]
    #[doc = " \\param datasize if not NULL, will store the number of bytes read"]
    #[doc = " \\param freesrc if non-zero, calls SDL_RWclose() on `src` before returning"]
    #[doc = " \\returns the data, or NULL if there was an error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.6."]
    pub fn SDL_LoadFile_RW(
        src: *mut SDL_RWops,
        datasize: *mut size_t,
        freesrc: libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Load all the data from a file path."]
    #[doc = ""]
    #[doc = " The data is allocated with a zero byte at the end (null terminated) for"]
    #[doc = " convenience. This extra byte is not included in the value reported via"]
    #[doc = " `datasize`."]
    #[doc = ""]
    #[doc = " The data should be freed with SDL_free()."]
    #[doc = ""]
    #[doc = " Prior to SDL 2.0.10, this function was a macro wrapping around"]
    #[doc = " SDL_LoadFile_RW."]
    #[doc = ""]
    #[doc = " \\param file the path to read all available data from"]
    #[doc = " \\param datasize if not NULL, will store the number of bytes read"]
    #[doc = " \\returns the data, or NULL if there was an error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.10."]
    pub fn SDL_LoadFile(file: *const libc::c_char, datasize: *mut size_t) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Use this function to read a byte from an SDL_RWops."]
    #[doc = ""]
    #[doc = " \\param src the SDL_RWops to read from"]
    #[doc = " \\returns the read byte on success or 0 on failure; call SDL_GetError() for"]
    #[doc = "          more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_WriteU8"]
    pub fn SDL_ReadU8(src: *mut SDL_RWops) -> Uint8;
}
extern "C" {
    #[doc = " Use this function to read 16 bits of little-endian data from an SDL_RWops"]
    #[doc = " and return in native format."]
    #[doc = ""]
    #[doc = " SDL byteswaps the data only if necessary, so the data returned will be in"]
    #[doc = " the native byte order."]
    #[doc = ""]
    #[doc = " \\param src the stream from which to read data"]
    #[doc = " \\returns 16 bits of data in the native byte order of the platform."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_ReadBE16"]
    pub fn SDL_ReadLE16(src: *mut SDL_RWops) -> Uint16;
}
extern "C" {
    #[doc = " Use this function to read 16 bits of big-endian data from an SDL_RWops and"]
    #[doc = " return in native format."]
    #[doc = ""]
    #[doc = " SDL byteswaps the data only if necessary, so the data returned will be in"]
    #[doc = " the native byte order."]
    #[doc = ""]
    #[doc = " \\param src the stream from which to read data"]
    #[doc = " \\returns 16 bits of data in the native byte order of the platform."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_ReadLE16"]
    pub fn SDL_ReadBE16(src: *mut SDL_RWops) -> Uint16;
}
extern "C" {
    #[doc = " Use this function to read 32 bits of little-endian data from an SDL_RWops"]
    #[doc = " and return in native format."]
    #[doc = ""]
    #[doc = " SDL byteswaps the data only if necessary, so the data returned will be in"]
    #[doc = " the native byte order."]
    #[doc = ""]
    #[doc = " \\param src the stream from which to read data"]
    #[doc = " \\returns 32 bits of data in the native byte order of the platform."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_ReadBE32"]
    pub fn SDL_ReadLE32(src: *mut SDL_RWops) -> Uint32;
}
extern "C" {
    #[doc = " Use this function to read 32 bits of big-endian data from an SDL_RWops and"]
    #[doc = " return in native format."]
    #[doc = ""]
    #[doc = " SDL byteswaps the data only if necessary, so the data returned will be in"]
    #[doc = " the native byte order."]
    #[doc = ""]
    #[doc = " \\param src the stream from which to read data"]
    #[doc = " \\returns 32 bits of data in the native byte order of the platform."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_ReadLE32"]
    pub fn SDL_ReadBE32(src: *mut SDL_RWops) -> Uint32;
}
extern "C" {
    #[doc = " Use this function to read 64 bits of little-endian data from an SDL_RWops"]
    #[doc = " and return in native format."]
    #[doc = ""]
    #[doc = " SDL byteswaps the data only if necessary, so the data returned will be in"]
    #[doc = " the native byte order."]
    #[doc = ""]
    #[doc = " \\param src the stream from which to read data"]
    #[doc = " \\returns 64 bits of data in the native byte order of the platform."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_ReadBE64"]
    pub fn SDL_ReadLE64(src: *mut SDL_RWops) -> Uint64;
}
extern "C" {
    #[doc = " Use this function to read 64 bits of big-endian data from an SDL_RWops and"]
    #[doc = " return in native format."]
    #[doc = ""]
    #[doc = " SDL byteswaps the data only if necessary, so the data returned will be in"]
    #[doc = " the native byte order."]
    #[doc = ""]
    #[doc = " \\param src the stream from which to read data"]
    #[doc = " \\returns 64 bits of data in the native byte order of the platform."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_ReadLE64"]
    pub fn SDL_ReadBE64(src: *mut SDL_RWops) -> Uint64;
}
extern "C" {
    #[doc = " Use this function to write a byte to an SDL_RWops."]
    #[doc = ""]
    #[doc = " \\param dst the SDL_RWops to write to"]
    #[doc = " \\param value the byte value to write"]
    #[doc = " \\returns 1 on success or 0 on failure; call SDL_GetError() for more"]
    #[doc = "          information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_ReadU8"]
    pub fn SDL_WriteU8(dst: *mut SDL_RWops, value: Uint8) -> size_t;
}
extern "C" {
    #[doc = " Use this function to write 16 bits in native format to a SDL_RWops as"]
    #[doc = " little-endian data."]
    #[doc = ""]
    #[doc = " SDL byteswaps the data only if necessary, so the application always"]
    #[doc = " specifies native format, and the data written will be in little-endian"]
    #[doc = " format."]
    #[doc = ""]
    #[doc = " \\param dst the stream to which data will be written"]
    #[doc = " \\param value the data to be written, in native format"]
    #[doc = " \\returns 1 on successful write, 0 on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_WriteBE16"]
    pub fn SDL_WriteLE16(dst: *mut SDL_RWops, value: Uint16) -> size_t;
}
extern "C" {
    #[doc = " Use this function to write 16 bits in native format to a SDL_RWops as"]
    #[doc = " big-endian data."]
    #[doc = ""]
    #[doc = " SDL byteswaps the data only if necessary, so the application always"]
    #[doc = " specifies native format, and the data written will be in big-endian format."]
    #[doc = ""]
    #[doc = " \\param dst the stream to which data will be written"]
    #[doc = " \\param value the data to be written, in native format"]
    #[doc = " \\returns 1 on successful write, 0 on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_WriteLE16"]
    pub fn SDL_WriteBE16(dst: *mut SDL_RWops, value: Uint16) -> size_t;
}
extern "C" {
    #[doc = " Use this function to write 32 bits in native format to a SDL_RWops as"]
    #[doc = " little-endian data."]
    #[doc = ""]
    #[doc = " SDL byteswaps the data only if necessary, so the application always"]
    #[doc = " specifies native format, and the data written will be in little-endian"]
    #[doc = " format."]
    #[doc = ""]
    #[doc = " \\param dst the stream to which data will be written"]
    #[doc = " \\param value the data to be written, in native format"]
    #[doc = " \\returns 1 on successful write, 0 on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_WriteBE32"]
    pub fn SDL_WriteLE32(dst: *mut SDL_RWops, value: Uint32) -> size_t;
}
extern "C" {
    #[doc = " Use this function to write 32 bits in native format to a SDL_RWops as"]
    #[doc = " big-endian data."]
    #[doc = ""]
    #[doc = " SDL byteswaps the data only if necessary, so the application always"]
    #[doc = " specifies native format, and the data written will be in big-endian format."]
    #[doc = ""]
    #[doc = " \\param dst the stream to which data will be written"]
    #[doc = " \\param value the data to be written, in native format"]
    #[doc = " \\returns 1 on successful write, 0 on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_WriteLE32"]
    pub fn SDL_WriteBE32(dst: *mut SDL_RWops, value: Uint32) -> size_t;
}
extern "C" {
    #[doc = " Use this function to write 64 bits in native format to a SDL_RWops as"]
    #[doc = " little-endian data."]
    #[doc = ""]
    #[doc = " SDL byteswaps the data only if necessary, so the application always"]
    #[doc = " specifies native format, and the data written will be in little-endian"]
    #[doc = " format."]
    #[doc = ""]
    #[doc = " \\param dst the stream to which data will be written"]
    #[doc = " \\param value the data to be written, in native format"]
    #[doc = " \\returns 1 on successful write, 0 on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_WriteBE64"]
    pub fn SDL_WriteLE64(dst: *mut SDL_RWops, value: Uint64) -> size_t;
}
extern "C" {
    #[doc = " Use this function to write 64 bits in native format to a SDL_RWops as"]
    #[doc = " big-endian data."]
    #[doc = ""]
    #[doc = " SDL byteswaps the data only if necessary, so the application always"]
    #[doc = " specifies native format, and the data written will be in big-endian format."]
    #[doc = ""]
    #[doc = " \\param dst the stream to which data will be written"]
    #[doc = " \\param value the data to be written, in native format"]
    #[doc = " \\returns 1 on successful write, 0 on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_WriteLE64"]
    pub fn SDL_WriteBE64(dst: *mut SDL_RWops, value: Uint64) -> size_t;
}
#[doc = "  \\brief Audio format flags."]
#[doc = ""]
#[doc = "  These are what the 16 bits in SDL_AudioFormat currently mean..."]
#[doc = "  (Unspecified bits are always zero)."]
#[doc = ""]
#[doc = "  \\verbatim"]
#[doc = "++-----------------------sample is signed if set"]
#[doc = "||"]
#[doc = "||       ++-----------sample is bigendian if set"]
#[doc = "||       ||"]
#[doc = "||       ||          ++---sample is float if set"]
#[doc = "||       ||          ||"]
#[doc = "||       ||          || +---sample bit size---+"]
#[doc = "||       ||          || |                     |"]
#[doc = "15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00"]
#[doc = "\\endverbatim"]
#[doc = ""]
#[doc = "  There are macros in SDL 2.0 and later to query these bits."]
pub type SDL_AudioFormat = Uint16;
#[doc = "  This function is called when the audio device needs more data."]
#[doc = ""]
#[doc = "  \\param userdata An application-specific parameter saved in"]
#[doc = "                  the SDL_AudioSpec structure"]
#[doc = "  \\param stream A pointer to the audio data buffer."]
#[doc = "  \\param len    The length of that buffer in bytes."]
#[doc = ""]
#[doc = "  Once the callback returns, the buffer will no longer be valid."]
#[doc = "  Stereo samples are stored in a LRLRLR ordering."]
#[doc = ""]
#[doc = "  You can choose to avoid callbacks and use SDL_QueueAudio() instead, if"]
#[doc = "  you like. Just open your audio device with a NULL callback."]
pub type SDL_AudioCallback = ::core::option::Option<
    unsafe extern "C" fn(userdata: *mut libc::c_void, stream: *mut Uint8, len: libc::c_int),
>;
#[doc = "  The calculated values in this structure are calculated by SDL_OpenAudio()."]
#[doc = ""]
#[doc = "  For multi-channel audio, the default SDL channel mapping is:"]
#[doc = "  2:  FL FR                       (stereo)"]
#[doc = "  3:  FL FR LFE                   (2.1 surround)"]
#[doc = "  4:  FL FR BL BR                 (quad)"]
#[doc = "  5:  FL FR FC BL BR              (quad + center)"]
#[doc = "  6:  FL FR FC LFE SL SR          (5.1 surround - last two can also be BL BR)"]
#[doc = "  7:  FL FR FC LFE BC SL SR       (6.1 surround)"]
#[doc = "  8:  FL FR FC LFE BL BR SL SR    (7.1 surround)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_AudioSpec {
    #[doc = "< DSP frequency -- samples per second"]
    pub freq: libc::c_int,
    #[doc = "< Audio data format"]
    pub format: SDL_AudioFormat,
    #[doc = "< Number of channels: 1 mono, 2 stereo"]
    pub channels: Uint8,
    #[doc = "< Audio buffer silence value (calculated)"]
    pub silence: Uint8,
    #[doc = "< Audio buffer size in sample FRAMES (total samples divided by channel count)"]
    pub samples: Uint16,
    #[doc = "< Necessary for some compile environments"]
    pub padding: Uint16,
    #[doc = "< Audio buffer size in bytes (calculated)"]
    pub size: Uint32,
    #[doc = "< Callback that feeds the audio device (NULL to use SDL_QueueAudio())."]
    pub callback: SDL_AudioCallback,
    #[doc = "< Userdata passed to callback (ignored for NULL callbacks)."]
    pub userdata: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_SDL_AudioSpec() {
    assert_eq!(
        ::core::mem::size_of::<SDL_AudioSpec>(),
        32usize,
        concat!("Size of: ", stringify!(SDL_AudioSpec))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_AudioSpec>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_AudioSpec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).freq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(freq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).format as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).channels as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).silence as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(silence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).samples as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).padding as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).callback as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AudioSpec>())).userdata as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(userdata)
        )
    );
}
pub type SDL_AudioFilter =
    ::core::option::Option<unsafe extern "C" fn(cvt: *mut SDL_AudioCVT, format: SDL_AudioFormat)>;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct SDL_AudioCVT {
    #[doc = "< Set to 1 if conversion possible"]
    pub needed: libc::c_int,
    #[doc = "< Source audio format"]
    pub src_format: SDL_AudioFormat,
    #[doc = "< Target audio format"]
    pub dst_format: SDL_AudioFormat,
    #[doc = "< Rate conversion increment"]
    pub rate_incr: f64,
    #[doc = "< Buffer to hold entire audio data"]
    pub buf: *mut Uint8,
    #[doc = "< Length of original audio buffer"]
    pub len: libc::c_int,
    #[doc = "< Length of converted audio buffer"]
    pub len_cvt: libc::c_int,
    #[doc = "< buffer must be len*len_mult big"]
    pub len_mult: libc::c_int,
    #[doc = "< Given len, final size is len*len_ratio"]
    pub len_ratio: f64,
    #[doc = "< NULL-terminated list of filter functions"]
    pub filters: [SDL_AudioFilter; 10usize],
    #[doc = "< Current audio conversion function"]
    pub filter_index: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_AudioCVT() {
    assert_eq!(
        ::core::mem::size_of::<SDL_AudioCVT>(),
        128usize,
        concat!("Size of: ", stringify!(SDL_AudioCVT))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_AudioCVT>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_AudioCVT))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).needed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(needed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).src_format as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(src_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).dst_format as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(dst_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).rate_incr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(rate_incr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).buf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).len_cvt as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(len_cvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).len_mult as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(len_mult)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).len_ratio as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(len_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).filters as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(filters)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AudioCVT>())).filter_index as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(filter_index)
        )
    );
}
extern "C" {
    #[doc = " Use this function to get the number of built-in audio drivers."]
    #[doc = ""]
    #[doc = " This function returns a hardcoded number. This never returns a negative"]
    #[doc = " value; if there are no drivers compiled into this build of SDL, this"]
    #[doc = " function returns zero. The presence of a driver in this list does not mean"]
    #[doc = " it will function, it just means SDL is capable of interacting with that"]
    #[doc = " interface. For example, a build of SDL might have esound support, but if"]
    #[doc = " there's no esound server available, SDL's esound driver would fail if used."]
    #[doc = ""]
    #[doc = " By default, SDL tries all drivers, in its preferred order, until one is"]
    #[doc = " found to be usable."]
    #[doc = ""]
    #[doc = " \\returns the number of built-in audio drivers."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetAudioDriver"]
    pub fn SDL_GetNumAudioDrivers() -> libc::c_int;
}
extern "C" {
    #[doc = " Use this function to get the name of a built in audio driver."]
    #[doc = ""]
    #[doc = " The list of audio drivers is given in the order that they are normally"]
    #[doc = " initialized by default; the drivers that seem more reasonable to choose"]
    #[doc = " first (as far as the SDL developers believe) are earlier in the list."]
    #[doc = ""]
    #[doc = " The names of drivers are all simple, low-ASCII identifiers, like \"alsa\","]
    #[doc = " \"coreaudio\" or \"xaudio2\". These never have Unicode characters, and are not"]
    #[doc = " meant to be proper names."]
    #[doc = ""]
    #[doc = " \\param index the index of the audio driver; the value ranges from 0 to"]
    #[doc = "              SDL_GetNumAudioDrivers() - 1"]
    #[doc = " \\returns the name of the audio driver at the requested index, or NULL if an"]
    #[doc = "          invalid index was specified."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetNumAudioDrivers"]
    pub fn SDL_GetAudioDriver(index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Use this function to initialize a particular audio driver."]
    #[doc = ""]
    #[doc = " This function is used internally, and should not be used unless you have a"]
    #[doc = " specific need to designate the audio driver you want to use. You should"]
    #[doc = " normally use SDL_Init() or SDL_InitSubSystem()."]
    #[doc = ""]
    #[doc = " \\param driver_name the name of the desired audio driver"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_AudioQuit"]
    pub fn SDL_AudioInit(driver_name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Use this function to shut down audio if you initialized it with"]
    #[doc = " SDL_AudioInit()."]
    #[doc = ""]
    #[doc = " This function is used internally, and should not be used unless you have a"]
    #[doc = " specific need to specify the audio driver you want to use. You should"]
    #[doc = " normally use SDL_Quit() or SDL_QuitSubSystem()."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_AudioInit"]
    pub fn SDL_AudioQuit();
}
extern "C" {
    #[doc = " Get the name of the current audio driver."]
    #[doc = ""]
    #[doc = " The returned string points to internal static memory and thus never becomes"]
    #[doc = " invalid, even if you quit the audio subsystem and initialize a new driver"]
    #[doc = " (although such a case would return a different static string from another"]
    #[doc = " call to this function, of course). As such, you should not modify or free"]
    #[doc = " the returned string."]
    #[doc = ""]
    #[doc = " \\returns the name of the current audio driver or NULL if no driver has been"]
    #[doc = "          initialized."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_AudioInit"]
    pub fn SDL_GetCurrentAudioDriver() -> *const libc::c_char;
}
extern "C" {
    #[doc = " This function is a legacy means of opening the audio device."]
    #[doc = ""]
    #[doc = " This function remains for compatibility with SDL 1.2, but also because it's"]
    #[doc = " slightly easier to use than the new functions in SDL 2.0. The new, more"]
    #[doc = " powerful, and preferred way to do this is SDL_OpenAudioDevice()."]
    #[doc = ""]
    #[doc = " This function is roughly equivalent to:"]
    #[doc = ""]
    #[doc = " ```c"]
    #[doc = " SDL_OpenAudioDevice(NULL, 0, desired, obtained, SDL_AUDIO_ALLOW_ANY_CHANGE);"]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " With two notable exceptions:"]
    #[doc = ""]
    #[doc = " - If `obtained` is NULL, we use `desired` (and allow no changes), which"]
    #[doc = "   means desired will be modified to have the correct values for silence,"]
    #[doc = "   etc, and SDL will convert any differences between your app's specific"]
    #[doc = "   request and the hardware behind the scenes."]
    #[doc = " - The return value is always success or failure, and not a device ID, which"]
    #[doc = "   means you can only have one device open at a time with this function."]
    #[doc = ""]
    #[doc = " \\param desired an SDL_AudioSpec structure representing the desired output"]
    #[doc = "                format. Please refer to the SDL_OpenAudioDevice"]
    #[doc = "                documentation for details on how to prepare this structure."]
    #[doc = " \\param obtained an SDL_AudioSpec structure filled in with the actual"]
    #[doc = "                 parameters, or NULL."]
    #[doc = " \\returns 0 if successful, placing the actual hardware parameters in the"]
    #[doc = "          structure pointed to by `obtained`."]
    #[doc = ""]
    #[doc = "          If `obtained` is NULL, the audio data passed to the callback"]
    #[doc = "          function will be guaranteed to be in the requested format, and"]
    #[doc = "          will be automatically converted to the actual hardware audio"]
    #[doc = "          format if necessary. If `obtained` is NULL, `desired` will have"]
    #[doc = "          fields modified."]
    #[doc = ""]
    #[doc = "          This function returns a negative error code on failure to open the"]
    #[doc = "          audio device or failure to set up the audio thread; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CloseAudio"]
    #[doc = " \\sa SDL_LockAudio"]
    #[doc = " \\sa SDL_PauseAudio"]
    #[doc = " \\sa SDL_UnlockAudio"]
    pub fn SDL_OpenAudio(desired: *mut SDL_AudioSpec, obtained: *mut SDL_AudioSpec) -> libc::c_int;
}
#[doc = "  SDL Audio Device IDs."]
#[doc = ""]
#[doc = "  A successful call to SDL_OpenAudio() is always device id 1, and legacy"]
#[doc = "  SDL audio APIs assume you want this device ID. SDL_OpenAudioDevice() calls"]
#[doc = "  always returns devices >= 2 on success. The legacy calls are good both"]
#[doc = "  for backwards compatibility and when you don't care about multiple,"]
#[doc = "  specific, or capture devices."]
pub type SDL_AudioDeviceID = Uint32;
extern "C" {
    #[doc = " Get the number of built-in audio devices."]
    #[doc = ""]
    #[doc = " This function is only valid after successfully initializing the audio"]
    #[doc = " subsystem."]
    #[doc = ""]
    #[doc = " Note that audio capture support is not implemented as of SDL 2.0.4, so the"]
    #[doc = " `iscapture` parameter is for future expansion and should always be zero for"]
    #[doc = " now."]
    #[doc = ""]
    #[doc = " This function will return -1 if an explicit list of devices can't be"]
    #[doc = " determined. Returning -1 is not an error. For example, if SDL is set up to"]
    #[doc = " talk to a remote audio server, it can't list every one available on the"]
    #[doc = " Internet, but it will still allow a specific host to be specified in"]
    #[doc = " SDL_OpenAudioDevice()."]
    #[doc = ""]
    #[doc = " In many common cases, when this function returns a value <= 0, it can still"]
    #[doc = " successfully open the default device (NULL for first argument of"]
    #[doc = " SDL_OpenAudioDevice())."]
    #[doc = ""]
    #[doc = " This function may trigger a complete redetect of available hardware. It"]
    #[doc = " should not be called for each iteration of a loop, but rather once at the"]
    #[doc = " start of a loop:"]
    #[doc = ""]
    #[doc = " ```c"]
    #[doc = " // Don't do this:"]
    #[doc = " for (int i = 0; i < SDL_GetNumAudioDevices(0); i++)"]
    #[doc = ""]
    #[doc = " // do this instead:"]
    #[doc = " const int count = SDL_GetNumAudioDevices(0);"]
    #[doc = " for (int i = 0; i < count; ++i) { do_something_here(); }"]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " \\param iscapture zero to request playback devices, non-zero to request"]
    #[doc = "                  recording devices"]
    #[doc = " \\returns the number of available devices exposed by the current driver or"]
    #[doc = "          -1 if an explicit list of devices can't be determined. A return"]
    #[doc = "          value of -1 does not necessarily mean an error condition."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetAudioDeviceName"]
    #[doc = " \\sa SDL_OpenAudioDevice"]
    pub fn SDL_GetNumAudioDevices(iscapture: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the human-readable name of a specific audio device."]
    #[doc = ""]
    #[doc = " This function is only valid after successfully initializing the audio"]
    #[doc = " subsystem. The values returned by this function reflect the latest call to"]
    #[doc = " SDL_GetNumAudioDevices(); re-call that function to redetect available"]
    #[doc = " hardware."]
    #[doc = ""]
    #[doc = " The string returned by this function is UTF-8 encoded, read-only, and"]
    #[doc = " managed internally. You are not to free it. If you need to keep the string"]
    #[doc = " for any length of time, you should make your own copy of it, as it will be"]
    #[doc = " invalid next time any of several other SDL functions are called."]
    #[doc = ""]
    #[doc = " \\param index the index of the audio device; valid values range from 0 to"]
    #[doc = "              SDL_GetNumAudioDevices() - 1"]
    #[doc = " \\param iscapture non-zero to query the list of recording devices, zero to"]
    #[doc = "                  query the list of output devices."]
    #[doc = " \\returns the name of the audio device at the requested index, or NULL on"]
    #[doc = "          error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetNumAudioDevices"]
    pub fn SDL_GetAudioDeviceName(
        index: libc::c_int,
        iscapture: libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the preferred audio format of a specific audio device."]
    #[doc = ""]
    #[doc = " This function is only valid after a successfully initializing the audio"]
    #[doc = " subsystem. The values returned by this function reflect the latest call to"]
    #[doc = " SDL_GetNumAudioDevices(); re-call that function to redetect available"]
    #[doc = " hardware."]
    #[doc = ""]
    #[doc = " `spec` will be filled with the sample rate, sample format, and channel"]
    #[doc = " count. All other values in the structure are filled with 0. When the"]
    #[doc = " supported struct members are 0, SDL was unable to get the property from the"]
    #[doc = " backend."]
    #[doc = ""]
    #[doc = " \\param index the index of the audio device; valid values range from 0 to"]
    #[doc = "              SDL_GetNumAudioDevices() - 1"]
    #[doc = " \\param iscapture non-zero to query the list of recording devices, zero to"]
    #[doc = "                  query the list of output devices."]
    #[doc = " \\param spec The SDL_AudioSpec to be initialized by this function."]
    #[doc = " \\returns 0 on success, nonzero on error"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.16."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetNumAudioDevices"]
    pub fn SDL_GetAudioDeviceSpec(
        index: libc::c_int,
        iscapture: libc::c_int,
        spec: *mut SDL_AudioSpec,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Open a specific audio device."]
    #[doc = ""]
    #[doc = " SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,"]
    #[doc = " this function will never return a 1 so as not to conflict with the legacy"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " Please note that SDL 2.0 before 2.0.5 did not support recording; as such,"]
    #[doc = " this function would fail if `iscapture` was not zero. Starting with SDL"]
    #[doc = " 2.0.5, recording is implemented and this value can be non-zero."]
    #[doc = ""]
    #[doc = " Passing in a `device` name of NULL requests the most reasonable default"]
    #[doc = " (and is equivalent to what SDL_OpenAudio() does to choose a device). The"]
    #[doc = " `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but"]
    #[doc = " some drivers allow arbitrary and driver-specific strings, such as a"]
    #[doc = " hostname/IP address for a remote audio server, or a filename in the"]
    #[doc = " diskaudio driver."]
    #[doc = ""]
    #[doc = " An opened audio device starts out paused, and should be enabled for playing"]
    #[doc = " by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio"]
    #[doc = " callback function to be called. Since the audio driver may modify the"]
    #[doc = " requested size of the audio buffer, you should allocate any local mixing"]
    #[doc = " buffers after you open the audio device."]
    #[doc = ""]
    #[doc = " The audio callback runs in a separate thread in most cases; you can prevent"]
    #[doc = " race conditions between your callback and other threads without fully"]
    #[doc = " pausing playback with SDL_LockAudioDevice(). For more information about the"]
    #[doc = " callback, see SDL_AudioSpec."]
    #[doc = ""]
    #[doc = " Managing the audio spec via 'desired' and 'obtained':"]
    #[doc = ""]
    #[doc = " When filling in the desired audio spec structure:"]
    #[doc = ""]
    #[doc = " - `desired->freq` should be the frequency in sample-frames-per-second (Hz)."]
    #[doc = " - `desired->format` should be the audio format (`AUDIO_S16SYS`, etc)."]
    #[doc = " - `desired->samples` is the desired size of the audio buffer, in _sample"]
    #[doc = "   frames_ (with stereo output, two samples--left and right--would make a"]
    #[doc = "   single sample frame). This number should be a power of two, and may be"]
    #[doc = "   adjusted by the audio driver to a value more suitable for the hardware."]
    #[doc = "   Good values seem to range between 512 and 8096 inclusive, depending on"]
    #[doc = "   the application and CPU speed. Smaller values reduce latency, but can"]
    #[doc = "   lead to underflow if the application is doing heavy processing and cannot"]
    #[doc = "   fill the audio buffer in time. Note that the number of sample frames is"]
    #[doc = "   directly related to time by the following formula: `ms ="]
    #[doc = "   (sampleframes*1000)/freq`"]
    #[doc = " - `desired->size` is the size in _bytes_ of the audio buffer, and is"]
    #[doc = "   calculated by SDL_OpenAudioDevice(). You don't initialize this."]
    #[doc = " - `desired->silence` is the value used to set the buffer to silence, and is"]
    #[doc = "   calculated by SDL_OpenAudioDevice(). You don't initialize this."]
    #[doc = " - `desired->callback` should be set to a function that will be called when"]
    #[doc = "   the audio device is ready for more data. It is passed a pointer to the"]
    #[doc = "   audio buffer, and the length in bytes of the audio buffer. This function"]
    #[doc = "   usually runs in a separate thread, and so you should protect data"]
    #[doc = "   structures that it accesses by calling SDL_LockAudioDevice() and"]
    #[doc = "   SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL"]
    #[doc = "   pointer here, and call SDL_QueueAudio() with some frequency, to queue"]
    #[doc = "   more audio samples to be played (or for capture devices, call"]
    #[doc = "   SDL_DequeueAudio() with some frequency, to obtain audio samples)."]
    #[doc = " - `desired->userdata` is passed as the first parameter to your callback"]
    #[doc = "   function. If you passed a NULL callback, this value is ignored."]
    #[doc = ""]
    #[doc = " `allowed_changes` can have the following flags OR'd together:"]
    #[doc = ""]
    #[doc = " - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`"]
    #[doc = " - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`"]
    #[doc = " - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`"]
    #[doc = " - `SDL_AUDIO_ALLOW_ANY_CHANGE`"]
    #[doc = ""]
    #[doc = " These flags specify how SDL should behave when a device cannot offer a"]
    #[doc = " specific feature. If the application requests a feature that the hardware"]
    #[doc = " doesn't offer, SDL will always try to get the closest equivalent."]
    #[doc = ""]
    #[doc = " For example, if you ask for float32 audio format, but the sound card only"]
    #[doc = " supports int16, SDL will set the hardware to int16. If you had set"]
    #[doc = " SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`"]
    #[doc = " structure. If that flag was *not* set, SDL will prepare to convert your"]
    #[doc = " callback's float32 audio to int16 before feeding it to the hardware and"]
    #[doc = " will keep the originally requested format in the `obtained` structure."]
    #[doc = ""]
    #[doc = " The resulting audio specs, varying depending on hardware and on what"]
    #[doc = " changes were allowed, will then be written back to `obtained`."]
    #[doc = ""]
    #[doc = " If your application can only handle one specific data format, pass a zero"]
    #[doc = " for `allowed_changes` and let SDL transparently handle any differences."]
    #[doc = ""]
    #[doc = " \\param device a UTF-8 string reported by SDL_GetAudioDeviceName() or a"]
    #[doc = "               driver-specific name as appropriate. NULL requests the most"]
    #[doc = "               reasonable default device."]
    #[doc = " \\param iscapture non-zero to specify a device should be opened for"]
    #[doc = "                  recording, not playback"]
    #[doc = " \\param desired an SDL_AudioSpec structure representing the desired output"]
    #[doc = "                format; see SDL_OpenAudio() for more information"]
    #[doc = " \\param obtained an SDL_AudioSpec structure filled in with the actual output"]
    #[doc = "                 format; see SDL_OpenAudio() for more information"]
    #[doc = " \\param allowed_changes 0, or one or more flags OR'd together"]
    #[doc = " \\returns a valid device ID that is > 0 on success or 0 on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = "          For compatibility with SDL 1.2, this will never return 1, since"]
    #[doc = "          SDL reserves that ID for the legacy SDL_OpenAudio() function."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CloseAudioDevice"]
    #[doc = " \\sa SDL_GetAudioDeviceName"]
    #[doc = " \\sa SDL_LockAudioDevice"]
    #[doc = " \\sa SDL_OpenAudio"]
    #[doc = " \\sa SDL_PauseAudioDevice"]
    #[doc = " \\sa SDL_UnlockAudioDevice"]
    pub fn SDL_OpenAudioDevice(
        device: *const libc::c_char,
        iscapture: libc::c_int,
        desired: *const SDL_AudioSpec,
        obtained: *mut SDL_AudioSpec,
        allowed_changes: libc::c_int,
    ) -> SDL_AudioDeviceID;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_AudioStatus {
    SDL_AUDIO_STOPPED = 0,
    SDL_AUDIO_PLAYING = 1,
    SDL_AUDIO_PAUSED = 2,
}
extern "C" {
    #[doc = " This function is a legacy means of querying the audio device."]
    #[doc = ""]
    #[doc = " New programs might want to use SDL_GetAudioDeviceStatus() instead. This"]
    #[doc = " function is equivalent to calling..."]
    #[doc = ""]
    #[doc = " ```c"]
    #[doc = " SDL_GetAudioDeviceStatus(1);"]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " ...and is only useful if you used the legacy SDL_OpenAudio() function."]
    #[doc = ""]
    #[doc = " \\returns the SDL_AudioStatus of the audio device opened by SDL_OpenAudio()."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetAudioDeviceStatus"]
    pub fn SDL_GetAudioStatus() -> SDL_AudioStatus;
}
extern "C" {
    #[doc = " Use this function to get the current audio state of an audio device."]
    #[doc = ""]
    #[doc = " \\param dev the ID of an audio device previously opened with"]
    #[doc = "            SDL_OpenAudioDevice()"]
    #[doc = " \\returns the SDL_AudioStatus of the specified audio device."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_PauseAudioDevice"]
    pub fn SDL_GetAudioDeviceStatus(dev: SDL_AudioDeviceID) -> SDL_AudioStatus;
}
extern "C" {
    #[doc = " This function is a legacy means of pausing the audio device."]
    #[doc = ""]
    #[doc = " New programs might want to use SDL_PauseAudioDevice() instead. This"]
    #[doc = " function is equivalent to calling..."]
    #[doc = ""]
    #[doc = " ```c"]
    #[doc = " SDL_PauseAudioDevice(1, pause_on);"]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " ...and is only useful if you used the legacy SDL_OpenAudio() function."]
    #[doc = ""]
    #[doc = " \\param pause_on non-zero to pause, 0 to unpause"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetAudioStatus"]
    #[doc = " \\sa SDL_PauseAudioDevice"]
    pub fn SDL_PauseAudio(pause_on: libc::c_int);
}
extern "C" {
    #[doc = " Use this function to pause and unpause audio playback on a specified"]
    #[doc = " device."]
    #[doc = ""]
    #[doc = " This function pauses and unpauses the audio callback processing for a given"]
    #[doc = " device. Newly-opened audio devices start in the paused state, so you must"]
    #[doc = " call this function with **pause_on**=0 after opening the specified audio"]
    #[doc = " device to start playing sound. This allows you to safely initialize data"]
    #[doc = " for your callback function after opening the audio device. Silence will be"]
    #[doc = " written to the audio device while paused, and the audio callback is"]
    #[doc = " guaranteed to not be called. Pausing one device does not prevent other"]
    #[doc = " unpaused devices from running their callbacks."]
    #[doc = ""]
    #[doc = " Pausing state does not stack; even if you pause a device several times, a"]
    #[doc = " single unpause will start the device playing again, and vice versa. This is"]
    #[doc = " different from how SDL_LockAudioDevice() works."]
    #[doc = ""]
    #[doc = " If you just need to protect a few variables from race conditions vs your"]
    #[doc = " callback, you shouldn't pause the audio device, as it will lead to dropouts"]
    #[doc = " in the audio playback. Instead, you should use SDL_LockAudioDevice()."]
    #[doc = ""]
    #[doc = " \\param dev a device opened by SDL_OpenAudioDevice()"]
    #[doc = " \\param pause_on non-zero to pause, 0 to unpause"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_LockAudioDevice"]
    pub fn SDL_PauseAudioDevice(dev: SDL_AudioDeviceID, pause_on: libc::c_int);
}
extern "C" {
    #[doc = " Load the audio data of a WAVE file into memory."]
    #[doc = ""]
    #[doc = " Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to"]
    #[doc = " be valid pointers. The entire data portion of the file is then loaded into"]
    #[doc = " memory and decoded if necessary."]
    #[doc = ""]
    #[doc = " If `freesrc` is non-zero, the data source gets automatically closed and"]
    #[doc = " freed before the function returns."]
    #[doc = ""]
    #[doc = " Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and"]
    #[doc = " 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and"]
    #[doc = " A-law and mu-law (8 bits). Other formats are currently unsupported and"]
    #[doc = " cause an error."]
    #[doc = ""]
    #[doc = " If this function succeeds, the pointer returned by it is equal to `spec`"]
    #[doc = " and the pointer to the audio data allocated by the function is written to"]
    #[doc = " `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec"]
    #[doc = " members `freq`, `channels`, and `format` are set to the values of the audio"]
    #[doc = " data in the buffer. The `samples` member is set to a sane default and all"]
    #[doc = " others are set to zero."]
    #[doc = ""]
    #[doc = " It's necessary to use SDL_FreeWAV() to free the audio data returned in"]
    #[doc = " `audio_buf` when it is no longer used."]
    #[doc = ""]
    #[doc = " Because of the underspecification of the .WAV format, there are many"]
    #[doc = " problematic files in the wild that cause issues with strict decoders. To"]
    #[doc = " provide compatibility with these files, this decoder is lenient in regards"]
    #[doc = " to the truncation of the file, the fact chunk, and the size of the RIFF"]
    #[doc = " chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,"]
    #[doc = " `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to"]
    #[doc = " tune the behavior of the loading process."]
    #[doc = ""]
    #[doc = " Any file that is invalid (due to truncation, corruption, or wrong values in"]
    #[doc = " the headers), too big, or unsupported causes an error. Additionally, any"]
    #[doc = " critical I/O error from the data source will terminate the loading process"]
    #[doc = " with an error. The function returns NULL on error and in all cases (with"]
    #[doc = " the exception of `src` being NULL), an appropriate error message will be"]
    #[doc = " set."]
    #[doc = ""]
    #[doc = " It is required that the data source supports seeking."]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = ""]
    #[doc = " ```c"]
    #[doc = " SDL_LoadWAV_RW(SDL_RWFromFile(\"sample.wav\", \"rb\"), 1, &spec, &buf, &len);"]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " Note that the SDL_LoadWAV macro does this same thing for you, but in a less"]
    #[doc = " messy way:"]
    #[doc = ""]
    #[doc = " ```c"]
    #[doc = " SDL_LoadWAV(\"sample.wav\", &spec, &buf, &len);"]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " \\param src The data source for the WAVE data"]
    #[doc = " \\param freesrc If non-zero, SDL will _always_ free the data source"]
    #[doc = " \\param spec An SDL_AudioSpec that will be filled in with the wave file's"]
    #[doc = "             format details"]
    #[doc = " \\param audio_buf A pointer filled with the audio data, allocated by the"]
    #[doc = "                  function."]
    #[doc = " \\param audio_len A pointer filled with the length of the audio data buffer"]
    #[doc = "                  in bytes"]
    #[doc = " \\returns This function, if successfully called, returns `spec`, which will"]
    #[doc = "          be filled with the audio data format of the wave source data."]
    #[doc = "          `audio_buf` will be filled with a pointer to an allocated buffer"]
    #[doc = "          containing the audio data, and `audio_len` is filled with the"]
    #[doc = "          length of that audio buffer in bytes."]
    #[doc = ""]
    #[doc = "          This function returns NULL if the .WAV file cannot be opened, uses"]
    #[doc = "          an unknown data format, or is corrupt; call SDL_GetError() for"]
    #[doc = "          more information."]
    #[doc = ""]
    #[doc = "          When the application is done with the data returned in"]
    #[doc = "          `audio_buf`, it should call SDL_FreeWAV() to dispose of it."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_FreeWAV"]
    #[doc = " \\sa SDL_LoadWAV"]
    pub fn SDL_LoadWAV_RW(
        src: *mut SDL_RWops,
        freesrc: libc::c_int,
        spec: *mut SDL_AudioSpec,
        audio_buf: *mut *mut Uint8,
        audio_len: *mut Uint32,
    ) -> *mut SDL_AudioSpec;
}
extern "C" {
    #[doc = " Free data previously allocated with SDL_LoadWAV() or SDL_LoadWAV_RW()."]
    #[doc = ""]
    #[doc = " After a WAVE file has been opened with SDL_LoadWAV() or SDL_LoadWAV_RW()"]
    #[doc = " its data can eventually be freed with SDL_FreeWAV(). It is safe to call"]
    #[doc = " this function with a NULL pointer."]
    #[doc = ""]
    #[doc = " \\param audio_buf a pointer to the buffer created by SDL_LoadWAV() or"]
    #[doc = "                  SDL_LoadWAV_RW()"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_LoadWAV"]
    #[doc = " \\sa SDL_LoadWAV_RW"]
    pub fn SDL_FreeWAV(audio_buf: *mut Uint8);
}
extern "C" {
    #[doc = " Initialize an SDL_AudioCVT structure for conversion."]
    #[doc = ""]
    #[doc = " Before an SDL_AudioCVT structure can be used to convert audio data it must"]
    #[doc = " be initialized with source and destination information."]
    #[doc = ""]
    #[doc = " This function will zero out every field of the SDL_AudioCVT, so it must be"]
    #[doc = " called before the application fills in the final buffer information."]
    #[doc = ""]
    #[doc = " Once this function has returned successfully, and reported that a"]
    #[doc = " conversion is necessary, the application fills in the rest of the fields in"]
    #[doc = " SDL_AudioCVT, now that it knows how large a buffer it needs to allocate,"]
    #[doc = " and then can call SDL_ConvertAudio() to complete the conversion."]
    #[doc = ""]
    #[doc = " \\param cvt an SDL_AudioCVT structure filled in with audio conversion"]
    #[doc = "            information"]
    #[doc = " \\param src_format the source format of the audio data; for more info see"]
    #[doc = "                   SDL_AudioFormat"]
    #[doc = " \\param src_channels the number of channels in the source"]
    #[doc = " \\param src_rate the frequency (sample-frames-per-second) of the source"]
    #[doc = " \\param dst_format the destination format of the audio data; for more info"]
    #[doc = "                   see SDL_AudioFormat"]
    #[doc = " \\param dst_channels the number of channels in the destination"]
    #[doc = " \\param dst_rate the frequency (sample-frames-per-second) of the destination"]
    #[doc = " \\returns 1 if the audio filter is prepared, 0 if no conversion is needed,"]
    #[doc = "          or a negative error code on failure; call SDL_GetError() for more"]
    #[doc = "          information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_ConvertAudio"]
    pub fn SDL_BuildAudioCVT(
        cvt: *mut SDL_AudioCVT,
        src_format: SDL_AudioFormat,
        src_channels: Uint8,
        src_rate: libc::c_int,
        dst_format: SDL_AudioFormat,
        dst_channels: Uint8,
        dst_rate: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Convert audio data to a desired audio format."]
    #[doc = ""]
    #[doc = " This function does the actual audio data conversion, after the application"]
    #[doc = " has called SDL_BuildAudioCVT() to prepare the conversion information and"]
    #[doc = " then filled in the buffer details."]
    #[doc = ""]
    #[doc = " Once the application has initialized the `cvt` structure using"]
    #[doc = " SDL_BuildAudioCVT(), allocated an audio buffer and filled it with audio"]
    #[doc = " data in the source format, this function will convert the buffer, in-place,"]
    #[doc = " to the desired format."]
    #[doc = ""]
    #[doc = " The data conversion may go through several passes; any given pass may"]
    #[doc = " possibly temporarily increase the size of the data. For example, SDL might"]
    #[doc = " expand 16-bit data to 32 bits before resampling to a lower frequency,"]
    #[doc = " shrinking the data size after having grown it briefly. Since the supplied"]
    #[doc = " buffer will be both the source and destination, converting as necessary"]
    #[doc = " in-place, the application must allocate a buffer that will fully contain"]
    #[doc = " the data during its largest conversion pass. After SDL_BuildAudioCVT()"]
    #[doc = " returns, the application should set the `cvt->len` field to the size, in"]
    #[doc = " bytes, of the source data, and allocate a buffer that is `cvt->len *"]
    #[doc = " cvt->len_mult` bytes long for the `buf` field."]
    #[doc = ""]
    #[doc = " The source data should be copied into this buffer before the call to"]
    #[doc = " SDL_ConvertAudio(). Upon successful return, this buffer will contain the"]
    #[doc = " converted audio, and `cvt->len_cvt` will be the size of the converted data,"]
    #[doc = " in bytes. Any bytes in the buffer past `cvt->len_cvt` are undefined once"]
    #[doc = " this function returns."]
    #[doc = ""]
    #[doc = " \\param cvt an SDL_AudioCVT structure that was previously set up by"]
    #[doc = "            SDL_BuildAudioCVT()."]
    #[doc = " \\returns 0 if the conversion was completed successfully or a negative error"]
    #[doc = "          code on failure; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_BuildAudioCVT"]
    pub fn SDL_ConvertAudio(cvt: *mut SDL_AudioCVT) -> libc::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SDL_AudioStream {
    _unused: [u8; 0],
}
pub type SDL_AudioStream = _SDL_AudioStream;
extern "C" {
    #[doc = " Create a new audio stream."]
    #[doc = ""]
    #[doc = " \\param src_format The format of the source audio"]
    #[doc = " \\param src_channels The number of channels of the source audio"]
    #[doc = " \\param src_rate The sampling rate of the source audio"]
    #[doc = " \\param dst_format The format of the desired audio output"]
    #[doc = " \\param dst_channels The number of channels of the desired audio output"]
    #[doc = " \\param dst_rate The sampling rate of the desired audio output"]
    #[doc = " \\returns 0 on success, or -1 on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.7."]
    #[doc = ""]
    #[doc = " \\sa SDL_AudioStreamPut"]
    #[doc = " \\sa SDL_AudioStreamGet"]
    #[doc = " \\sa SDL_AudioStreamAvailable"]
    #[doc = " \\sa SDL_AudioStreamFlush"]
    #[doc = " \\sa SDL_AudioStreamClear"]
    #[doc = " \\sa SDL_FreeAudioStream"]
    pub fn SDL_NewAudioStream(
        src_format: SDL_AudioFormat,
        src_channels: Uint8,
        src_rate: libc::c_int,
        dst_format: SDL_AudioFormat,
        dst_channels: Uint8,
        dst_rate: libc::c_int,
    ) -> *mut SDL_AudioStream;
}
extern "C" {
    #[doc = " Add data to be converted/resampled to the stream."]
    #[doc = ""]
    #[doc = " \\param stream The stream the audio data is being added to"]
    #[doc = " \\param buf A pointer to the audio data to add"]
    #[doc = " \\param len The number of bytes to write to the stream"]
    #[doc = " \\returns 0 on success, or -1 on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.7."]
    #[doc = ""]
    #[doc = " \\sa SDL_NewAudioStream"]
    #[doc = " \\sa SDL_AudioStreamGet"]
    #[doc = " \\sa SDL_AudioStreamAvailable"]
    #[doc = " \\sa SDL_AudioStreamFlush"]
    #[doc = " \\sa SDL_AudioStreamClear"]
    #[doc = " \\sa SDL_FreeAudioStream"]
    pub fn SDL_AudioStreamPut(
        stream: *mut SDL_AudioStream,
        buf: *const libc::c_void,
        len: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get converted/resampled data from the stream"]
    #[doc = ""]
    #[doc = " \\param stream The stream the audio is being requested from"]
    #[doc = " \\param buf A buffer to fill with audio data"]
    #[doc = " \\param len The maximum number of bytes to fill"]
    #[doc = " \\returns the number of bytes read from the stream, or -1 on error"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.7."]
    #[doc = ""]
    #[doc = " \\sa SDL_NewAudioStream"]
    #[doc = " \\sa SDL_AudioStreamPut"]
    #[doc = " \\sa SDL_AudioStreamAvailable"]
    #[doc = " \\sa SDL_AudioStreamFlush"]
    #[doc = " \\sa SDL_AudioStreamClear"]
    #[doc = " \\sa SDL_FreeAudioStream"]
    pub fn SDL_AudioStreamGet(
        stream: *mut SDL_AudioStream,
        buf: *mut libc::c_void,
        len: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the number of converted/resampled bytes available."]
    #[doc = ""]
    #[doc = " The stream may be buffering data behind the scenes until it has enough to"]
    #[doc = " resample correctly, so this number might be lower than what you expect, or"]
    #[doc = " even be zero. Add more data or flush the stream if you need the data now."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.7."]
    #[doc = ""]
    #[doc = " \\sa SDL_NewAudioStream"]
    #[doc = " \\sa SDL_AudioStreamPut"]
    #[doc = " \\sa SDL_AudioStreamGet"]
    #[doc = " \\sa SDL_AudioStreamFlush"]
    #[doc = " \\sa SDL_AudioStreamClear"]
    #[doc = " \\sa SDL_FreeAudioStream"]
    pub fn SDL_AudioStreamAvailable(stream: *mut SDL_AudioStream) -> libc::c_int;
}
extern "C" {
    #[doc = " Tell the stream that you're done sending data, and anything being buffered"]
    #[doc = " should be converted/resampled and made available immediately."]
    #[doc = ""]
    #[doc = " It is legal to add more data to a stream after flushing, but there will be"]
    #[doc = " audio gaps in the output. Generally this is intended to signal the end of"]
    #[doc = " input, so the complete output becomes available."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.7."]
    #[doc = ""]
    #[doc = " \\sa SDL_NewAudioStream"]
    #[doc = " \\sa SDL_AudioStreamPut"]
    #[doc = " \\sa SDL_AudioStreamGet"]
    #[doc = " \\sa SDL_AudioStreamAvailable"]
    #[doc = " \\sa SDL_AudioStreamClear"]
    #[doc = " \\sa SDL_FreeAudioStream"]
    pub fn SDL_AudioStreamFlush(stream: *mut SDL_AudioStream) -> libc::c_int;
}
extern "C" {
    #[doc = " Clear any pending data in the stream without converting it"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.7."]
    #[doc = ""]
    #[doc = " \\sa SDL_NewAudioStream"]
    #[doc = " \\sa SDL_AudioStreamPut"]
    #[doc = " \\sa SDL_AudioStreamGet"]
    #[doc = " \\sa SDL_AudioStreamAvailable"]
    #[doc = " \\sa SDL_AudioStreamFlush"]
    #[doc = " \\sa SDL_FreeAudioStream"]
    pub fn SDL_AudioStreamClear(stream: *mut SDL_AudioStream);
}
extern "C" {
    #[doc = " Free an audio stream"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.7."]
    #[doc = ""]
    #[doc = " \\sa SDL_NewAudioStream"]
    #[doc = " \\sa SDL_AudioStreamPut"]
    #[doc = " \\sa SDL_AudioStreamGet"]
    #[doc = " \\sa SDL_AudioStreamAvailable"]
    #[doc = " \\sa SDL_AudioStreamFlush"]
    #[doc = " \\sa SDL_AudioStreamClear"]
    pub fn SDL_FreeAudioStream(stream: *mut SDL_AudioStream);
}
extern "C" {
    #[doc = " This function is a legacy means of mixing audio."]
    #[doc = ""]
    #[doc = " This function is equivalent to calling..."]
    #[doc = ""]
    #[doc = " ```c"]
    #[doc = " SDL_MixAudioFormat(dst, src, format, len, volume);"]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " ...where `format` is the obtained format of the audio device from the"]
    #[doc = " legacy SDL_OpenAudio() function."]
    #[doc = ""]
    #[doc = " \\param dst the destination for the mixed audio"]
    #[doc = " \\param src the source audio buffer to be mixed"]
    #[doc = " \\param len the length of the audio buffer in bytes"]
    #[doc = " \\param volume ranges from 0 - 128, and should be set to SDL_MIX_MAXVOLUME"]
    #[doc = "               for full audio volume"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_MixAudioFormat"]
    pub fn SDL_MixAudio(dst: *mut Uint8, src: *const Uint8, len: Uint32, volume: libc::c_int);
}
extern "C" {
    #[doc = " Mix audio data in a specified format."]
    #[doc = ""]
    #[doc = " This takes an audio buffer `src` of `len` bytes of `format` data and mixes"]
    #[doc = " it into `dst`, performing addition, volume adjustment, and overflow"]
    #[doc = " clipping. The buffer pointed to by `dst` must also be `len` bytes of"]
    #[doc = " `format` data."]
    #[doc = ""]
    #[doc = " This is provided for convenience -- you can mix your own audio data."]
    #[doc = ""]
    #[doc = " Do not use this function for mixing together more than two streams of"]
    #[doc = " sample data. The output from repeated application of this function may be"]
    #[doc = " distorted by clipping, because there is no accumulator with greater range"]
    #[doc = " than the input (not to mention this being an inefficient way of doing it)."]
    #[doc = ""]
    #[doc = " It is a common misconception that this function is required to write audio"]
    #[doc = " data to an output stream in an audio callback. While you can do that,"]
    #[doc = " SDL_MixAudioFormat() is really only needed when you're mixing a single"]
    #[doc = " audio stream with a volume adjustment."]
    #[doc = ""]
    #[doc = " \\param dst the destination for the mixed audio"]
    #[doc = " \\param src the source audio buffer to be mixed"]
    #[doc = " \\param format the SDL_AudioFormat structure representing the desired audio"]
    #[doc = "               format"]
    #[doc = " \\param len the length of the audio buffer in bytes"]
    #[doc = " \\param volume ranges from 0 - 128, and should be set to SDL_MIX_MAXVOLUME"]
    #[doc = "               for full audio volume"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_MixAudioFormat(
        dst: *mut Uint8,
        src: *const Uint8,
        format: SDL_AudioFormat,
        len: Uint32,
        volume: libc::c_int,
    );
}
extern "C" {
    #[doc = " Queue more audio on non-callback devices."]
    #[doc = ""]
    #[doc = " If you are looking to retrieve queued audio from a non-callback capture"]
    #[doc = " device, you want SDL_DequeueAudio() instead. SDL_QueueAudio() will return"]
    #[doc = " -1 to signify an error if you use it with capture devices."]
    #[doc = ""]
    #[doc = " SDL offers two ways to feed audio to the device: you can either supply a"]
    #[doc = " callback that SDL triggers with some frequency to obtain more audio (pull"]
    #[doc = " method), or you can supply no callback, and then SDL will expect you to"]
    #[doc = " supply data at regular intervals (push method) with this function."]
    #[doc = ""]
    #[doc = " There are no limits on the amount of data you can queue, short of"]
    #[doc = " exhaustion of address space. Queued data will drain to the device as"]
    #[doc = " necessary without further intervention from you. If the device needs audio"]
    #[doc = " but there is not enough queued, it will play silence to make up the"]
    #[doc = " difference. This means you will have skips in your audio playback if you"]
    #[doc = " aren't routinely queueing sufficient data."]
    #[doc = ""]
    #[doc = " This function copies the supplied data, so you are safe to free it when the"]
    #[doc = " function returns. This function is thread-safe, but queueing to the same"]
    #[doc = " device from two threads at once does not promise which buffer will be"]
    #[doc = " queued first."]
    #[doc = ""]
    #[doc = " You may not queue audio on a device that is using an application-supplied"]
    #[doc = " callback; doing so returns an error. You have to use the audio callback or"]
    #[doc = " queue audio with this function, but not both."]
    #[doc = ""]
    #[doc = " You should not call SDL_LockAudio() on the device before queueing; SDL"]
    #[doc = " handles locking internally for this function."]
    #[doc = ""]
    #[doc = " Note that SDL2 does not support planar audio. You will need to resample"]
    #[doc = " from planar audio formats into a non-planar one (see SDL_AudioFormat)"]
    #[doc = " before queuing audio."]
    #[doc = ""]
    #[doc = " \\param dev the device ID to which we will queue audio"]
    #[doc = " \\param data the data to queue to the device for later playback"]
    #[doc = " \\param len the number of bytes (not samples!) to which `data` points"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.4."]
    #[doc = ""]
    #[doc = " \\sa SDL_ClearQueuedAudio"]
    #[doc = " \\sa SDL_GetQueuedAudioSize"]
    pub fn SDL_QueueAudio(
        dev: SDL_AudioDeviceID,
        data: *const libc::c_void,
        len: Uint32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Dequeue more audio on non-callback devices."]
    #[doc = ""]
    #[doc = " If you are looking to queue audio for output on a non-callback playback"]
    #[doc = " device, you want SDL_QueueAudio() instead. SDL_DequeueAudio() will always"]
    #[doc = " return 0 if you use it with playback devices."]
    #[doc = ""]
    #[doc = " SDL offers two ways to retrieve audio from a capture device: you can either"]
    #[doc = " supply a callback that SDL triggers with some frequency as the device"]
    #[doc = " records more audio data, (push method), or you can supply no callback, and"]
    #[doc = " then SDL will expect you to retrieve data at regular intervals (pull"]
    #[doc = " method) with this function."]
    #[doc = ""]
    #[doc = " There are no limits on the amount of data you can queue, short of"]
    #[doc = " exhaustion of address space. Data from the device will keep queuing as"]
    #[doc = " necessary without further intervention from you. This means you will"]
    #[doc = " eventually run out of memory if you aren't routinely dequeueing data."]
    #[doc = ""]
    #[doc = " Capture devices will not queue data when paused; if you are expecting to"]
    #[doc = " not need captured audio for some length of time, use SDL_PauseAudioDevice()"]
    #[doc = " to stop the capture device from queueing more data. This can be useful"]
    #[doc = " during, say, level loading times. When unpaused, capture devices will start"]
    #[doc = " queueing data from that point, having flushed any capturable data available"]
    #[doc = " while paused."]
    #[doc = ""]
    #[doc = " This function is thread-safe, but dequeueing from the same device from two"]
    #[doc = " threads at once does not promise which thread will dequeue data first."]
    #[doc = ""]
    #[doc = " You may not dequeue audio from a device that is using an"]
    #[doc = " application-supplied callback; doing so returns an error. You have to use"]
    #[doc = " the audio callback, or dequeue audio with this function, but not both."]
    #[doc = ""]
    #[doc = " You should not call SDL_LockAudio() on the device before dequeueing; SDL"]
    #[doc = " handles locking internally for this function."]
    #[doc = ""]
    #[doc = " \\param dev the device ID from which we will dequeue audio"]
    #[doc = " \\param data a pointer into where audio data should be copied"]
    #[doc = " \\param len the number of bytes (not samples!) to which (data) points"]
    #[doc = " \\returns the number of bytes dequeued, which could be less than requested;"]
    #[doc = "          call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.5."]
    #[doc = ""]
    #[doc = " \\sa SDL_ClearQueuedAudio"]
    #[doc = " \\sa SDL_GetQueuedAudioSize"]
    pub fn SDL_DequeueAudio(dev: SDL_AudioDeviceID, data: *mut libc::c_void, len: Uint32)
        -> Uint32;
}
extern "C" {
    #[doc = " Get the number of bytes of still-queued audio."]
    #[doc = ""]
    #[doc = " For playback devices: this is the number of bytes that have been queued for"]
    #[doc = " playback with SDL_QueueAudio(), but have not yet been sent to the hardware."]
    #[doc = ""]
    #[doc = " Once we've sent it to the hardware, this function can not decide the exact"]
    #[doc = " byte boundary of what has been played. It's possible that we just gave the"]
    #[doc = " hardware several kilobytes right before you called this function, but it"]
    #[doc = " hasn't played any of it yet, or maybe half of it, etc."]
    #[doc = ""]
    #[doc = " For capture devices, this is the number of bytes that have been captured by"]
    #[doc = " the device and are waiting for you to dequeue. This number may grow at any"]
    #[doc = " time, so this only informs of the lower-bound of available data."]
    #[doc = ""]
    #[doc = " You may not queue or dequeue audio on a device that is using an"]
    #[doc = " application-supplied callback; calling this function on such a device"]
    #[doc = " always returns 0. You have to use the audio callback or queue audio, but"]
    #[doc = " not both."]
    #[doc = ""]
    #[doc = " You should not call SDL_LockAudio() on the device before querying; SDL"]
    #[doc = " handles locking internally for this function."]
    #[doc = ""]
    #[doc = " \\param dev the device ID of which we will query queued audio size"]
    #[doc = " \\returns the number of bytes (not samples!) of queued audio."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.4."]
    #[doc = ""]
    #[doc = " \\sa SDL_ClearQueuedAudio"]
    #[doc = " \\sa SDL_QueueAudio"]
    #[doc = " \\sa SDL_DequeueAudio"]
    pub fn SDL_GetQueuedAudioSize(dev: SDL_AudioDeviceID) -> Uint32;
}
extern "C" {
    #[doc = " Drop any queued audio data waiting to be sent to the hardware."]
    #[doc = ""]
    #[doc = " Immediately after this call, SDL_GetQueuedAudioSize() will return 0. For"]
    #[doc = " output devices, the hardware will start playing silence if more audio isn't"]
    #[doc = " queued. For capture devices, the hardware will start filling the empty"]
    #[doc = " queue with new data if the capture device isn't paused."]
    #[doc = ""]
    #[doc = " This will not prevent playback of queued audio that's already been sent to"]
    #[doc = " the hardware, as we can not undo that, so expect there to be some fraction"]
    #[doc = " of a second of audio that might still be heard. This can be useful if you"]
    #[doc = " want to, say, drop any pending music or any unprocessed microphone input"]
    #[doc = " during a level change in your game."]
    #[doc = ""]
    #[doc = " You may not queue or dequeue audio on a device that is using an"]
    #[doc = " application-supplied callback; calling this function on such a device"]
    #[doc = " always returns 0. You have to use the audio callback or queue audio, but"]
    #[doc = " not both."]
    #[doc = ""]
    #[doc = " You should not call SDL_LockAudio() on the device before clearing the"]
    #[doc = " queue; SDL handles locking internally for this function."]
    #[doc = ""]
    #[doc = " This function always succeeds and thus returns void."]
    #[doc = ""]
    #[doc = " \\param dev the device ID of which to clear the audio queue"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.4."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetQueuedAudioSize"]
    #[doc = " \\sa SDL_QueueAudio"]
    #[doc = " \\sa SDL_DequeueAudio"]
    pub fn SDL_ClearQueuedAudio(dev: SDL_AudioDeviceID);
}
extern "C" {
    #[doc = " This function is a legacy means of locking the audio device."]
    #[doc = ""]
    #[doc = " New programs might want to use SDL_LockAudioDevice() instead. This function"]
    #[doc = " is equivalent to calling..."]
    #[doc = ""]
    #[doc = " ```c"]
    #[doc = " SDL_LockAudioDevice(1);"]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " ...and is only useful if you used the legacy SDL_OpenAudio() function."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_LockAudioDevice"]
    #[doc = " \\sa SDL_UnlockAudio"]
    #[doc = " \\sa SDL_UnlockAudioDevice"]
    pub fn SDL_LockAudio();
}
extern "C" {
    #[doc = " Use this function to lock out the audio callback function for a specified"]
    #[doc = " device."]
    #[doc = ""]
    #[doc = " The lock manipulated by these functions protects the audio callback"]
    #[doc = " function specified in SDL_OpenAudioDevice(). During a"]
    #[doc = " SDL_LockAudioDevice()/SDL_UnlockAudioDevice() pair, you can be guaranteed"]
    #[doc = " that the callback function for that device is not running, even if the"]
    #[doc = " device is not paused. While a device is locked, any other unpaused,"]
    #[doc = " unlocked devices may still run their callbacks."]
    #[doc = ""]
    #[doc = " Calling this function from inside your audio callback is unnecessary. SDL"]
    #[doc = " obtains this lock before calling your function, and releases it when the"]
    #[doc = " function returns."]
    #[doc = ""]
    #[doc = " You should not hold the lock longer than absolutely necessary. If you hold"]
    #[doc = " it too long, you'll experience dropouts in your audio playback. Ideally,"]
    #[doc = " your application locks the device, sets a few variables and unlocks again."]
    #[doc = " Do not do heavy work while holding the lock for a device."]
    #[doc = ""]
    #[doc = " It is safe to lock the audio device multiple times, as long as you unlock"]
    #[doc = " it an equivalent number of times. The callback will not run until the"]
    #[doc = " device has been unlocked completely in this way. If your application fails"]
    #[doc = " to unlock the device appropriately, your callback will never run, you might"]
    #[doc = " hear repeating bursts of audio, and SDL_CloseAudioDevice() will probably"]
    #[doc = " deadlock."]
    #[doc = ""]
    #[doc = " Internally, the audio device lock is a mutex; if you lock from two threads"]
    #[doc = " at once, not only will you block the audio callback, you'll block the other"]
    #[doc = " thread."]
    #[doc = ""]
    #[doc = " \\param dev the ID of the device to be locked"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_UnlockAudioDevice"]
    pub fn SDL_LockAudioDevice(dev: SDL_AudioDeviceID);
}
extern "C" {
    #[doc = " This function is a legacy means of unlocking the audio device."]
    #[doc = ""]
    #[doc = " New programs might want to use SDL_UnlockAudioDevice() instead. This"]
    #[doc = " function is equivalent to calling..."]
    #[doc = ""]
    #[doc = " ```c"]
    #[doc = " SDL_UnlockAudioDevice(1);"]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " ...and is only useful if you used the legacy SDL_OpenAudio() function."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_LockAudio"]
    #[doc = " \\sa SDL_UnlockAudioDevice"]
    pub fn SDL_UnlockAudio();
}
extern "C" {
    #[doc = " Use this function to unlock the audio callback function for a specified"]
    #[doc = " device."]
    #[doc = ""]
    #[doc = " This function should be paired with a previous SDL_LockAudioDevice() call."]
    #[doc = ""]
    #[doc = " \\param dev the ID of the device to be unlocked"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_LockAudioDevice"]
    pub fn SDL_UnlockAudioDevice(dev: SDL_AudioDeviceID);
}
extern "C" {
    #[doc = " This function is a legacy means of closing the audio device."]
    #[doc = ""]
    #[doc = " This function is equivalent to calling..."]
    #[doc = ""]
    #[doc = " ```c"]
    #[doc = " SDL_CloseAudioDevice(1);"]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " ...and is only useful if you used the legacy SDL_OpenAudio() function."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_OpenAudio"]
    pub fn SDL_CloseAudio();
}
extern "C" {
    #[doc = " Use this function to shut down audio processing and close the audio device."]
    #[doc = ""]
    #[doc = " The application should close open audio devices once they are no longer"]
    #[doc = " needed. Calling this function will wait until the device's audio callback"]
    #[doc = " is not running, release the audio hardware and then clean up internal"]
    #[doc = " state. No further audio will play from this device once this function"]
    #[doc = " returns."]
    #[doc = ""]
    #[doc = " This function may block briefly while pending audio data is played by the"]
    #[doc = " hardware, so that applications don't drop the last buffer of data they"]
    #[doc = " supplied."]
    #[doc = ""]
    #[doc = " The device ID is invalid as soon as the device is closed, and is eligible"]
    #[doc = " for reuse in a new SDL_OpenAudioDevice() call immediately."]
    #[doc = ""]
    #[doc = " \\param dev an audio device previously opened with SDL_OpenAudioDevice()"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_OpenAudioDevice"]
    pub fn SDL_CloseAudioDevice(dev: SDL_AudioDeviceID);
}
extern "C" {
    #[doc = " Put UTF-8 text into the clipboard."]
    #[doc = ""]
    #[doc = " \\param text the text to store in the clipboard"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetClipboardText"]
    #[doc = " \\sa SDL_HasClipboardText"]
    pub fn SDL_SetClipboardText(text: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Get UTF-8 text from the clipboard, which must be freed with SDL_free()."]
    #[doc = ""]
    #[doc = " This functions returns empty string if there was not enough memory left for"]
    #[doc = " a copy of the clipboard's content."]
    #[doc = ""]
    #[doc = " \\returns the clipboard text on success or an empty string on failure; call"]
    #[doc = "          SDL_GetError() for more information. Caller must call SDL_free()"]
    #[doc = "          on the returned pointer when done with it (even if there was an"]
    #[doc = "          error)."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HasClipboardText"]
    #[doc = " \\sa SDL_SetClipboardText"]
    pub fn SDL_GetClipboardText() -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Query whether the clipboard exists and contains a non-empty text string."]
    #[doc = ""]
    #[doc = " \\returns SDL_TRUE if the clipboard has text, or SDL_FALSE if it does not."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetClipboardText"]
    #[doc = " \\sa SDL_SetClipboardText"]
    pub fn SDL_HasClipboardText() -> SDL_bool;
}
pub type __m64 = [libc::c_longlong; 1usize];
pub type __v1di = [libc::c_longlong; 1usize];
pub type __v2si = [libc::c_int; 2usize];
pub type __v4hi = [libc::c_short; 4usize];
pub type __v8qi = [libc::c_char; 8usize];
pub type __v4si = [libc::c_int; 4usize];
pub type __v4sf = [f32; 4usize];
pub type __m128 = [f32; 4usize];
pub type __m128_u = [f32; 4usize];
pub type __v4su = [libc::c_uint; 4usize];
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct div_t {
    pub quot: libc::c_int,
    pub rem: libc::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::core::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::core::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ldiv_t {
    pub quot: libc::c_long,
    pub rem: libc::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::core::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lldiv_t {
    pub quot: libc::c_longlong,
    pub rem: libc::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::core::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    pub fn atof(__nptr: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const libc::c_char) -> libc::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const libc::c_char) -> libc::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const libc::c_char, __endptr: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const libc::c_char, __endptr: *mut *mut libc::c_char) -> f32;
}
extern "C" {
    pub fn strtold(__nptr: *const libc::c_char, __endptr: *mut *mut libc::c_char) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: libc::c_long) -> *mut libc::c_char;
}
extern "C" {
    pub fn a64l(__s: *const libc::c_char) -> libc::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = libc::c_ulong;
pub type ushort = libc::c_ushort;
pub type uint = libc::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = libc::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigset_t {
    pub __val: [libc::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::core::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::core::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::core::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::core::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::core::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = libc::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::core::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::core::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> libc::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: libc::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: libc::c_uint,
    pub __high: libc::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__atomic_wide_counter__bindgen_ty_1>())).__low as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__atomic_wide_counter__bindgen_ty_1>())).__high as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    assert_eq!(
        ::core::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::core::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__atomic_wide_counter>())).__value64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__atomic_wide_counter>())).__value32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: libc::c_int,
    pub __count: libc::c_uint,
    pub __owner: libc::c_int,
    pub __nusers: libc::c_uint,
    pub __kind: libc::c_int,
    pub __spins: libc::c_short,
    pub __elision: libc::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: libc::c_uint,
    pub __writers: libc::c_uint,
    pub __wrphase_futex: libc::c_uint,
    pub __writers_futex: libc::c_uint,
    pub __pad3: libc::c_uint,
    pub __pad4: libc::c_uint,
    pub __cur_writer: libc::c_int,
    pub __shared: libc::c_int,
    pub __rwelision: libc::c_schar,
    pub __pad1: [libc::c_uchar; 7usize],
    pub __pad2: libc::c_ulong,
    pub __flags: libc::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [libc::c_uint; 2usize],
    pub __g_size: [libc::c_uint; 2usize],
    pub __g1_orig_size: libc::c_uint,
    pub __wrefs: libc::c_uint,
    pub __g_signals: [libc::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_cond_s>())).__wseq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_cond_s>())).__g1_start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = libc::c_uint;
pub type __thrd_t = libc::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __once_flag {
    pub __data: libc::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    assert_eq!(
        ::core::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::core::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__once_flag>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = libc::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [libc::c_char; 4usize],
    pub __align: libc::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [libc::c_char; 4usize],
    pub __align: libc::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = libc::c_uint;
pub type pthread_once_t = libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [libc::c_char; 56usize],
    pub __align: libc::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [libc::c_char; 40usize],
    pub __align: libc::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [libc::c_char; 48usize],
    pub __align: libc::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [libc::c_char; 56usize],
    pub __align: libc::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [libc::c_char; 8usize],
    pub __align: libc::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [libc::c_char; 32usize],
    pub __align: libc::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [libc::c_char; 4usize],
    pub __align: libc::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> libc::c_long;
}
extern "C" {
    pub fn srandom(__seed: libc::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: libc::c_uint,
        __statebuf: *mut libc::c_char,
        __statelen: size_t,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut libc::c_char) -> *mut libc::c_char;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: libc::c_int,
    pub rand_deg: libc::c_int,
    pub rand_sep: libc::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::core::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::core::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<random_data>())).fptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<random_data>())).rptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<random_data>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<random_data>())).rand_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<random_data>())).rand_deg as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<random_data>())).rand_sep as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<random_data>())).end_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> libc::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: libc::c_uint, __buf: *mut random_data) -> libc::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: libc::c_uint,
        __statebuf: *mut libc::c_char,
        __statelen: size_t,
        __buf: *mut random_data,
    ) -> libc::c_int;
}
extern "C" {
    pub fn setstate_r(__statebuf: *mut libc::c_char, __buf: *mut random_data) -> libc::c_int;
}
extern "C" {
    pub fn rand() -> libc::c_int;
}
extern "C" {
    pub fn srand(__seed: libc::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut libc::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> libc::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut libc::c_ushort) -> libc::c_long;
}
extern "C" {
    pub fn mrand48() -> libc::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut libc::c_ushort) -> libc::c_long;
}
extern "C" {
    pub fn srand48(__seedval: libc::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut libc::c_ushort) -> *mut libc::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut libc::c_ushort);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drand48_data {
    pub __x: [libc::c_ushort; 3usize],
    pub __old_x: [libc::c_ushort; 3usize],
    pub __c: libc::c_ushort,
    pub __init: libc::c_ushort,
    pub __a: libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::core::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::core::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<drand48_data>())).__x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<drand48_data>())).__c as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<drand48_data>())).__init as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<drand48_data>())).__a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> libc::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut libc::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn lrand48_r(__buffer: *mut drand48_data, __result: *mut libc::c_long) -> libc::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut libc::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut libc::c_long,
    ) -> libc::c_int;
}
extern "C" {
    pub fn mrand48_r(__buffer: *mut drand48_data, __result: *mut libc::c_long) -> libc::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut libc::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut libc::c_long,
    ) -> libc::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: libc::c_long, __buffer: *mut drand48_data) -> libc::c_int;
}
extern "C" {
    pub fn seed48_r(__seed16v: *mut libc::c_ushort, __buffer: *mut drand48_data) -> libc::c_int;
}
extern "C" {
    pub fn lcong48_r(__param: *mut libc::c_ushort, __buffer: *mut drand48_data) -> libc::c_int;
}
extern "C" {
    pub fn malloc(__size: libc::c_ulong) -> *mut libc::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: libc::c_ulong, __size: libc::c_ulong) -> *mut libc::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut libc::c_void, __size: libc::c_ulong) -> *mut libc::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut libc::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut libc::c_void,
        __nmemb: size_t,
        __size: size_t,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn alloca(__size: libc::c_ulong) -> *mut libc::c_void;
}
extern "C" {
    pub fn valloc(__size: size_t) -> *mut libc::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut libc::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: libc::c_ulong, __size: libc::c_ulong) -> *mut libc::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> libc::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> libc::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(__status: libc::c_int, __arg: *mut libc::c_void),
        >,
        __arg: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn exit(__status: libc::c_int);
}
extern "C" {
    pub fn quick_exit(__status: libc::c_int);
}
extern "C" {
    pub fn _Exit(__status: libc::c_int);
}
extern "C" {
    pub fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const libc::c_char,
        __value: *const libc::c_char,
        __replace: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn clearenv() -> libc::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn mkstemps(__template: *mut libc::c_char, __suffixlen: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn system(__command: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const libc::c_char,
        __resolved: *mut libc::c_char,
    ) -> *mut libc::c_char;
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *const libc::c_void, arg2: *const libc::c_void) -> libc::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const libc::c_void,
        __base: *const libc::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut libc::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn labs(__x: libc::c_long) -> libc::c_long;
}
extern "C" {
    pub fn llabs(__x: libc::c_longlong) -> libc::c_longlong;
}
extern "C" {
    pub fn div(__numer: libc::c_int, __denom: libc::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: libc::c_long, __denom: libc::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: libc::c_longlong, __denom: libc::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn gcvt(__value: f64, __ndigit: libc::c_int, __buf: *mut libc::c_char)
        -> *mut libc::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: libc::c_int,
        __buf: *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
        __buf: *mut libc::c_char,
        __len: size_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
        __buf: *mut libc::c_char,
        __len: size_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
        __buf: *mut libc::c_char,
        __len: size_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: libc::c_int,
        __decpt: *mut libc::c_int,
        __sign: *mut libc::c_int,
        __buf: *mut libc::c_char,
        __len: size_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn mblen(__s: *const libc::c_char, __n: size_t) -> libc::c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const libc::c_char, __n: size_t) -> libc::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut libc::c_char, __wchar: wchar_t) -> libc::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const libc::c_char, __n: size_t) -> size_t;
}
extern "C" {
    pub fn wcstombs(__s: *mut libc::c_char, __pwcs: *const wchar_t, __n: size_t) -> size_t;
}
extern "C" {
    pub fn rpmatch(__response: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut libc::c_char,
        __tokens: *const *mut libc::c_char,
        __valuep: *mut *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn _mm_sfence();
}
extern "C" {
    pub fn _mm_getcsr() -> libc::c_uint;
}
extern "C" {
    pub fn _mm_setcsr(__i: libc::c_uint);
}
pub type __m128d = [f64; 2usize];
pub type __m128i = [libc::c_longlong; 2usize];
pub type __m128d_u = [f64; 2usize];
pub type __m128i_u = [libc::c_longlong; 2usize];
pub type __v2df = [f64; 2usize];
pub type __v2di = [libc::c_longlong; 2usize];
pub type __v8hi = [libc::c_short; 8usize];
pub type __v16qi = [libc::c_char; 16usize];
pub type __v2du = [libc::c_ulonglong; 2usize];
pub type __v8hu = [libc::c_ushort; 8usize];
pub type __v16qu = [libc::c_uchar; 16usize];
pub type __v16qs = [libc::c_schar; 16usize];
extern "C" {
    pub fn _mm_clflush(__p: *const libc::c_void);
}
extern "C" {
    pub fn _mm_lfence();
}
extern "C" {
    pub fn _mm_mfence();
}
extern "C" {
    pub fn _mm_pause();
}
extern "C" {
    #[doc = " Get the number of CPU cores available."]
    #[doc = ""]
    #[doc = " \\returns the total number of logical CPU cores. On CPUs that include"]
    #[doc = "          technologies such as hyperthreading, the number of logical cores"]
    #[doc = "          may be more than the number of physical cores."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_GetCPUCount() -> libc::c_int;
}
extern "C" {
    #[doc = " Determine the L1 cache line size of the CPU."]
    #[doc = ""]
    #[doc = " This is useful for determining multi-threaded structure padding or SIMD"]
    #[doc = " prefetch sizes."]
    #[doc = ""]
    #[doc = " \\returns the L1 cache line size of the CPU, in bytes."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_GetCPUCacheLineSize() -> libc::c_int;
}
extern "C" {
    #[doc = " Determine whether the CPU has the RDTSC instruction."]
    #[doc = ""]
    #[doc = " This always returns false on CPUs that aren't using Intel instruction sets."]
    #[doc = ""]
    #[doc = " \\returns SDL_TRUE if the CPU has the RDTSC instruction or SDL_FALSE if not."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_Has3DNow"]
    #[doc = " \\sa SDL_HasAltiVec"]
    #[doc = " \\sa SDL_HasAVX"]
    #[doc = " \\sa SDL_HasAVX2"]
    #[doc = " \\sa SDL_HasMMX"]
    #[doc = " \\sa SDL_HasSSE"]
    #[doc = " \\sa SDL_HasSSE2"]
    #[doc = " \\sa SDL_HasSSE3"]
    #[doc = " \\sa SDL_HasSSE41"]
    #[doc = " \\sa SDL_HasSSE42"]
    pub fn SDL_HasRDTSC() -> SDL_bool;
}
extern "C" {
    #[doc = " Determine whether the CPU has AltiVec features."]
    #[doc = ""]
    #[doc = " This always returns false on CPUs that aren't using PowerPC instruction"]
    #[doc = " sets."]
    #[doc = ""]
    #[doc = " \\returns SDL_TRUE if the CPU has AltiVec features or SDL_FALSE if not."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_Has3DNow"]
    #[doc = " \\sa SDL_HasAVX"]
    #[doc = " \\sa SDL_HasAVX2"]
    #[doc = " \\sa SDL_HasMMX"]
    #[doc = " \\sa SDL_HasRDTSC"]
    #[doc = " \\sa SDL_HasSSE"]
    #[doc = " \\sa SDL_HasSSE2"]
    #[doc = " \\sa SDL_HasSSE3"]
    #[doc = " \\sa SDL_HasSSE41"]
    #[doc = " \\sa SDL_HasSSE42"]
    pub fn SDL_HasAltiVec() -> SDL_bool;
}
extern "C" {
    #[doc = " Determine whether the CPU has MMX features."]
    #[doc = ""]
    #[doc = " This always returns false on CPUs that aren't using Intel instruction sets."]
    #[doc = ""]
    #[doc = " \\returns SDL_TRUE if the CPU has MMX features or SDL_FALSE if not."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_Has3DNow"]
    #[doc = " \\sa SDL_HasAltiVec"]
    #[doc = " \\sa SDL_HasAVX"]
    #[doc = " \\sa SDL_HasAVX2"]
    #[doc = " \\sa SDL_HasRDTSC"]
    #[doc = " \\sa SDL_HasSSE"]
    #[doc = " \\sa SDL_HasSSE2"]
    #[doc = " \\sa SDL_HasSSE3"]
    #[doc = " \\sa SDL_HasSSE41"]
    #[doc = " \\sa SDL_HasSSE42"]
    pub fn SDL_HasMMX() -> SDL_bool;
}
extern "C" {
    #[doc = " Determine whether the CPU has 3DNow! features."]
    #[doc = ""]
    #[doc = " This always returns false on CPUs that aren't using AMD instruction sets."]
    #[doc = ""]
    #[doc = " \\returns SDL_TRUE if the CPU has 3DNow! features or SDL_FALSE if not."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HasAltiVec"]
    #[doc = " \\sa SDL_HasAVX"]
    #[doc = " \\sa SDL_HasAVX2"]
    #[doc = " \\sa SDL_HasMMX"]
    #[doc = " \\sa SDL_HasRDTSC"]
    #[doc = " \\sa SDL_HasSSE"]
    #[doc = " \\sa SDL_HasSSE2"]
    #[doc = " \\sa SDL_HasSSE3"]
    #[doc = " \\sa SDL_HasSSE41"]
    #[doc = " \\sa SDL_HasSSE42"]
    pub fn SDL_Has3DNow() -> SDL_bool;
}
extern "C" {
    #[doc = " Determine whether the CPU has SSE features."]
    #[doc = ""]
    #[doc = " This always returns false on CPUs that aren't using Intel instruction sets."]
    #[doc = ""]
    #[doc = " \\returns SDL_TRUE if the CPU has SSE features or SDL_FALSE if not."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_Has3DNow"]
    #[doc = " \\sa SDL_HasAltiVec"]
    #[doc = " \\sa SDL_HasAVX"]
    #[doc = " \\sa SDL_HasAVX2"]
    #[doc = " \\sa SDL_HasMMX"]
    #[doc = " \\sa SDL_HasRDTSC"]
    #[doc = " \\sa SDL_HasSSE2"]
    #[doc = " \\sa SDL_HasSSE3"]
    #[doc = " \\sa SDL_HasSSE41"]
    #[doc = " \\sa SDL_HasSSE42"]
    pub fn SDL_HasSSE() -> SDL_bool;
}
extern "C" {
    #[doc = " Determine whether the CPU has SSE2 features."]
    #[doc = ""]
    #[doc = " This always returns false on CPUs that aren't using Intel instruction sets."]
    #[doc = ""]
    #[doc = " \\returns SDL_TRUE if the CPU has SSE2 features or SDL_FALSE if not."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_Has3DNow"]
    #[doc = " \\sa SDL_HasAltiVec"]
    #[doc = " \\sa SDL_HasAVX"]
    #[doc = " \\sa SDL_HasAVX2"]
    #[doc = " \\sa SDL_HasMMX"]
    #[doc = " \\sa SDL_HasRDTSC"]
    #[doc = " \\sa SDL_HasSSE"]
    #[doc = " \\sa SDL_HasSSE3"]
    #[doc = " \\sa SDL_HasSSE41"]
    #[doc = " \\sa SDL_HasSSE42"]
    pub fn SDL_HasSSE2() -> SDL_bool;
}
extern "C" {
    #[doc = " Determine whether the CPU has SSE3 features."]
    #[doc = ""]
    #[doc = " This always returns false on CPUs that aren't using Intel instruction sets."]
    #[doc = ""]
    #[doc = " \\returns SDL_TRUE if the CPU has SSE3 features or SDL_FALSE if not."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_Has3DNow"]
    #[doc = " \\sa SDL_HasAltiVec"]
    #[doc = " \\sa SDL_HasAVX"]
    #[doc = " \\sa SDL_HasAVX2"]
    #[doc = " \\sa SDL_HasMMX"]
    #[doc = " \\sa SDL_HasRDTSC"]
    #[doc = " \\sa SDL_HasSSE"]
    #[doc = " \\sa SDL_HasSSE2"]
    #[doc = " \\sa SDL_HasSSE41"]
    #[doc = " \\sa SDL_HasSSE42"]
    pub fn SDL_HasSSE3() -> SDL_bool;
}
extern "C" {
    #[doc = " Determine whether the CPU has SSE4.1 features."]
    #[doc = ""]
    #[doc = " This always returns false on CPUs that aren't using Intel instruction sets."]
    #[doc = ""]
    #[doc = " \\returns SDL_TRUE if the CPU has SSE4.1 features or SDL_FALSE if not."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_Has3DNow"]
    #[doc = " \\sa SDL_HasAltiVec"]
    #[doc = " \\sa SDL_HasAVX"]
    #[doc = " \\sa SDL_HasAVX2"]
    #[doc = " \\sa SDL_HasMMX"]
    #[doc = " \\sa SDL_HasRDTSC"]
    #[doc = " \\sa SDL_HasSSE"]
    #[doc = " \\sa SDL_HasSSE2"]
    #[doc = " \\sa SDL_HasSSE3"]
    #[doc = " \\sa SDL_HasSSE42"]
    pub fn SDL_HasSSE41() -> SDL_bool;
}
extern "C" {
    #[doc = " Determine whether the CPU has SSE4.2 features."]
    #[doc = ""]
    #[doc = " This always returns false on CPUs that aren't using Intel instruction sets."]
    #[doc = ""]
    #[doc = " \\returns SDL_TRUE if the CPU has SSE4.2 features or SDL_FALSE if not."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_Has3DNow"]
    #[doc = " \\sa SDL_HasAltiVec"]
    #[doc = " \\sa SDL_HasAVX"]
    #[doc = " \\sa SDL_HasAVX2"]
    #[doc = " \\sa SDL_HasMMX"]
    #[doc = " \\sa SDL_HasRDTSC"]
    #[doc = " \\sa SDL_HasSSE"]
    #[doc = " \\sa SDL_HasSSE2"]
    #[doc = " \\sa SDL_HasSSE3"]
    #[doc = " \\sa SDL_HasSSE41"]
    pub fn SDL_HasSSE42() -> SDL_bool;
}
extern "C" {
    #[doc = " Determine whether the CPU has AVX features."]
    #[doc = ""]
    #[doc = " This always returns false on CPUs that aren't using Intel instruction sets."]
    #[doc = ""]
    #[doc = " \\returns SDL_TRUE if the CPU has AVX features or SDL_FALSE if not."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.2."]
    #[doc = ""]
    #[doc = " \\sa SDL_Has3DNow"]
    #[doc = " \\sa SDL_HasAltiVec"]
    #[doc = " \\sa SDL_HasAVX2"]
    #[doc = " \\sa SDL_HasMMX"]
    #[doc = " \\sa SDL_HasRDTSC"]
    #[doc = " \\sa SDL_HasSSE"]
    #[doc = " \\sa SDL_HasSSE2"]
    #[doc = " \\sa SDL_HasSSE3"]
    #[doc = " \\sa SDL_HasSSE41"]
    #[doc = " \\sa SDL_HasSSE42"]
    pub fn SDL_HasAVX() -> SDL_bool;
}
extern "C" {
    #[doc = " Determine whether the CPU has AVX2 features."]
    #[doc = ""]
    #[doc = " This always returns false on CPUs that aren't using Intel instruction sets."]
    #[doc = ""]
    #[doc = " \\returns SDL_TRUE if the CPU has AVX2 features or SDL_FALSE if not."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.4."]
    #[doc = ""]
    #[doc = " \\sa SDL_Has3DNow"]
    #[doc = " \\sa SDL_HasAltiVec"]
    #[doc = " \\sa SDL_HasAVX"]
    #[doc = " \\sa SDL_HasMMX"]
    #[doc = " \\sa SDL_HasRDTSC"]
    #[doc = " \\sa SDL_HasSSE"]
    #[doc = " \\sa SDL_HasSSE2"]
    #[doc = " \\sa SDL_HasSSE3"]
    #[doc = " \\sa SDL_HasSSE41"]
    #[doc = " \\sa SDL_HasSSE42"]
    pub fn SDL_HasAVX2() -> SDL_bool;
}
extern "C" {
    #[doc = " Determine whether the CPU has AVX-512F (foundation) features."]
    #[doc = ""]
    #[doc = " This always returns false on CPUs that aren't using Intel instruction sets."]
    #[doc = ""]
    #[doc = " \\returns SDL_TRUE if the CPU has AVX-512F features or SDL_FALSE if not."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.9."]
    #[doc = ""]
    #[doc = " \\sa SDL_HasAVX"]
    pub fn SDL_HasAVX512F() -> SDL_bool;
}
extern "C" {
    #[doc = " Determine whether the CPU has ARM SIMD (ARMv6) features."]
    #[doc = ""]
    #[doc = " This is different from ARM NEON, which is a different instruction set."]
    #[doc = ""]
    #[doc = " This always returns false on CPUs that aren't using ARM instruction sets."]
    #[doc = ""]
    #[doc = " \\returns SDL_TRUE if the CPU has ARM SIMD features or SDL_FALSE if not."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.12."]
    #[doc = ""]
    #[doc = " \\sa SDL_HasNEON"]
    pub fn SDL_HasARMSIMD() -> SDL_bool;
}
extern "C" {
    #[doc = " Determine whether the CPU has NEON (ARM SIMD) features."]
    #[doc = ""]
    #[doc = " This always returns false on CPUs that aren't using ARM instruction sets."]
    #[doc = ""]
    #[doc = " \\returns SDL_TRUE if the CPU has ARM NEON features or SDL_FALSE if not."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.6."]
    pub fn SDL_HasNEON() -> SDL_bool;
}
extern "C" {
    #[doc = " Get the amount of RAM configured in the system."]
    #[doc = ""]
    #[doc = " \\returns the amount of RAM configured in the system in MB."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.1."]
    pub fn SDL_GetSystemRAM() -> libc::c_int;
}
extern "C" {
    #[doc = " Report the alignment this system needs for SIMD allocations."]
    #[doc = ""]
    #[doc = " This will return the minimum number of bytes to which a pointer must be"]
    #[doc = " aligned to be compatible with SIMD instructions on the current machine. For"]
    #[doc = " example, if the machine supports SSE only, it will return 16, but if it"]
    #[doc = " supports AVX-512F, it'll return 64 (etc). This only reports values for"]
    #[doc = " instruction sets SDL knows about, so if your SDL build doesn't have"]
    #[doc = " SDL_HasAVX512F(), then it might return 16 for the SSE support it sees and"]
    #[doc = " not 64 for the AVX-512 instructions that exist but SDL doesn't know about."]
    #[doc = " Plan accordingly."]
    #[doc = ""]
    #[doc = " \\returns the alignment in bytes needed for available, known SIMD"]
    #[doc = "          instructions."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.10."]
    pub fn SDL_SIMDGetAlignment() -> size_t;
}
extern "C" {
    #[doc = " Allocate memory in a SIMD-friendly way."]
    #[doc = ""]
    #[doc = " This will allocate a block of memory that is suitable for use with SIMD"]
    #[doc = " instructions. Specifically, it will be properly aligned and padded for the"]
    #[doc = " system's supported vector instructions."]
    #[doc = ""]
    #[doc = " The memory returned will be padded such that it is safe to read or write an"]
    #[doc = " incomplete vector at the end of the memory block. This can be useful so you"]
    #[doc = " don't have to drop back to a scalar fallback at the end of your SIMD"]
    #[doc = " processing loop to deal with the final elements without overflowing the"]
    #[doc = " allocated buffer."]
    #[doc = ""]
    #[doc = " You must free this memory with SDL_FreeSIMD(), not free() or SDL_free() or"]
    #[doc = " delete[], etc."]
    #[doc = ""]
    #[doc = " Note that SDL will only deal with SIMD instruction sets it is aware of; for"]
    #[doc = " example, SDL 2.0.8 knows that SSE wants 16-byte vectors (SDL_HasSSE()), and"]
    #[doc = " AVX2 wants 32 bytes (SDL_HasAVX2()), but doesn't know that AVX-512 wants"]
    #[doc = " 64. To be clear: if you can't decide to use an instruction set with an"]
    #[doc = " SDL_Has*() function, don't use that instruction set with memory allocated"]
    #[doc = " through here."]
    #[doc = ""]
    #[doc = " SDL_AllocSIMD(0) will return a non-NULL pointer, assuming the system isn't"]
    #[doc = " out of memory, but you are not allowed to dereference it (because you only"]
    #[doc = " own zero bytes of that buffer)."]
    #[doc = ""]
    #[doc = " \\param len The length, in bytes, of the block to allocate. The actual"]
    #[doc = "            allocated block might be larger due to padding, etc."]
    #[doc = " \\returns a pointer to the newly-allocated block, NULL if out of memory."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.10."]
    #[doc = ""]
    #[doc = " \\sa SDL_SIMDAlignment"]
    #[doc = " \\sa SDL_SIMDRealloc"]
    #[doc = " \\sa SDL_SIMDFree"]
    pub fn SDL_SIMDAlloc(len: size_t) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Reallocate memory obtained from SDL_SIMDAlloc"]
    #[doc = ""]
    #[doc = " It is not valid to use this function on a pointer from anything but"]
    #[doc = " SDL_SIMDAlloc(). It can't be used on pointers from malloc, realloc,"]
    #[doc = " SDL_malloc, memalign, new[], etc."]
    #[doc = ""]
    #[doc = " \\param mem The pointer obtained from SDL_SIMDAlloc. This function also"]
    #[doc = "            accepts NULL, at which point this function is the same as"]
    #[doc = "            calling SDL_SIMDAlloc with a NULL pointer."]
    #[doc = " \\param len The length, in bytes, of the block to allocated. The actual"]
    #[doc = "            allocated block might be larger due to padding, etc. Passing 0"]
    #[doc = "            will return a non-NULL pointer, assuming the system isn't out of"]
    #[doc = "            memory."]
    #[doc = " \\returns a pointer to the newly-reallocated block, NULL if out of memory."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.14."]
    #[doc = ""]
    #[doc = " \\sa SDL_SIMDAlignment"]
    #[doc = " \\sa SDL_SIMDAlloc"]
    #[doc = " \\sa SDL_SIMDFree"]
    pub fn SDL_SIMDRealloc(mem: *mut libc::c_void, len: size_t) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Deallocate memory obtained from SDL_SIMDAlloc"]
    #[doc = ""]
    #[doc = " It is not valid to use this function on a pointer from anything but"]
    #[doc = " SDL_SIMDAlloc() or SDL_SIMDRealloc(). It can't be used on pointers from"]
    #[doc = " malloc, realloc, SDL_malloc, memalign, new[], etc."]
    #[doc = ""]
    #[doc = " However, SDL_SIMDFree(NULL) is a legal no-op."]
    #[doc = ""]
    #[doc = " The memory pointed to by `ptr` is no longer valid for access upon return,"]
    #[doc = " and may be returned to the system or reused by a future allocation. The"]
    #[doc = " pointer passed to this function is no longer safe to dereference once this"]
    #[doc = " function returns, and should be discarded."]
    #[doc = ""]
    #[doc = " \\param ptr The pointer, returned from SDL_SIMDAlloc or SDL_SIMDRealloc, to"]
    #[doc = "            deallocate. NULL is a legal no-op."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.10."]
    #[doc = ""]
    #[doc = " \\sa SDL_SIMDAlloc"]
    #[doc = " \\sa SDL_SIMDRealloc"]
    pub fn SDL_SIMDFree(ptr: *mut libc::c_void);
}
#[repr(u32)]
#[doc = " Pixel type."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_PixelType {
    SDL_PIXELTYPE_UNKNOWN = 0,
    SDL_PIXELTYPE_INDEX1 = 1,
    SDL_PIXELTYPE_INDEX4 = 2,
    SDL_PIXELTYPE_INDEX8 = 3,
    SDL_PIXELTYPE_PACKED8 = 4,
    SDL_PIXELTYPE_PACKED16 = 5,
    SDL_PIXELTYPE_PACKED32 = 6,
    SDL_PIXELTYPE_ARRAYU8 = 7,
    SDL_PIXELTYPE_ARRAYU16 = 8,
    SDL_PIXELTYPE_ARRAYU32 = 9,
    SDL_PIXELTYPE_ARRAYF16 = 10,
    SDL_PIXELTYPE_ARRAYF32 = 11,
}
#[repr(u32)]
#[doc = " Bitmap pixel order, high bit -> low bit."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_BitmapOrder {
    SDL_BITMAPORDER_NONE = 0,
    SDL_BITMAPORDER_4321 = 1,
    SDL_BITMAPORDER_1234 = 2,
}
#[repr(u32)]
#[doc = " Packed component order, high bit -> low bit."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_PackedOrder {
    SDL_PACKEDORDER_NONE = 0,
    SDL_PACKEDORDER_XRGB = 1,
    SDL_PACKEDORDER_RGBX = 2,
    SDL_PACKEDORDER_ARGB = 3,
    SDL_PACKEDORDER_RGBA = 4,
    SDL_PACKEDORDER_XBGR = 5,
    SDL_PACKEDORDER_BGRX = 6,
    SDL_PACKEDORDER_ABGR = 7,
    SDL_PACKEDORDER_BGRA = 8,
}
#[repr(u32)]
#[doc = " Array component order, low byte -> high byte."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_ArrayOrder {
    SDL_ARRAYORDER_NONE = 0,
    SDL_ARRAYORDER_RGB = 1,
    SDL_ARRAYORDER_RGBA = 2,
    SDL_ARRAYORDER_ARGB = 3,
    SDL_ARRAYORDER_BGR = 4,
    SDL_ARRAYORDER_BGRA = 5,
    SDL_ARRAYORDER_ABGR = 6,
}
#[repr(u32)]
#[doc = " Packed component layout."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_PackedLayout {
    SDL_PACKEDLAYOUT_NONE = 0,
    SDL_PACKEDLAYOUT_332 = 1,
    SDL_PACKEDLAYOUT_4444 = 2,
    SDL_PACKEDLAYOUT_1555 = 3,
    SDL_PACKEDLAYOUT_5551 = 4,
    SDL_PACKEDLAYOUT_565 = 5,
    SDL_PACKEDLAYOUT_8888 = 6,
    SDL_PACKEDLAYOUT_2101010 = 7,
    SDL_PACKEDLAYOUT_1010102 = 8,
}
impl SDL_PixelFormatEnum {
    pub const SDL_PIXELFORMAT_RGB444: SDL_PixelFormatEnum =
        SDL_PixelFormatEnum::SDL_PIXELFORMAT_XRGB4444;
}
impl SDL_PixelFormatEnum {
    pub const SDL_PIXELFORMAT_BGR444: SDL_PixelFormatEnum =
        SDL_PixelFormatEnum::SDL_PIXELFORMAT_XBGR4444;
}
impl SDL_PixelFormatEnum {
    pub const SDL_PIXELFORMAT_RGB555: SDL_PixelFormatEnum =
        SDL_PixelFormatEnum::SDL_PIXELFORMAT_XRGB1555;
}
impl SDL_PixelFormatEnum {
    pub const SDL_PIXELFORMAT_BGR555: SDL_PixelFormatEnum =
        SDL_PixelFormatEnum::SDL_PIXELFORMAT_XBGR1555;
}
impl SDL_PixelFormatEnum {
    pub const SDL_PIXELFORMAT_RGB888: SDL_PixelFormatEnum =
        SDL_PixelFormatEnum::SDL_PIXELFORMAT_XRGB8888;
}
impl SDL_PixelFormatEnum {
    pub const SDL_PIXELFORMAT_BGR888: SDL_PixelFormatEnum =
        SDL_PixelFormatEnum::SDL_PIXELFORMAT_XBGR8888;
}
impl SDL_PixelFormatEnum {
    pub const SDL_PIXELFORMAT_RGBA32: SDL_PixelFormatEnum =
        SDL_PixelFormatEnum::SDL_PIXELFORMAT_ABGR8888;
}
impl SDL_PixelFormatEnum {
    pub const SDL_PIXELFORMAT_ARGB32: SDL_PixelFormatEnum =
        SDL_PixelFormatEnum::SDL_PIXELFORMAT_BGRA8888;
}
impl SDL_PixelFormatEnum {
    pub const SDL_PIXELFORMAT_BGRA32: SDL_PixelFormatEnum =
        SDL_PixelFormatEnum::SDL_PIXELFORMAT_ARGB8888;
}
impl SDL_PixelFormatEnum {
    pub const SDL_PIXELFORMAT_ABGR32: SDL_PixelFormatEnum =
        SDL_PixelFormatEnum::SDL_PIXELFORMAT_RGBA8888;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_PixelFormatEnum {
    SDL_PIXELFORMAT_UNKNOWN = 0,
    SDL_PIXELFORMAT_INDEX1LSB = 286261504,
    SDL_PIXELFORMAT_INDEX1MSB = 287310080,
    SDL_PIXELFORMAT_INDEX4LSB = 303039488,
    SDL_PIXELFORMAT_INDEX4MSB = 304088064,
    SDL_PIXELFORMAT_INDEX8 = 318769153,
    SDL_PIXELFORMAT_RGB332 = 336660481,
    SDL_PIXELFORMAT_XRGB4444 = 353504258,
    SDL_PIXELFORMAT_XBGR4444 = 357698562,
    SDL_PIXELFORMAT_XRGB1555 = 353570562,
    SDL_PIXELFORMAT_XBGR1555 = 357764866,
    SDL_PIXELFORMAT_ARGB4444 = 355602434,
    SDL_PIXELFORMAT_RGBA4444 = 356651010,
    SDL_PIXELFORMAT_ABGR4444 = 359796738,
    SDL_PIXELFORMAT_BGRA4444 = 360845314,
    SDL_PIXELFORMAT_ARGB1555 = 355667970,
    SDL_PIXELFORMAT_RGBA5551 = 356782082,
    SDL_PIXELFORMAT_ABGR1555 = 359862274,
    SDL_PIXELFORMAT_BGRA5551 = 360976386,
    SDL_PIXELFORMAT_RGB565 = 353701890,
    SDL_PIXELFORMAT_BGR565 = 357896194,
    SDL_PIXELFORMAT_RGB24 = 386930691,
    SDL_PIXELFORMAT_BGR24 = 390076419,
    SDL_PIXELFORMAT_XRGB8888 = 370546692,
    SDL_PIXELFORMAT_RGBX8888 = 371595268,
    SDL_PIXELFORMAT_XBGR8888 = 374740996,
    SDL_PIXELFORMAT_BGRX8888 = 375789572,
    SDL_PIXELFORMAT_ARGB8888 = 372645892,
    SDL_PIXELFORMAT_RGBA8888 = 373694468,
    SDL_PIXELFORMAT_ABGR8888 = 376840196,
    SDL_PIXELFORMAT_BGRA8888 = 377888772,
    SDL_PIXELFORMAT_ARGB2101010 = 372711428,
    #[doc = "< Planar mode: Y + V + U  (3 planes)"]
    SDL_PIXELFORMAT_YV12 = 842094169,
    #[doc = "< Planar mode: Y + U + V  (3 planes)"]
    SDL_PIXELFORMAT_IYUV = 1448433993,
    #[doc = "< Packed mode: Y0+U0+Y1+V0 (1 plane)"]
    SDL_PIXELFORMAT_YUY2 = 844715353,
    #[doc = "< Packed mode: U0+Y0+V0+Y1 (1 plane)"]
    SDL_PIXELFORMAT_UYVY = 1498831189,
    #[doc = "< Packed mode: Y0+V0+Y1+U0 (1 plane)"]
    SDL_PIXELFORMAT_YVYU = 1431918169,
    #[doc = "< Planar mode: Y + U/V interleaved  (2 planes)"]
    SDL_PIXELFORMAT_NV12 = 842094158,
    #[doc = "< Planar mode: Y + V/U interleaved  (2 planes)"]
    SDL_PIXELFORMAT_NV21 = 825382478,
    #[doc = "< Android video texture format"]
    SDL_PIXELFORMAT_EXTERNAL_OES = 542328143,
}
#[doc = " The bits of this structure can be directly reinterpreted as an integer-packed"]
#[doc = " color which uses the SDL_PIXELFORMAT_RGBA32 format (SDL_PIXELFORMAT_ABGR8888"]
#[doc = " on little-endian systems and SDL_PIXELFORMAT_RGBA8888 on big-endian systems)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Color {
    pub r: Uint8,
    pub g: Uint8,
    pub b: Uint8,
    pub a: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_Color() {
    assert_eq!(
        ::core::mem::size_of::<SDL_Color>(),
        4usize,
        concat!("Size of: ", stringify!(SDL_Color))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_Color>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_Color))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Color>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Color),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Color>())).g as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Color),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Color>())).b as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Color),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Color>())).a as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Color),
            "::",
            stringify!(a)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Palette {
    pub ncolors: libc::c_int,
    pub colors: *mut SDL_Color,
    pub version: Uint32,
    pub refcount: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Palette() {
    assert_eq!(
        ::core::mem::size_of::<SDL_Palette>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_Palette))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_Palette>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_Palette))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Palette>())).ncolors as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Palette),
            "::",
            stringify!(ncolors)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Palette>())).colors as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Palette),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Palette>())).version as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Palette),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Palette>())).refcount as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Palette),
            "::",
            stringify!(refcount)
        )
    );
}
#[doc = "  \\note Everything in the pixel format structure is read-only."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_PixelFormat {
    pub format: Uint32,
    pub palette: *mut SDL_Palette,
    pub BitsPerPixel: Uint8,
    pub BytesPerPixel: Uint8,
    pub padding: [Uint8; 2usize],
    pub Rmask: Uint32,
    pub Gmask: Uint32,
    pub Bmask: Uint32,
    pub Amask: Uint32,
    pub Rloss: Uint8,
    pub Gloss: Uint8,
    pub Bloss: Uint8,
    pub Aloss: Uint8,
    pub Rshift: Uint8,
    pub Gshift: Uint8,
    pub Bshift: Uint8,
    pub Ashift: Uint8,
    pub refcount: libc::c_int,
    pub next: *mut SDL_PixelFormat,
}
#[test]
fn bindgen_test_layout_SDL_PixelFormat() {
    assert_eq!(
        ::core::mem::size_of::<SDL_PixelFormat>(),
        56usize,
        concat!("Size of: ", stringify!(SDL_PixelFormat))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_PixelFormat>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_PixelFormat))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).palette as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(palette)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).BitsPerPixel as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(BitsPerPixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).BytesPerPixel as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(BytesPerPixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).padding as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Rmask as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Rmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Gmask as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Gmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Bmask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Bmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Amask as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Amask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Rloss as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Rloss)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Gloss as *const _ as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Gloss)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Bloss as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Bloss)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Aloss as *const _ as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Aloss)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Rshift as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Rshift)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Gshift as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Gshift)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Bshift as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Bshift)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).Ashift as *const _ as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Ashift)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).refcount as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_PixelFormat>())).next as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    #[doc = " Get the human readable name of a pixel format."]
    #[doc = ""]
    #[doc = " \\param format the pixel format to query"]
    #[doc = " \\returns the human readable name of the specified pixel format or"]
    #[doc = "          `SDL_PIXELFORMAT_UNKNOWN` if the format isn't recognized."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_GetPixelFormatName(format: Uint32) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Convert one of the enumerated pixel formats to a bpp value and RGBA masks."]
    #[doc = ""]
    #[doc = " \\param format one of the SDL_PixelFormatEnum values"]
    #[doc = " \\param bpp a bits per pixel value; usually 15, 16, or 32"]
    #[doc = " \\param Rmask a pointer filled in with the red mask for the format"]
    #[doc = " \\param Gmask a pointer filled in with the green mask for the format"]
    #[doc = " \\param Bmask a pointer filled in with the blue mask for the format"]
    #[doc = " \\param Amask a pointer filled in with the alpha mask for the format"]
    #[doc = " \\returns SDL_TRUE on success or SDL_FALSE if the conversion wasn't"]
    #[doc = "          possible; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_MasksToPixelFormatEnum"]
    pub fn SDL_PixelFormatEnumToMasks(
        format: Uint32,
        bpp: *mut libc::c_int,
        Rmask: *mut Uint32,
        Gmask: *mut Uint32,
        Bmask: *mut Uint32,
        Amask: *mut Uint32,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = " Convert a bpp value and RGBA masks to an enumerated pixel format."]
    #[doc = ""]
    #[doc = " This will return `SDL_PIXELFORMAT_UNKNOWN` if the conversion wasn't"]
    #[doc = " possible."]
    #[doc = ""]
    #[doc = " \\param bpp a bits per pixel value; usually 15, 16, or 32"]
    #[doc = " \\param Rmask the red mask for the format"]
    #[doc = " \\param Gmask the green mask for the format"]
    #[doc = " \\param Bmask the blue mask for the format"]
    #[doc = " \\param Amask the alpha mask for the format"]
    #[doc = " \\returns one of the SDL_PixelFormatEnum values"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_PixelFormatEnumToMasks"]
    pub fn SDL_MasksToPixelFormatEnum(
        bpp: libc::c_int,
        Rmask: Uint32,
        Gmask: Uint32,
        Bmask: Uint32,
        Amask: Uint32,
    ) -> Uint32;
}
extern "C" {
    #[doc = " Create an SDL_PixelFormat structure corresponding to a pixel format."]
    #[doc = ""]
    #[doc = " Returned structure may come from a shared global cache (i.e. not newly"]
    #[doc = " allocated), and hence should not be modified, especially the palette. Weird"]
    #[doc = " errors such as `Blit combination not supported` may occur."]
    #[doc = ""]
    #[doc = " \\param pixel_format one of the SDL_PixelFormatEnum values"]
    #[doc = " \\returns the new SDL_PixelFormat structure or NULL on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_FreeFormat"]
    pub fn SDL_AllocFormat(pixel_format: Uint32) -> *mut SDL_PixelFormat;
}
extern "C" {
    #[doc = " Free an SDL_PixelFormat structure allocated by SDL_AllocFormat()."]
    #[doc = ""]
    #[doc = " \\param format the SDL_PixelFormat structure to free"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_AllocFormat"]
    pub fn SDL_FreeFormat(format: *mut SDL_PixelFormat);
}
extern "C" {
    #[doc = " Create a palette structure with the specified number of color entries."]
    #[doc = ""]
    #[doc = " The palette entries are initialized to white."]
    #[doc = ""]
    #[doc = " \\param ncolors represents the number of color entries in the color palette"]
    #[doc = " \\returns a new SDL_Palette structure on success or NULL on failure (e.g. if"]
    #[doc = "          there wasn't enough memory); call SDL_GetError() for more"]
    #[doc = "          information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_FreePalette"]
    pub fn SDL_AllocPalette(ncolors: libc::c_int) -> *mut SDL_Palette;
}
extern "C" {
    #[doc = " Set the palette for a pixel format structure."]
    #[doc = ""]
    #[doc = " \\param format the SDL_PixelFormat structure that will use the palette"]
    #[doc = " \\param palette the SDL_Palette structure that will be used"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_AllocPalette"]
    #[doc = " \\sa SDL_FreePalette"]
    pub fn SDL_SetPixelFormatPalette(
        format: *mut SDL_PixelFormat,
        palette: *mut SDL_Palette,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set a range of colors in a palette."]
    #[doc = ""]
    #[doc = " \\param palette the SDL_Palette structure to modify"]
    #[doc = " \\param colors an array of SDL_Color structures to copy into the palette"]
    #[doc = " \\param firstcolor the index of the first palette entry to modify"]
    #[doc = " \\param ncolors the number of entries to modify"]
    #[doc = " \\returns 0 on success or a negative error code if not all of the colors"]
    #[doc = "          could be set; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_AllocPalette"]
    #[doc = " \\sa SDL_CreateRGBSurface"]
    pub fn SDL_SetPaletteColors(
        palette: *mut SDL_Palette,
        colors: *const SDL_Color,
        firstcolor: libc::c_int,
        ncolors: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Free a palette created with SDL_AllocPalette()."]
    #[doc = ""]
    #[doc = " \\param palette the SDL_Palette structure to be freed"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_AllocPalette"]
    pub fn SDL_FreePalette(palette: *mut SDL_Palette);
}
extern "C" {
    #[doc = " Map an RGB triple to an opaque pixel value for a given pixel format."]
    #[doc = ""]
    #[doc = " This function maps the RGB color value to the specified pixel format and"]
    #[doc = " returns the pixel value best approximating the given RGB color value for"]
    #[doc = " the given pixel format."]
    #[doc = ""]
    #[doc = " If the format has a palette (8-bit) the index of the closest matching color"]
    #[doc = " in the palette will be returned."]
    #[doc = ""]
    #[doc = " If the specified pixel format has an alpha component it will be returned as"]
    #[doc = " all 1 bits (fully opaque)."]
    #[doc = ""]
    #[doc = " If the pixel format bpp (color depth) is less than 32-bpp then the unused"]
    #[doc = " upper bits of the return value can safely be ignored (e.g., with a 16-bpp"]
    #[doc = " format the return value can be assigned to a Uint16, and similarly a Uint8"]
    #[doc = " for an 8-bpp format)."]
    #[doc = ""]
    #[doc = " \\param format an SDL_PixelFormat structure describing the pixel format"]
    #[doc = " \\param r the red component of the pixel in the range 0-255"]
    #[doc = " \\param g the green component of the pixel in the range 0-255"]
    #[doc = " \\param b the blue component of the pixel in the range 0-255"]
    #[doc = " \\returns a pixel value"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetRGB"]
    #[doc = " \\sa SDL_GetRGBA"]
    #[doc = " \\sa SDL_MapRGBA"]
    pub fn SDL_MapRGB(format: *const SDL_PixelFormat, r: Uint8, g: Uint8, b: Uint8) -> Uint32;
}
extern "C" {
    #[doc = " Map an RGBA quadruple to a pixel value for a given pixel format."]
    #[doc = ""]
    #[doc = " This function maps the RGBA color value to the specified pixel format and"]
    #[doc = " returns the pixel value best approximating the given RGBA color value for"]
    #[doc = " the given pixel format."]
    #[doc = ""]
    #[doc = " If the specified pixel format has no alpha component the alpha value will"]
    #[doc = " be ignored (as it will be in formats with a palette)."]
    #[doc = ""]
    #[doc = " If the format has a palette (8-bit) the index of the closest matching color"]
    #[doc = " in the palette will be returned."]
    #[doc = ""]
    #[doc = " If the pixel format bpp (color depth) is less than 32-bpp then the unused"]
    #[doc = " upper bits of the return value can safely be ignored (e.g., with a 16-bpp"]
    #[doc = " format the return value can be assigned to a Uint16, and similarly a Uint8"]
    #[doc = " for an 8-bpp format)."]
    #[doc = ""]
    #[doc = " \\param format an SDL_PixelFormat structure describing the format of the"]
    #[doc = "               pixel"]
    #[doc = " \\param r the red component of the pixel in the range 0-255"]
    #[doc = " \\param g the green component of the pixel in the range 0-255"]
    #[doc = " \\param b the blue component of the pixel in the range 0-255"]
    #[doc = " \\param a the alpha component of the pixel in the range 0-255"]
    #[doc = " \\returns a pixel value"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetRGB"]
    #[doc = " \\sa SDL_GetRGBA"]
    #[doc = " \\sa SDL_MapRGB"]
    pub fn SDL_MapRGBA(
        format: *const SDL_PixelFormat,
        r: Uint8,
        g: Uint8,
        b: Uint8,
        a: Uint8,
    ) -> Uint32;
}
extern "C" {
    #[doc = " Get RGB values from a pixel in the specified format."]
    #[doc = ""]
    #[doc = " This function uses the entire 8-bit [0..255] range when converting color"]
    #[doc = " components from pixel formats with less than 8-bits per RGB component"]
    #[doc = " (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,"]
    #[doc = " 0xff, 0xff] not [0xf8, 0xfc, 0xf8])."]
    #[doc = ""]
    #[doc = " \\param pixel a pixel value"]
    #[doc = " \\param format an SDL_PixelFormat structure describing the format of the"]
    #[doc = "               pixel"]
    #[doc = " \\param r a pointer filled in with the red component"]
    #[doc = " \\param g a pointer filled in with the green component"]
    #[doc = " \\param b a pointer filled in with the blue component"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetRGBA"]
    #[doc = " \\sa SDL_MapRGB"]
    #[doc = " \\sa SDL_MapRGBA"]
    pub fn SDL_GetRGB(
        pixel: Uint32,
        format: *const SDL_PixelFormat,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
    );
}
extern "C" {
    #[doc = " Get RGBA values from a pixel in the specified format."]
    #[doc = ""]
    #[doc = " This function uses the entire 8-bit [0..255] range when converting color"]
    #[doc = " components from pixel formats with less than 8-bits per RGB component"]
    #[doc = " (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,"]
    #[doc = " 0xff, 0xff] not [0xf8, 0xfc, 0xf8])."]
    #[doc = ""]
    #[doc = " If the surface has no alpha component, the alpha will be returned as 0xff"]
    #[doc = " (100% opaque)."]
    #[doc = ""]
    #[doc = " \\param pixel a pixel value"]
    #[doc = " \\param format an SDL_PixelFormat structure describing the format of the"]
    #[doc = "               pixel"]
    #[doc = " \\param r a pointer filled in with the red component"]
    #[doc = " \\param g a pointer filled in with the green component"]
    #[doc = " \\param b a pointer filled in with the blue component"]
    #[doc = " \\param a a pointer filled in with the alpha component"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetRGB"]
    #[doc = " \\sa SDL_MapRGB"]
    #[doc = " \\sa SDL_MapRGBA"]
    pub fn SDL_GetRGBA(
        pixel: Uint32,
        format: *const SDL_PixelFormat,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
        a: *mut Uint8,
    );
}
extern "C" {
    #[doc = " Calculate a 256 entry gamma ramp for a gamma value."]
    #[doc = ""]
    #[doc = " \\param gamma a gamma value where 0.0 is black and 1.0 is identity"]
    #[doc = " \\param ramp an array of 256 values filled in with the gamma ramp"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_SetWindowGammaRamp"]
    pub fn SDL_CalculateGammaRamp(gamma: f32, ramp: *mut Uint16);
}
#[doc = " The structure that defines a point (integer)"]
#[doc = ""]
#[doc = " \\sa SDL_EnclosePoints"]
#[doc = " \\sa SDL_PointInRect"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Point {
    pub x: libc::c_int,
    pub y: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Point() {
    assert_eq!(
        ::core::mem::size_of::<SDL_Point>(),
        8usize,
        concat!("Size of: ", stringify!(SDL_Point))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_Point>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_Point))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Point>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Point),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Point>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Point),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " The structure that defines a point (floating point)"]
#[doc = ""]
#[doc = " \\sa SDL_EnclosePoints"]
#[doc = " \\sa SDL_PointInRect"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_FPoint {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_SDL_FPoint() {
    assert_eq!(
        ::core::mem::size_of::<SDL_FPoint>(),
        8usize,
        concat!("Size of: ", stringify!(SDL_FPoint))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_FPoint>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_FPoint))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_FPoint>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_FPoint),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_FPoint>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_FPoint),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " A rectangle, with the origin at the upper left (integer)."]
#[doc = ""]
#[doc = " \\sa SDL_RectEmpty"]
#[doc = " \\sa SDL_RectEquals"]
#[doc = " \\sa SDL_HasIntersection"]
#[doc = " \\sa SDL_IntersectRect"]
#[doc = " \\sa SDL_UnionRect"]
#[doc = " \\sa SDL_EnclosePoints"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Rect {
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub w: libc::c_int,
    pub h: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Rect() {
    assert_eq!(
        ::core::mem::size_of::<SDL_Rect>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_Rect))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_Rect>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_Rect))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Rect>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Rect),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Rect>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Rect),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Rect>())).w as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Rect),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Rect>())).h as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Rect),
            "::",
            stringify!(h)
        )
    );
}
#[doc = " A rectangle, with the origin at the upper left (floating point)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_FRect {
    pub x: f32,
    pub y: f32,
    pub w: f32,
    pub h: f32,
}
#[test]
fn bindgen_test_layout_SDL_FRect() {
    assert_eq!(
        ::core::mem::size_of::<SDL_FRect>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_FRect))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_FRect>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_FRect))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_FRect>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_FRect),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_FRect>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_FRect),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_FRect>())).w as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_FRect),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_FRect>())).h as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_FRect),
            "::",
            stringify!(h)
        )
    );
}
extern "C" {
    #[doc = " Determine whether two rectangles intersect."]
    #[doc = ""]
    #[doc = " If either pointer is NULL the function will return SDL_FALSE."]
    #[doc = ""]
    #[doc = " \\param A an SDL_Rect structure representing the first rectangle"]
    #[doc = " \\param B an SDL_Rect structure representing the second rectangle"]
    #[doc = " \\returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_IntersectRect"]
    pub fn SDL_HasIntersection(A: *const SDL_Rect, B: *const SDL_Rect) -> SDL_bool;
}
extern "C" {
    #[doc = " Calculate the intersection of two rectangles."]
    #[doc = ""]
    #[doc = " If `result` is NULL then this function will return SDL_FALSE."]
    #[doc = ""]
    #[doc = " \\param A an SDL_Rect structure representing the first rectangle"]
    #[doc = " \\param B an SDL_Rect structure representing the second rectangle"]
    #[doc = " \\param result an SDL_Rect structure filled in with the intersection of"]
    #[doc = "               rectangles `A` and `B`"]
    #[doc = " \\returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HasIntersection"]
    pub fn SDL_IntersectRect(
        A: *const SDL_Rect,
        B: *const SDL_Rect,
        result: *mut SDL_Rect,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = " Calculate the union of two rectangles."]
    #[doc = ""]
    #[doc = " \\param A an SDL_Rect structure representing the first rectangle"]
    #[doc = " \\param B an SDL_Rect structure representing the second rectangle"]
    #[doc = " \\param result an SDL_Rect structure filled in with the union of rectangles"]
    #[doc = "               `A` and `B`"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_UnionRect(A: *const SDL_Rect, B: *const SDL_Rect, result: *mut SDL_Rect);
}
extern "C" {
    #[doc = " Calculate a minimal rectangle enclosing a set of points."]
    #[doc = ""]
    #[doc = " If `clip` is not NULL then only points inside of the clipping rectangle are"]
    #[doc = " considered."]
    #[doc = ""]
    #[doc = " \\param points an array of SDL_Point structures representing points to be"]
    #[doc = "               enclosed"]
    #[doc = " \\param count the number of structures in the `points` array"]
    #[doc = " \\param clip an SDL_Rect used for clipping or NULL to enclose all points"]
    #[doc = " \\param result an SDL_Rect structure filled in with the minimal enclosing"]
    #[doc = "               rectangle"]
    #[doc = " \\returns SDL_TRUE if any points were enclosed or SDL_FALSE if all the"]
    #[doc = "          points were outside of the clipping rectangle."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_EnclosePoints(
        points: *const SDL_Point,
        count: libc::c_int,
        clip: *const SDL_Rect,
        result: *mut SDL_Rect,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = " Calculate the intersection of a rectangle and line segment."]
    #[doc = ""]
    #[doc = " This function is used to clip a line segment to a rectangle. A line segment"]
    #[doc = " contained entirely within the rectangle or that does not intersect will"]
    #[doc = " remain unchanged. A line segment that crosses the rectangle at either or"]
    #[doc = " both ends will be clipped to the boundary of the rectangle and the new"]
    #[doc = " coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary."]
    #[doc = ""]
    #[doc = " \\param rect an SDL_Rect structure representing the rectangle to intersect"]
    #[doc = " \\param X1 a pointer to the starting X-coordinate of the line"]
    #[doc = " \\param Y1 a pointer to the starting Y-coordinate of the line"]
    #[doc = " \\param X2 a pointer to the ending X-coordinate of the line"]
    #[doc = " \\param Y2 a pointer to the ending Y-coordinate of the line"]
    #[doc = " \\returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_IntersectRectAndLine(
        rect: *const SDL_Rect,
        X1: *mut libc::c_int,
        Y1: *mut libc::c_int,
        X2: *mut libc::c_int,
        Y2: *mut libc::c_int,
    ) -> SDL_bool;
}
#[repr(u32)]
#[doc = "  \\brief The blend mode used in SDL_RenderCopy() and drawing operations."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_BlendMode {
    #[doc = "< no blending"]
    #[doc = "dstRGBA = srcRGBA"]
    SDL_BLENDMODE_NONE = 0,
    #[doc = "< alpha blending"]
    #[doc = "dstRGB = (srcRGB * srcA) + (dstRGB * (1-srcA))"]
    #[doc = "dstA = srcA + (dstA * (1-srcA))"]
    SDL_BLENDMODE_BLEND = 1,
    #[doc = "< additive blending"]
    #[doc = "dstRGB = (srcRGB * srcA) + dstRGB"]
    #[doc = "dstA = dstA"]
    SDL_BLENDMODE_ADD = 2,
    #[doc = "< color modulate"]
    #[doc = "dstRGB = srcRGB * dstRGB"]
    #[doc = "dstA = dstA"]
    SDL_BLENDMODE_MOD = 4,
    #[doc = "< color multiply"]
    #[doc = "dstRGB = (srcRGB * dstRGB) + (dstRGB * (1-srcA))"]
    #[doc = "dstA = (srcA * dstA) + (dstA * (1-srcA))"]
    SDL_BLENDMODE_MUL = 8,
    SDL_BLENDMODE_INVALID = 2147483647,
}
#[repr(u32)]
#[doc = "  \\brief The blend operation used when combining source and destination pixel components"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_BlendOperation {
    #[doc = "< dst + src: supported by all renderers"]
    SDL_BLENDOPERATION_ADD = 1,
    #[doc = "< dst - src : supported by D3D9, D3D11, OpenGL, OpenGLES"]
    SDL_BLENDOPERATION_SUBTRACT = 2,
    #[doc = "< src - dst : supported by D3D9, D3D11, OpenGL, OpenGLES"]
    SDL_BLENDOPERATION_REV_SUBTRACT = 3,
    #[doc = "< min(dst, src) : supported by D3D11"]
    SDL_BLENDOPERATION_MINIMUM = 4,
    #[doc = "< max(dst, src) : supported by D3D11"]
    SDL_BLENDOPERATION_MAXIMUM = 5,
}
#[repr(u32)]
#[doc = "  \\brief The normalized factor used to multiply pixel components"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_BlendFactor {
    #[doc = "< 0, 0, 0, 0"]
    SDL_BLENDFACTOR_ZERO = 1,
    #[doc = "< 1, 1, 1, 1"]
    SDL_BLENDFACTOR_ONE = 2,
    #[doc = "< srcR, srcG, srcB, srcA"]
    SDL_BLENDFACTOR_SRC_COLOR = 3,
    #[doc = "< 1-srcR, 1-srcG, 1-srcB, 1-srcA"]
    SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR = 4,
    #[doc = "< srcA, srcA, srcA, srcA"]
    SDL_BLENDFACTOR_SRC_ALPHA = 5,
    #[doc = "< 1-srcA, 1-srcA, 1-srcA, 1-srcA"]
    SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA = 6,
    #[doc = "< dstR, dstG, dstB, dstA"]
    SDL_BLENDFACTOR_DST_COLOR = 7,
    #[doc = "< 1-dstR, 1-dstG, 1-dstB, 1-dstA"]
    SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR = 8,
    #[doc = "< dstA, dstA, dstA, dstA"]
    SDL_BLENDFACTOR_DST_ALPHA = 9,
    #[doc = "< 1-dstA, 1-dstA, 1-dstA, 1-dstA"]
    SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA = 10,
}
extern "C" {
    #[doc = " Compose a custom blend mode for renderers."]
    #[doc = ""]
    #[doc = " The functions SDL_SetRenderDrawBlendMode and SDL_SetTextureBlendMode accept"]
    #[doc = " the SDL_BlendMode returned by this function if the renderer supports it."]
    #[doc = ""]
    #[doc = " A blend mode controls how the pixels from a drawing operation (source) get"]
    #[doc = " combined with the pixels from the render target (destination). First, the"]
    #[doc = " components of the source and destination pixels get multiplied with their"]
    #[doc = " blend factors. Then, the blend operation takes the two products and"]
    #[doc = " calculates the result that will get stored in the render target."]
    #[doc = ""]
    #[doc = " Expressed in pseudocode, it would look like this:"]
    #[doc = ""]
    #[doc = " ```c"]
    #[doc = " dstRGB = colorOperation(srcRGB * srcColorFactor, dstRGB * dstColorFactor);"]
    #[doc = " dstA = alphaOperation(srcA * srcAlphaFactor, dstA * dstAlphaFactor);"]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " Where the functions `colorOperation(src, dst)` and `alphaOperation(src,"]
    #[doc = " dst)` can return one of the following:"]
    #[doc = ""]
    #[doc = " - `src + dst`"]
    #[doc = " - `src - dst`"]
    #[doc = " - `dst - src`"]
    #[doc = " - `min(src, dst)`"]
    #[doc = " - `max(src, dst)`"]
    #[doc = ""]
    #[doc = " The red, green, and blue components are always multiplied with the first,"]
    #[doc = " second, and third components of the SDL_BlendFactor, respectively. The"]
    #[doc = " fourth component is not used."]
    #[doc = ""]
    #[doc = " The alpha component is always multiplied with the fourth component of the"]
    #[doc = " SDL_BlendFactor. The other components are not used in the alpha"]
    #[doc = " calculation."]
    #[doc = ""]
    #[doc = " Support for these blend modes varies for each renderer. To check if a"]
    #[doc = " specific SDL_BlendMode is supported, create a renderer and pass it to"]
    #[doc = " either SDL_SetRenderDrawBlendMode or SDL_SetTextureBlendMode. They will"]
    #[doc = " return with an error if the blend mode is not supported."]
    #[doc = ""]
    #[doc = " This list describes the support of custom blend modes for each renderer in"]
    #[doc = " SDL 2.0.6. All renderers support the four blend modes listed in the"]
    #[doc = " SDL_BlendMode enumeration."]
    #[doc = ""]
    #[doc = " - **direct3d**: Supports `SDL_BLENDOPERATION_ADD` with all factors."]
    #[doc = " - **direct3d11**: Supports all operations with all factors. However, some"]
    #[doc = "   factors produce unexpected results with `SDL_BLENDOPERATION_MINIMUM` and"]
    #[doc = "   `SDL_BLENDOPERATION_MAXIMUM`."]
    #[doc = " - **opengl**: Supports the `SDL_BLENDOPERATION_ADD` operation with all"]
    #[doc = "   factors. OpenGL versions 1.1, 1.2, and 1.3 do not work correctly with SDL"]
    #[doc = "   2.0.6."]
    #[doc = " - **opengles**: Supports the `SDL_BLENDOPERATION_ADD` operation with all"]
    #[doc = "   factors. Color and alpha factors need to be the same. OpenGL ES 1"]
    #[doc = "   implementation specific: May also support `SDL_BLENDOPERATION_SUBTRACT`"]
    #[doc = "   and `SDL_BLENDOPERATION_REV_SUBTRACT`. May support color and alpha"]
    #[doc = "   operations being different from each other. May support color and alpha"]
    #[doc = "   factors being different from each other."]
    #[doc = " - **opengles2**: Supports the `SDL_BLENDOPERATION_ADD`,"]
    #[doc = "   `SDL_BLENDOPERATION_SUBTRACT`, `SDL_BLENDOPERATION_REV_SUBTRACT`"]
    #[doc = "   operations with all factors."]
    #[doc = " - **psp**: No custom blend mode support."]
    #[doc = " - **software**: No custom blend mode support."]
    #[doc = ""]
    #[doc = " Some renderers do not provide an alpha component for the default render"]
    #[doc = " target. The `SDL_BLENDFACTOR_DST_ALPHA` and"]
    #[doc = " `SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA` factors do not have an effect in this"]
    #[doc = " case."]
    #[doc = ""]
    #[doc = " \\param srcColorFactor the SDL_BlendFactor applied to the red, green, and"]
    #[doc = "                       blue components of the source pixels"]
    #[doc = " \\param dstColorFactor the SDL_BlendFactor applied to the red, green, and"]
    #[doc = "                       blue components of the destination pixels"]
    #[doc = " \\param colorOperation the SDL_BlendOperation used to combine the red,"]
    #[doc = "                       green, and blue components of the source and"]
    #[doc = "                       destination pixels"]
    #[doc = " \\param srcAlphaFactor the SDL_BlendFactor applied to the alpha component of"]
    #[doc = "                       the source pixels"]
    #[doc = " \\param dstAlphaFactor the SDL_BlendFactor applied to the alpha component of"]
    #[doc = "                       the destination pixels"]
    #[doc = " \\param alphaOperation the SDL_BlendOperation used to combine the alpha"]
    #[doc = "                       component of the source and destination pixels"]
    #[doc = " \\returns an SDL_BlendMode that represents the chosen factors and"]
    #[doc = "          operations."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.6."]
    #[doc = ""]
    #[doc = " \\sa SDL_SetRenderDrawBlendMode"]
    #[doc = " \\sa SDL_GetRenderDrawBlendMode"]
    #[doc = " \\sa SDL_SetTextureBlendMode"]
    #[doc = " \\sa SDL_GetTextureBlendMode"]
    pub fn SDL_ComposeCustomBlendMode(
        srcColorFactor: SDL_BlendFactor,
        dstColorFactor: SDL_BlendFactor,
        colorOperation: SDL_BlendOperation,
        srcAlphaFactor: SDL_BlendFactor,
        dstAlphaFactor: SDL_BlendFactor,
        alphaOperation: SDL_BlendOperation,
    ) -> SDL_BlendMode;
}
#[doc = " \\brief A collection of pixels used in software blitting."]
#[doc = ""]
#[doc = " \\note  This structure should be treated as read-only, except for \\c pixels,"]
#[doc = "        which, if not NULL, contains the raw pixel data for the surface."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Surface {
    #[doc = "< Read-only"]
    pub flags: Uint32,
    #[doc = "< Read-only"]
    pub format: *mut SDL_PixelFormat,
    #[doc = "< Read-only"]
    pub w: libc::c_int,
    #[doc = "< Read-only"]
    pub h: libc::c_int,
    #[doc = "< Read-only"]
    pub pitch: libc::c_int,
    #[doc = "< Read-write"]
    pub pixels: *mut libc::c_void,
    #[doc = "< Read-write"]
    pub userdata: *mut libc::c_void,
    #[doc = "< Read-only"]
    pub locked: libc::c_int,
    #[doc = "< Private"]
    pub list_blitmap: *mut libc::c_void,
    #[doc = "< Read-only"]
    pub clip_rect: SDL_Rect,
    #[doc = "< Private"]
    pub map: *mut SDL_BlitMap,
    #[doc = "< Read-mostly"]
    pub refcount: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Surface() {
    assert_eq!(
        ::core::mem::size_of::<SDL_Surface>(),
        96usize,
        concat!("Size of: ", stringify!(SDL_Surface))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_Surface>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_Surface))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Surface>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Surface>())).format as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Surface>())).w as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Surface>())).h as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Surface>())).pitch as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Surface>())).pixels as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(pixels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Surface>())).userdata as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(userdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Surface>())).locked as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(locked)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Surface>())).list_blitmap as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(list_blitmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Surface>())).clip_rect as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(clip_rect)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Surface>())).map as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Surface>())).refcount as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(refcount)
        )
    );
}
#[doc = " \\brief The type of function used for surface blitting functions."]
pub type SDL_blit = ::core::option::Option<
    unsafe extern "C" fn(
        src: *mut SDL_Surface,
        srcrect: *mut SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *mut SDL_Rect,
    ) -> libc::c_int,
>;
#[repr(u32)]
#[doc = " \\brief The formula used for converting between YUV and RGB"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_YUV_CONVERSION_MODE {
    #[doc = "< Full range JPEG"]
    SDL_YUV_CONVERSION_JPEG = 0,
    #[doc = "< BT.601 (the default)"]
    SDL_YUV_CONVERSION_BT601 = 1,
    #[doc = "< BT.709"]
    SDL_YUV_CONVERSION_BT709 = 2,
    #[doc = "< BT.601 for SD content, BT.709 for HD content"]
    SDL_YUV_CONVERSION_AUTOMATIC = 3,
}
extern "C" {
    #[doc = " Allocate a new RGB surface."]
    #[doc = ""]
    #[doc = " If `depth` is 4 or 8 bits, an empty palette is allocated for the surface."]
    #[doc = " If `depth` is greater than 8 bits, the pixel format is set using the"]
    #[doc = " [RGBA]mask parameters."]
    #[doc = ""]
    #[doc = " The [RGBA]mask parameters are the bitmasks used to extract that color from"]
    #[doc = " a pixel. For instance, `Rmask` being 0xFF000000 means the red data is"]
    #[doc = " stored in the most significant byte. Using zeros for the RGB masks sets a"]
    #[doc = " default value, based on the depth. For example:"]
    #[doc = ""]
    #[doc = " ```c++"]
    #[doc = " SDL_CreateRGBSurface(0,w,h,32,0,0,0,0);"]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " However, using zero for the Amask results in an Amask of 0."]
    #[doc = ""]
    #[doc = " By default surfaces with an alpha mask are set up for blending as with:"]
    #[doc = ""]
    #[doc = " ```c++"]
    #[doc = " SDL_SetSurfaceBlendMode(surface, SDL_BLENDMODE_BLEND)"]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " You can change this by calling SDL_SetSurfaceBlendMode() and selecting a"]
    #[doc = " different `blendMode`."]
    #[doc = ""]
    #[doc = " \\param flags the flags are unused and should be set to 0"]
    #[doc = " \\param width the width of the surface"]
    #[doc = " \\param height the height of the surface"]
    #[doc = " \\param depth the depth of the surface in bits"]
    #[doc = " \\param Rmask the red mask for the pixels"]
    #[doc = " \\param Gmask the green mask for the pixels"]
    #[doc = " \\param Bmask the blue mask for the pixels"]
    #[doc = " \\param Amask the alpha mask for the pixels"]
    #[doc = " \\returns the new SDL_Surface structure that is created or NULL if it fails;"]
    #[doc = "          call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateRGBSurfaceFrom"]
    #[doc = " \\sa SDL_CreateRGBSurfaceWithFormat"]
    #[doc = " \\sa SDL_FreeSurface"]
    pub fn SDL_CreateRGBSurface(
        flags: Uint32,
        width: libc::c_int,
        height: libc::c_int,
        depth: libc::c_int,
        Rmask: Uint32,
        Gmask: Uint32,
        Bmask: Uint32,
        Amask: Uint32,
    ) -> *mut SDL_Surface;
}
extern "C" {
    #[doc = " Allocate a new RGB surface with a specific pixel format."]
    #[doc = ""]
    #[doc = " This function operates mostly like SDL_CreateRGBSurface(), except instead"]
    #[doc = " of providing pixel color masks, you provide it with a predefined format"]
    #[doc = " from SDL_PixelFormatEnum."]
    #[doc = ""]
    #[doc = " \\param flags the flags are unused and should be set to 0"]
    #[doc = " \\param width the width of the surface"]
    #[doc = " \\param height the height of the surface"]
    #[doc = " \\param depth the depth of the surface in bits"]
    #[doc = " \\param format the SDL_PixelFormatEnum for the new surface's pixel format."]
    #[doc = " \\returns the new SDL_Surface structure that is created or NULL if it fails;"]
    #[doc = "          call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.5."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateRGBSurface"]
    #[doc = " \\sa SDL_CreateRGBSurfaceFrom"]
    #[doc = " \\sa SDL_FreeSurface"]
    pub fn SDL_CreateRGBSurfaceWithFormat(
        flags: Uint32,
        width: libc::c_int,
        height: libc::c_int,
        depth: libc::c_int,
        format: Uint32,
    ) -> *mut SDL_Surface;
}
extern "C" {
    #[doc = " Allocate a new RGB surface with existing pixel data."]
    #[doc = ""]
    #[doc = " This function operates mostly like SDL_CreateRGBSurface(), except it does"]
    #[doc = " not allocate memory for the pixel data, instead the caller provides an"]
    #[doc = " existing buffer of data for the surface to use."]
    #[doc = ""]
    #[doc = " No copy is made of the pixel data. Pixel data is not managed automatically;"]
    #[doc = " you must free the surface before you free the pixel data."]
    #[doc = ""]
    #[doc = " \\param pixels a pointer to existing pixel data"]
    #[doc = " \\param width the width of the surface"]
    #[doc = " \\param height the height of the surface"]
    #[doc = " \\param depth the depth of the surface in bits"]
    #[doc = " \\param pitch the pitch of the surface in bytes"]
    #[doc = " \\param Rmask the red mask for the pixels"]
    #[doc = " \\param Gmask the green mask for the pixels"]
    #[doc = " \\param Bmask the blue mask for the pixels"]
    #[doc = " \\param Amask the alpha mask for the pixels"]
    #[doc = " \\returns the new SDL_Surface structure that is created or NULL if it fails;"]
    #[doc = "          call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateRGBSurface"]
    #[doc = " \\sa SDL_CreateRGBSurfaceWithFormat"]
    #[doc = " \\sa SDL_FreeSurface"]
    pub fn SDL_CreateRGBSurfaceFrom(
        pixels: *mut libc::c_void,
        width: libc::c_int,
        height: libc::c_int,
        depth: libc::c_int,
        pitch: libc::c_int,
        Rmask: Uint32,
        Gmask: Uint32,
        Bmask: Uint32,
        Amask: Uint32,
    ) -> *mut SDL_Surface;
}
extern "C" {
    #[doc = " Allocate a new RGB surface with with a specific pixel format and existing"]
    #[doc = " pixel data."]
    #[doc = ""]
    #[doc = " This function operates mostly like SDL_CreateRGBSurfaceFrom(), except"]
    #[doc = " instead of providing pixel color masks, you provide it with a predefined"]
    #[doc = " format from SDL_PixelFormatEnum."]
    #[doc = ""]
    #[doc = " No copy is made of the pixel data. Pixel data is not managed automatically;"]
    #[doc = " you must free the surface before you free the pixel data."]
    #[doc = ""]
    #[doc = " \\param pixels a pointer to existing pixel data"]
    #[doc = " \\param width the width of the surface"]
    #[doc = " \\param height the height of the surface"]
    #[doc = " \\param depth the depth of the surface in bits"]
    #[doc = " \\param pitch the pitch of the surface in bytes"]
    #[doc = " \\param format the SDL_PixelFormatEnum for the new surface's pixel format."]
    #[doc = " \\returns the new SDL_Surface structure that is created or NULL if it fails;"]
    #[doc = "          call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.5."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateRGBSurfaceFrom"]
    #[doc = " \\sa SDL_CreateRGBSurfaceWithFormat"]
    #[doc = " \\sa SDL_FreeSurface"]
    pub fn SDL_CreateRGBSurfaceWithFormatFrom(
        pixels: *mut libc::c_void,
        width: libc::c_int,
        height: libc::c_int,
        depth: libc::c_int,
        pitch: libc::c_int,
        format: Uint32,
    ) -> *mut SDL_Surface;
}
extern "C" {
    #[doc = " Free an RGB surface."]
    #[doc = ""]
    #[doc = " It is safe to pass NULL to this function."]
    #[doc = ""]
    #[doc = " \\param surface the SDL_Surface to free."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateRGBSurface"]
    #[doc = " \\sa SDL_CreateRGBSurfaceFrom"]
    #[doc = " \\sa SDL_LoadBMP"]
    #[doc = " \\sa SDL_LoadBMP_RW"]
    pub fn SDL_FreeSurface(surface: *mut SDL_Surface);
}
extern "C" {
    #[doc = " Set the palette used by a surface."]
    #[doc = ""]
    #[doc = " A single palette can be shared with many surfaces."]
    #[doc = ""]
    #[doc = " \\param surface the SDL_Surface structure to update"]
    #[doc = " \\param palette the SDL_Palette structure to use"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_SetSurfacePalette(
        surface: *mut SDL_Surface,
        palette: *mut SDL_Palette,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set up a surface for directly accessing the pixels."]
    #[doc = ""]
    #[doc = " Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to"]
    #[doc = " and read from `surface->pixels`, using the pixel format stored in"]
    #[doc = " `surface->format`. Once you are done accessing the surface, you should use"]
    #[doc = " SDL_UnlockSurface() to release it."]
    #[doc = ""]
    #[doc = " Not all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to"]
    #[doc = " 0, then you can read and write to the surface at any time, and the pixel"]
    #[doc = " format of the surface will not change."]
    #[doc = ""]
    #[doc = " \\param surface the SDL_Surface structure to be locked"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_MUSTLOCK"]
    #[doc = " \\sa SDL_UnlockSurface"]
    pub fn SDL_LockSurface(surface: *mut SDL_Surface) -> libc::c_int;
}
extern "C" {
    #[doc = " Release a surface after directly accessing the pixels."]
    #[doc = ""]
    #[doc = " \\param surface the SDL_Surface structure to be unlocked"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_LockSurface"]
    pub fn SDL_UnlockSurface(surface: *mut SDL_Surface);
}
extern "C" {
    #[doc = " Load a BMP image from a seekable SDL data stream."]
    #[doc = ""]
    #[doc = " The new surface should be freed with SDL_FreeSurface(). Not doing so will"]
    #[doc = " result in a memory leak."]
    #[doc = ""]
    #[doc = " src is an open SDL_RWops buffer, typically loaded with SDL_RWFromFile."]
    #[doc = " Alternitavely, you might also use the macro SDL_LoadBMP to load a bitmap"]
    #[doc = " from a file, convert it to an SDL_Surface and then close the file."]
    #[doc = ""]
    #[doc = " \\param src the data stream for the surface"]
    #[doc = " \\param freesrc non-zero to close the stream after being read"]
    #[doc = " \\returns a pointer to a new SDL_Surface structure or NULL if there was an"]
    #[doc = "          error; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_FreeSurface"]
    #[doc = " \\sa SDL_RWFromFile"]
    #[doc = " \\sa SDL_LoadBMP"]
    #[doc = " \\sa SDL_SaveBMP_RW"]
    pub fn SDL_LoadBMP_RW(src: *mut SDL_RWops, freesrc: libc::c_int) -> *mut SDL_Surface;
}
extern "C" {
    #[doc = " Save a surface to a seekable SDL data stream in BMP format."]
    #[doc = ""]
    #[doc = " Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the"]
    #[doc = " BMP directly. Other RGB formats with 8-bit or higher get converted to a"]
    #[doc = " 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit"]
    #[doc = " surface before they are saved. YUV and paletted 1-bit and 4-bit formats are"]
    #[doc = " not supported."]
    #[doc = ""]
    #[doc = " \\param surface the SDL_Surface structure containing the image to be saved"]
    #[doc = " \\param dst a data stream to save to"]
    #[doc = " \\param freedst non-zero to close the stream after being written"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_LoadBMP_RW"]
    #[doc = " \\sa SDL_SaveBMP"]
    pub fn SDL_SaveBMP_RW(
        surface: *mut SDL_Surface,
        dst: *mut SDL_RWops,
        freedst: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the RLE acceleration hint for a surface."]
    #[doc = ""]
    #[doc = " If RLE is enabled, color key and alpha blending blits are much faster, but"]
    #[doc = " the surface must be locked before directly accessing the pixels."]
    #[doc = ""]
    #[doc = " \\param surface the SDL_Surface structure to optimize"]
    #[doc = " \\param flag 0 to disable, non-zero to enable RLE acceleration"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_BlitSurface"]
    #[doc = " \\sa SDL_LockSurface"]
    #[doc = " \\sa SDL_UnlockSurface"]
    pub fn SDL_SetSurfaceRLE(surface: *mut SDL_Surface, flag: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Returns whether the surface is RLE enabled"]
    #[doc = ""]
    #[doc = " It is safe to pass a NULL `surface` here; it will return SDL_FALSE."]
    #[doc = ""]
    #[doc = " \\param surface the SDL_Surface structure to query"]
    #[doc = " \\returns SDL_TRUE if the surface is RLE enabled, SDL_FALSE otherwise."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.14."]
    #[doc = ""]
    #[doc = " \\sa SDL_SetSurfaceRLE"]
    pub fn SDL_HasSurfaceRLE(surface: *mut SDL_Surface) -> SDL_bool;
}
extern "C" {
    #[doc = " Set the color key (transparent pixel) in a surface."]
    #[doc = ""]
    #[doc = " The color key defines a pixel value that will be treated as transparent in"]
    #[doc = " a blit. For example, one can use this to specify that cyan pixels should be"]
    #[doc = " considered transparent, and therefore not rendered."]
    #[doc = ""]
    #[doc = " It is a pixel of the format used by the surface, as generated by"]
    #[doc = " SDL_MapRGB()."]
    #[doc = ""]
    #[doc = " RLE acceleration can substantially speed up blitting of images with large"]
    #[doc = " horizontal runs of transparent pixels. See SDL_SetSurfaceRLE() for details."]
    #[doc = ""]
    #[doc = " \\param surface the SDL_Surface structure to update"]
    #[doc = " \\param flag SDL_TRUE to enable color key, SDL_FALSE to disable color key"]
    #[doc = " \\param key the transparent pixel"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_BlitSurface"]
    #[doc = " \\sa SDL_GetColorKey"]
    pub fn SDL_SetColorKey(
        surface: *mut SDL_Surface,
        flag: libc::c_int,
        key: Uint32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Returns whether the surface has a color key"]
    #[doc = ""]
    #[doc = " It is safe to pass a NULL `surface` here; it will return SDL_FALSE."]
    #[doc = ""]
    #[doc = " \\param surface the SDL_Surface structure to query"]
    #[doc = " \\return SDL_TRUE if the surface has a color key, SDL_FALSE otherwise."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.9."]
    #[doc = ""]
    #[doc = " \\sa SDL_SetColorKey"]
    #[doc = " \\sa SDL_GetColorKey"]
    pub fn SDL_HasColorKey(surface: *mut SDL_Surface) -> SDL_bool;
}
extern "C" {
    #[doc = " Get the color key (transparent pixel) for a surface."]
    #[doc = ""]
    #[doc = " The color key is a pixel of the format used by the surface, as generated by"]
    #[doc = " SDL_MapRGB()."]
    #[doc = ""]
    #[doc = " If the surface doesn't have color key enabled this function returns -1."]
    #[doc = ""]
    #[doc = " \\param surface the SDL_Surface structure to query"]
    #[doc = " \\param key a pointer filled in with the transparent pixel"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_BlitSurface"]
    #[doc = " \\sa SDL_SetColorKey"]
    pub fn SDL_GetColorKey(surface: *mut SDL_Surface, key: *mut Uint32) -> libc::c_int;
}
extern "C" {
    #[doc = " Set an additional color value multiplied into blit operations."]
    #[doc = ""]
    #[doc = " When this surface is blitted, during the blit operation each source color"]
    #[doc = " channel is modulated by the appropriate color value according to the"]
    #[doc = " following formula:"]
    #[doc = ""]
    #[doc = " `srcC = srcC * (color / 255)`"]
    #[doc = ""]
    #[doc = " \\param surface the SDL_Surface structure to update"]
    #[doc = " \\param r the red color value multiplied into blit operations"]
    #[doc = " \\param g the green color value multiplied into blit operations"]
    #[doc = " \\param b the blue color value multiplied into blit operations"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetSurfaceColorMod"]
    #[doc = " \\sa SDL_SetSurfaceAlphaMod"]
    pub fn SDL_SetSurfaceColorMod(
        surface: *mut SDL_Surface,
        r: Uint8,
        g: Uint8,
        b: Uint8,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the additional color value multiplied into blit operations."]
    #[doc = ""]
    #[doc = " \\param surface the SDL_Surface structure to query"]
    #[doc = " \\param r a pointer filled in with the current red color value"]
    #[doc = " \\param g a pointer filled in with the current green color value"]
    #[doc = " \\param b a pointer filled in with the current blue color value"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetSurfaceAlphaMod"]
    #[doc = " \\sa SDL_SetSurfaceColorMod"]
    pub fn SDL_GetSurfaceColorMod(
        surface: *mut SDL_Surface,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set an additional alpha value used in blit operations."]
    #[doc = ""]
    #[doc = " When this surface is blitted, during the blit operation the source alpha"]
    #[doc = " value is modulated by this alpha value according to the following formula:"]
    #[doc = ""]
    #[doc = " `srcA = srcA * (alpha / 255)`"]
    #[doc = ""]
    #[doc = " \\param surface the SDL_Surface structure to update"]
    #[doc = " \\param alpha the alpha value multiplied into blit operations"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetSurfaceAlphaMod"]
    #[doc = " \\sa SDL_SetSurfaceColorMod"]
    pub fn SDL_SetSurfaceAlphaMod(surface: *mut SDL_Surface, alpha: Uint8) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the additional alpha value used in blit operations."]
    #[doc = ""]
    #[doc = " \\param surface the SDL_Surface structure to query"]
    #[doc = " \\param alpha a pointer filled in with the current alpha value"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetSurfaceColorMod"]
    #[doc = " \\sa SDL_SetSurfaceAlphaMod"]
    pub fn SDL_GetSurfaceAlphaMod(surface: *mut SDL_Surface, alpha: *mut Uint8) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the blend mode used for blit operations."]
    #[doc = ""]
    #[doc = " To copy a surface to another surface (or texture) without blending with the"]
    #[doc = " existing data, the blendmode of the SOURCE surface should be set to"]
    #[doc = " `SDL_BLENDMODE_NONE`."]
    #[doc = ""]
    #[doc = " \\param surface the SDL_Surface structure to update"]
    #[doc = " \\param blendMode the SDL_BlendMode to use for blit blending"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetSurfaceBlendMode"]
    pub fn SDL_SetSurfaceBlendMode(
        surface: *mut SDL_Surface,
        blendMode: SDL_BlendMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the blend mode used for blit operations."]
    #[doc = ""]
    #[doc = " \\param surface the SDL_Surface structure to query"]
    #[doc = " \\param blendMode a pointer filled in with the current SDL_BlendMode"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_SetSurfaceBlendMode"]
    pub fn SDL_GetSurfaceBlendMode(
        surface: *mut SDL_Surface,
        blendMode: *mut SDL_BlendMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the clipping rectangle for a surface."]
    #[doc = ""]
    #[doc = " When `surface` is the destination of a blit, only the area within the clip"]
    #[doc = " rectangle is drawn into."]
    #[doc = ""]
    #[doc = " Note that blits are automatically clipped to the edges of the source and"]
    #[doc = " destination surfaces."]
    #[doc = ""]
    #[doc = " \\param surface the SDL_Surface structure to be clipped"]
    #[doc = " \\param rect the SDL_Rect structure representing the clipping rectangle, or"]
    #[doc = "             NULL to disable clipping"]
    #[doc = " \\returns SDL_TRUE if the rectangle intersects the surface, otherwise"]
    #[doc = "          SDL_FALSE and blits will be completely clipped."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_BlitSurface"]
    #[doc = " \\sa SDL_GetClipRect"]
    pub fn SDL_SetClipRect(surface: *mut SDL_Surface, rect: *const SDL_Rect) -> SDL_bool;
}
extern "C" {
    #[doc = " Get the clipping rectangle for a surface."]
    #[doc = ""]
    #[doc = " When `surface` is the destination of a blit, only the area within the clip"]
    #[doc = " rectangle is drawn into."]
    #[doc = ""]
    #[doc = " \\param surface the SDL_Surface structure representing the surface to be"]
    #[doc = "                clipped"]
    #[doc = " \\param rect an SDL_Rect structure filled in with the clipping rectangle for"]
    #[doc = "             the surface"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_BlitSurface"]
    #[doc = " \\sa SDL_SetClipRect"]
    pub fn SDL_GetClipRect(surface: *mut SDL_Surface, rect: *mut SDL_Rect);
}
extern "C" {
    pub fn SDL_DuplicateSurface(surface: *mut SDL_Surface) -> *mut SDL_Surface;
}
extern "C" {
    #[doc = " Copy an existing surface to a new surface of the specified format."]
    #[doc = ""]
    #[doc = " This function is used to optimize images for faster *repeat* blitting. This"]
    #[doc = " is accomplished by converting the original and storing the result as a new"]
    #[doc = " surface. The new, optimized surface can then be used as the source for"]
    #[doc = " future blits, making them faster."]
    #[doc = ""]
    #[doc = " \\param src the existing SDL_Surface structure to convert"]
    #[doc = " \\param fmt the SDL_PixelFormat structure that the new surface is optimized"]
    #[doc = "            for"]
    #[doc = " \\param flags the flags are unused and should be set to 0; this is a"]
    #[doc = "              leftover from SDL 1.2's API"]
    #[doc = " \\returns the new SDL_Surface structure that is created or NULL if it fails;"]
    #[doc = "          call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_AllocFormat"]
    #[doc = " \\sa SDL_ConvertSurfaceFormat"]
    #[doc = " \\sa SDL_CreateRGBSurface"]
    pub fn SDL_ConvertSurface(
        src: *mut SDL_Surface,
        fmt: *const SDL_PixelFormat,
        flags: Uint32,
    ) -> *mut SDL_Surface;
}
extern "C" {
    #[doc = " Copy an existing surface to a new surface of the specified format enum."]
    #[doc = ""]
    #[doc = " This function operates just like SDL_ConvertSurface(), but accepts an"]
    #[doc = " SDL_PixelFormatEnum value instead of an SDL_PixelFormat structure. As such,"]
    #[doc = " it might be easier to call but it doesn't have access to palette"]
    #[doc = " information for the destination surface, in case that would be important."]
    #[doc = ""]
    #[doc = " \\param src the existing SDL_Surface structure to convert"]
    #[doc = " \\param pixel_format the SDL_PixelFormatEnum that the new surface is"]
    #[doc = "                     optimized for"]
    #[doc = " \\param flags the flags are unused and should be set to 0; this is a"]
    #[doc = "              leftover from SDL 1.2's API"]
    #[doc = " \\returns the new SDL_Surface structure that is created or NULL if it fails;"]
    #[doc = "          call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_AllocFormat"]
    #[doc = " \\sa SDL_ConvertSurface"]
    #[doc = " \\sa SDL_CreateRGBSurface"]
    pub fn SDL_ConvertSurfaceFormat(
        src: *mut SDL_Surface,
        pixel_format: Uint32,
        flags: Uint32,
    ) -> *mut SDL_Surface;
}
extern "C" {
    #[doc = " Copy a block of pixels of one format to another format."]
    #[doc = ""]
    #[doc = " \\param width the width of the block to copy, in pixels"]
    #[doc = " \\param height the height of the block to copy, in pixels"]
    #[doc = " \\param src_format an SDL_PixelFormatEnum value of the `src` pixels format"]
    #[doc = " \\param src a pointer to the source pixels"]
    #[doc = " \\param src_pitch the pitch of the source pixels, in bytes"]
    #[doc = " \\param dst_format an SDL_PixelFormatEnum value of the `dst` pixels format"]
    #[doc = " \\param dst a pointer to be filled in with new pixel data"]
    #[doc = " \\param dst_pitch the pitch of the destination pixels, in bytes"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_ConvertPixels(
        width: libc::c_int,
        height: libc::c_int,
        src_format: Uint32,
        src: *const libc::c_void,
        src_pitch: libc::c_int,
        dst_format: Uint32,
        dst: *mut libc::c_void,
        dst_pitch: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Premultiply the alpha on a block of pixels."]
    #[doc = ""]
    #[doc = " This is safe to use with src == dst, but not for other overlapping areas."]
    #[doc = ""]
    #[doc = " This function is currently only implemented for SDL_PIXELFORMAT_ARGB8888."]
    #[doc = ""]
    #[doc = " \\param width the width of the block to convert, in pixels"]
    #[doc = " \\param height the height of the block to convert, in pixels"]
    #[doc = " \\param src_format an SDL_PixelFormatEnum value of the `src` pixels format"]
    #[doc = " \\param src a pointer to the source pixels"]
    #[doc = " \\param src_pitch the pitch of the source pixels, in bytes"]
    #[doc = " \\param dst_format an SDL_PixelFormatEnum value of the `dst` pixels format"]
    #[doc = " \\param dst a pointer to be filled in with premultiplied pixel data"]
    #[doc = " \\param dst_pitch the pitch of the destination pixels, in bytes"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    pub fn SDL_PremultiplyAlpha(
        width: libc::c_int,
        height: libc::c_int,
        src_format: Uint32,
        src: *const libc::c_void,
        src_pitch: libc::c_int,
        dst_format: Uint32,
        dst: *mut libc::c_void,
        dst_pitch: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Perform a fast fill of a rectangle with a specific color."]
    #[doc = ""]
    #[doc = " `color` should be a pixel of the format used by the surface, and can be"]
    #[doc = " generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an"]
    #[doc = " alpha component then the destination is simply filled with that alpha"]
    #[doc = " information, no blending takes place."]
    #[doc = ""]
    #[doc = " If there is a clip rectangle set on the destination (set via"]
    #[doc = " SDL_SetClipRect()), then this function will fill based on the intersection"]
    #[doc = " of the clip rectangle and `rect`."]
    #[doc = ""]
    #[doc = " \\param dst the SDL_Surface structure that is the drawing target"]
    #[doc = " \\param rect the SDL_Rect structure representing the rectangle to fill, or"]
    #[doc = "             NULL to fill the entire surface"]
    #[doc = " \\param color the color to fill with"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_FillRects"]
    pub fn SDL_FillRect(dst: *mut SDL_Surface, rect: *const SDL_Rect, color: Uint32)
        -> libc::c_int;
}
extern "C" {
    #[doc = " Perform a fast fill of a set of rectangles with a specific color."]
    #[doc = ""]
    #[doc = " `color` should be a pixel of the format used by the surface, and can be"]
    #[doc = " generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an"]
    #[doc = " alpha component then the destination is simply filled with that alpha"]
    #[doc = " information, no blending takes place."]
    #[doc = ""]
    #[doc = " If there is a clip rectangle set on the destination (set via"]
    #[doc = " SDL_SetClipRect()), then this function will fill based on the intersection"]
    #[doc = " of the clip rectangle and `rect`."]
    #[doc = ""]
    #[doc = " \\param dst the SDL_Surface structure that is the drawing target"]
    #[doc = " \\param rects an array of SDL_Rects representing the rectangles to fill."]
    #[doc = " \\param count the number of rectangles in the array"]
    #[doc = " \\param color the color to fill with"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_FillRect"]
    pub fn SDL_FillRects(
        dst: *mut SDL_Surface,
        rects: *const SDL_Rect,
        count: libc::c_int,
        color: Uint32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Perform a fast blit from the source surface to the destination surface."]
    #[doc = ""]
    #[doc = " SDL_UpperBlit() has been replaced by SDL_BlitSurface(), which is merely a"]
    #[doc = " macro for this function with a less confusing name."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_BlitSurface"]
    pub fn SDL_UpperBlit(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *mut SDL_Rect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Perform low-level surface blitting only."]
    #[doc = ""]
    #[doc = " This is a semi-private blit function and it performs low-level surface"]
    #[doc = " blitting, assuming the input rectangles have already been clipped."]
    #[doc = ""]
    #[doc = " Unless you know what you're doing, you should be using SDL_BlitSurface()"]
    #[doc = " instead."]
    #[doc = ""]
    #[doc = " \\param src the SDL_Surface structure to be copied from"]
    #[doc = " \\param srcrect the SDL_Rect structure representing the rectangle to be"]
    #[doc = "                copied, or NULL to copy the entire surface"]
    #[doc = " \\param dst the SDL_Surface structure that is the blit target"]
    #[doc = " \\param dstrect the SDL_Rect structure representing the rectangle that is"]
    #[doc = "                copied into"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_BlitSurface"]
    pub fn SDL_LowerBlit(
        src: *mut SDL_Surface,
        srcrect: *mut SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *mut SDL_Rect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Perform a fast, low quality, stretch blit between two surfaces of the same"]
    #[doc = " format."]
    #[doc = ""]
    #[doc = " Please use SDL_BlitScaled() instead."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_SoftStretch(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *const SDL_Rect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Perform bilinear scaling between two surfaces of the same format, 32BPP."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.16."]
    pub fn SDL_SoftStretchLinear(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *const SDL_Rect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Perform a scaled surface copy to a destination surface."]
    #[doc = ""]
    #[doc = " SDL_UpperBlitScaled() has been replaced by SDL_BlitScaled(), which is"]
    #[doc = " merely a macro for this function with a less confusing name."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_BlitScaled"]
    pub fn SDL_UpperBlitScaled(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *mut SDL_Rect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Perform low-level surface scaled blitting only."]
    #[doc = ""]
    #[doc = " This is a semi-private function and it performs low-level surface blitting,"]
    #[doc = " assuming the input rectangles have already been clipped."]
    #[doc = ""]
    #[doc = " \\param src the SDL_Surface structure to be copied from"]
    #[doc = " \\param srcrect the SDL_Rect structure representing the rectangle to be"]
    #[doc = "                copied"]
    #[doc = " \\param dst the SDL_Surface structure that is the blit target"]
    #[doc = " \\param dstrect the SDL_Rect structure representing the rectangle that is"]
    #[doc = "                copied into"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_BlitScaled"]
    pub fn SDL_LowerBlitScaled(
        src: *mut SDL_Surface,
        srcrect: *mut SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *mut SDL_Rect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the YUV conversion mode"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.8."]
    pub fn SDL_SetYUVConversionMode(mode: SDL_YUV_CONVERSION_MODE);
}
extern "C" {
    #[doc = " Get the YUV conversion mode"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.8."]
    pub fn SDL_GetYUVConversionMode() -> SDL_YUV_CONVERSION_MODE;
}
extern "C" {
    #[doc = " Get the YUV conversion mode, returning the correct mode for the resolution"]
    #[doc = " when the current conversion mode is SDL_YUV_CONVERSION_AUTOMATIC"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.8."]
    pub fn SDL_GetYUVConversionModeForResolution(
        width: libc::c_int,
        height: libc::c_int,
    ) -> SDL_YUV_CONVERSION_MODE;
}
#[doc = "  \\brief  The structure that defines a display mode"]
#[doc = ""]
#[doc = "  \\sa SDL_GetNumDisplayModes()"]
#[doc = "  \\sa SDL_GetDisplayMode()"]
#[doc = "  \\sa SDL_GetDesktopDisplayMode()"]
#[doc = "  \\sa SDL_GetCurrentDisplayMode()"]
#[doc = "  \\sa SDL_GetClosestDisplayMode()"]
#[doc = "  \\sa SDL_SetWindowDisplayMode()"]
#[doc = "  \\sa SDL_GetWindowDisplayMode()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_DisplayMode {
    #[doc = "< pixel format"]
    pub format: Uint32,
    #[doc = "< width, in screen coordinates"]
    pub w: libc::c_int,
    #[doc = "< height, in screen coordinates"]
    pub h: libc::c_int,
    #[doc = "< refresh rate (or zero for unspecified)"]
    pub refresh_rate: libc::c_int,
    #[doc = "< driver-specific data, initialize to 0"]
    pub driverdata: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_SDL_DisplayMode() {
    assert_eq!(
        ::core::mem::size_of::<SDL_DisplayMode>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_DisplayMode))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_DisplayMode>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_DisplayMode))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_DisplayMode>())).format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayMode),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_DisplayMode>())).w as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayMode),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_DisplayMode>())).h as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayMode),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_DisplayMode>())).refresh_rate as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayMode),
            "::",
            stringify!(refresh_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_DisplayMode>())).driverdata as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayMode),
            "::",
            stringify!(driverdata)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Window {
    _unused: [u8; 0],
}
impl SDL_WindowFlags {
    pub const SDL_WINDOW_INPUT_GRABBED: SDL_WindowFlags = SDL_WindowFlags::SDL_WINDOW_MOUSE_GRABBED;
}
#[repr(u32)]
#[doc = "  \\brief The flags on a window"]
#[doc = ""]
#[doc = "  \\sa SDL_GetWindowFlags()"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_WindowFlags {
    #[doc = "< fullscreen window"]
    SDL_WINDOW_FULLSCREEN = 1,
    #[doc = "< window usable with OpenGL context"]
    SDL_WINDOW_OPENGL = 2,
    #[doc = "< window is visible"]
    SDL_WINDOW_SHOWN = 4,
    #[doc = "< window is not visible"]
    SDL_WINDOW_HIDDEN = 8,
    #[doc = "< no window decoration"]
    SDL_WINDOW_BORDERLESS = 16,
    #[doc = "< window can be resized"]
    SDL_WINDOW_RESIZABLE = 32,
    #[doc = "< window is minimized"]
    SDL_WINDOW_MINIMIZED = 64,
    #[doc = "< window is maximized"]
    SDL_WINDOW_MAXIMIZED = 128,
    #[doc = "< window has grabbed mouse input"]
    SDL_WINDOW_MOUSE_GRABBED = 256,
    #[doc = "< window has input focus"]
    SDL_WINDOW_INPUT_FOCUS = 512,
    #[doc = "< window has mouse focus"]
    SDL_WINDOW_MOUSE_FOCUS = 1024,
    SDL_WINDOW_FULLSCREEN_DESKTOP = 4097,
    #[doc = "< window not created by SDL"]
    SDL_WINDOW_FOREIGN = 2048,
    #[doc = "< window should be created in high-DPI mode if supported."]
    #[doc = "On macOS NSHighResolutionCapable must be set true in the"]
    #[doc = "application's Info.plist for this to have any effect."]
    SDL_WINDOW_ALLOW_HIGHDPI = 8192,
    #[doc = "< window has mouse captured (unrelated to MOUSE_GRABBED)"]
    SDL_WINDOW_MOUSE_CAPTURE = 16384,
    #[doc = "< window should always be above others"]
    SDL_WINDOW_ALWAYS_ON_TOP = 32768,
    #[doc = "< window should not be added to the taskbar"]
    SDL_WINDOW_SKIP_TASKBAR = 65536,
    #[doc = "< window should be treated as a utility window"]
    SDL_WINDOW_UTILITY = 131072,
    #[doc = "< window should be treated as a tooltip"]
    SDL_WINDOW_TOOLTIP = 262144,
    #[doc = "< window should be treated as a popup menu"]
    SDL_WINDOW_POPUP_MENU = 524288,
    #[doc = "< window has grabbed keyboard input"]
    SDL_WINDOW_KEYBOARD_GRABBED = 1048576,
    #[doc = "< window usable for Vulkan surface"]
    SDL_WINDOW_VULKAN = 268435456,
    #[doc = "< window usable for Metal view"]
    SDL_WINDOW_METAL = 536870912,
}
#[repr(u32)]
#[doc = "  \\brief Event subtype for window events"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_WindowEventID {
    #[doc = "< Never used"]
    SDL_WINDOWEVENT_NONE = 0,
    #[doc = "< Window has been shown"]
    SDL_WINDOWEVENT_SHOWN = 1,
    #[doc = "< Window has been hidden"]
    SDL_WINDOWEVENT_HIDDEN = 2,
    #[doc = "< Window has been exposed and should be"]
    #[doc = "redrawn"]
    SDL_WINDOWEVENT_EXPOSED = 3,
    #[doc = "< Window has been moved to data1, data2"]
    SDL_WINDOWEVENT_MOVED = 4,
    #[doc = "< Window has been resized to data1xdata2"]
    SDL_WINDOWEVENT_RESIZED = 5,
    #[doc = "< The window size has changed, either as"]
    #[doc = "a result of an API call or through the"]
    #[doc = "system or user changing the window size."]
    SDL_WINDOWEVENT_SIZE_CHANGED = 6,
    #[doc = "< Window has been minimized"]
    SDL_WINDOWEVENT_MINIMIZED = 7,
    #[doc = "< Window has been maximized"]
    SDL_WINDOWEVENT_MAXIMIZED = 8,
    #[doc = "< Window has been restored to normal size"]
    #[doc = "and position"]
    SDL_WINDOWEVENT_RESTORED = 9,
    #[doc = "< Window has gained mouse focus"]
    SDL_WINDOWEVENT_ENTER = 10,
    #[doc = "< Window has lost mouse focus"]
    SDL_WINDOWEVENT_LEAVE = 11,
    #[doc = "< Window has gained keyboard focus"]
    SDL_WINDOWEVENT_FOCUS_GAINED = 12,
    #[doc = "< Window has lost keyboard focus"]
    SDL_WINDOWEVENT_FOCUS_LOST = 13,
    #[doc = "< The window manager requests that the window be closed"]
    SDL_WINDOWEVENT_CLOSE = 14,
    #[doc = "< Window is being offered a focus (should SetWindowInputFocus() on itself or a subwindow, or ignore)"]
    SDL_WINDOWEVENT_TAKE_FOCUS = 15,
    #[doc = "< Window had a hit test that wasn't SDL_HITTEST_NORMAL."]
    SDL_WINDOWEVENT_HIT_TEST = 16,
    #[doc = "< The ICC profile of the window's display has changed."]
    SDL_WINDOWEVENT_ICCPROF_CHANGED = 17,
    #[doc = "< Window has been moved to display data1."]
    SDL_WINDOWEVENT_DISPLAY_CHANGED = 18,
}
#[repr(u32)]
#[doc = "  \\brief Event subtype for display events"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_DisplayEventID {
    #[doc = "< Never used"]
    SDL_DISPLAYEVENT_NONE = 0,
    #[doc = "< Display orientation has changed to data1"]
    SDL_DISPLAYEVENT_ORIENTATION = 1,
    #[doc = "< Display has been added to the system"]
    SDL_DISPLAYEVENT_CONNECTED = 2,
    #[doc = "< Display has been removed from the system"]
    SDL_DISPLAYEVENT_DISCONNECTED = 3,
}
#[repr(u32)]
#[doc = "  \\brief Display orientation"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_DisplayOrientation {
    #[doc = "< The display orientation can't be determined"]
    SDL_ORIENTATION_UNKNOWN = 0,
    #[doc = "< The display is in landscape mode, with the right side up, relative to portrait mode"]
    SDL_ORIENTATION_LANDSCAPE = 1,
    #[doc = "< The display is in landscape mode, with the left side up, relative to portrait mode"]
    SDL_ORIENTATION_LANDSCAPE_FLIPPED = 2,
    #[doc = "< The display is in portrait mode"]
    SDL_ORIENTATION_PORTRAIT = 3,
    #[doc = "< The display is in portrait mode, upside down"]
    SDL_ORIENTATION_PORTRAIT_FLIPPED = 4,
}
#[repr(u32)]
#[doc = "  \\brief Window flash operation"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_FlashOperation {
    #[doc = "< Cancel any window flash state"]
    SDL_FLASH_CANCEL = 0,
    #[doc = "< Flash the window briefly to get attention"]
    SDL_FLASH_BRIEFLY = 1,
    #[doc = "< Flash the window until it gets focus"]
    SDL_FLASH_UNTIL_FOCUSED = 2,
}
#[doc = "  \\brief An opaque handle to an OpenGL context."]
pub type SDL_GLContext = *mut libc::c_void;
#[repr(u32)]
#[doc = "  \\brief OpenGL configuration attributes"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_GLattr {
    SDL_GL_RED_SIZE = 0,
    SDL_GL_GREEN_SIZE = 1,
    SDL_GL_BLUE_SIZE = 2,
    SDL_GL_ALPHA_SIZE = 3,
    SDL_GL_BUFFER_SIZE = 4,
    SDL_GL_DOUBLEBUFFER = 5,
    SDL_GL_DEPTH_SIZE = 6,
    SDL_GL_STENCIL_SIZE = 7,
    SDL_GL_ACCUM_RED_SIZE = 8,
    SDL_GL_ACCUM_GREEN_SIZE = 9,
    SDL_GL_ACCUM_BLUE_SIZE = 10,
    SDL_GL_ACCUM_ALPHA_SIZE = 11,
    SDL_GL_STEREO = 12,
    SDL_GL_MULTISAMPLEBUFFERS = 13,
    SDL_GL_MULTISAMPLESAMPLES = 14,
    SDL_GL_ACCELERATED_VISUAL = 15,
    SDL_GL_RETAINED_BACKING = 16,
    SDL_GL_CONTEXT_MAJOR_VERSION = 17,
    SDL_GL_CONTEXT_MINOR_VERSION = 18,
    SDL_GL_CONTEXT_EGL = 19,
    SDL_GL_CONTEXT_FLAGS = 20,
    SDL_GL_CONTEXT_PROFILE_MASK = 21,
    SDL_GL_SHARE_WITH_CURRENT_CONTEXT = 22,
    SDL_GL_FRAMEBUFFER_SRGB_CAPABLE = 23,
    SDL_GL_CONTEXT_RELEASE_BEHAVIOR = 24,
    SDL_GL_CONTEXT_RESET_NOTIFICATION = 25,
    SDL_GL_CONTEXT_NO_ERROR = 26,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_GLprofile {
    SDL_GL_CONTEXT_PROFILE_CORE = 1,
    SDL_GL_CONTEXT_PROFILE_COMPATIBILITY = 2,
    #[doc = "< GLX_CONTEXT_ES2_PROFILE_BIT_EXT"]
    SDL_GL_CONTEXT_PROFILE_ES = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_GLcontextFlag {
    SDL_GL_CONTEXT_DEBUG_FLAG = 1,
    SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG = 2,
    SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG = 4,
    SDL_GL_CONTEXT_RESET_ISOLATION_FLAG = 8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_GLcontextReleaseFlag {
    SDL_GL_CONTEXT_RELEASE_BEHAVIOR_NONE = 0,
    SDL_GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_GLContextResetNotification {
    SDL_GL_CONTEXT_RESET_NO_NOTIFICATION = 0,
    SDL_GL_CONTEXT_RESET_LOSE_CONTEXT = 1,
}
extern "C" {
    #[doc = " Get the number of video drivers compiled into SDL."]
    #[doc = ""]
    #[doc = " \\returns a number >= 1 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetVideoDriver"]
    pub fn SDL_GetNumVideoDrivers() -> libc::c_int;
}
extern "C" {
    #[doc = " Get the name of a built in video driver."]
    #[doc = ""]
    #[doc = " The video drivers are presented in the order in which they are normally"]
    #[doc = " checked during initialization."]
    #[doc = ""]
    #[doc = " \\param index the index of a video driver"]
    #[doc = " \\returns the name of the video driver with the given **index**."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetNumVideoDrivers"]
    pub fn SDL_GetVideoDriver(index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Initialize the video subsystem, optionally specifying a video driver."]
    #[doc = ""]
    #[doc = " This function initializes the video subsystem, setting up a connection to"]
    #[doc = " the window manager, etc, and determines the available display modes and"]
    #[doc = " pixel formats, but does not initialize a window or graphics mode."]
    #[doc = ""]
    #[doc = " If you use this function and you haven't used the SDL_INIT_VIDEO flag with"]
    #[doc = " either SDL_Init() or SDL_InitSubSystem(), you should call SDL_VideoQuit()"]
    #[doc = " before calling SDL_Quit()."]
    #[doc = ""]
    #[doc = " It is safe to call this function multiple times. SDL_VideoInit() will call"]
    #[doc = " SDL_VideoQuit() itself if the video subsystem has already been initialized."]
    #[doc = ""]
    #[doc = " You can use SDL_GetNumVideoDrivers() and SDL_GetVideoDriver() to find a"]
    #[doc = " specific `driver_name`."]
    #[doc = ""]
    #[doc = " \\param driver_name the name of a video driver to initialize, or NULL for"]
    #[doc = "                    the default driver"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetNumVideoDrivers"]
    #[doc = " \\sa SDL_GetVideoDriver"]
    #[doc = " \\sa SDL_InitSubSystem"]
    #[doc = " \\sa SDL_VideoQuit"]
    pub fn SDL_VideoInit(driver_name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Shut down the video subsystem, if initialized with SDL_VideoInit()."]
    #[doc = ""]
    #[doc = " This function closes all windows, and restores the original video mode."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_VideoInit"]
    pub fn SDL_VideoQuit();
}
extern "C" {
    #[doc = " Get the name of the currently initialized video driver."]
    #[doc = ""]
    #[doc = " \\returns the name of the current video driver or NULL if no driver has been"]
    #[doc = "          initialized."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetNumVideoDrivers"]
    #[doc = " \\sa SDL_GetVideoDriver"]
    pub fn SDL_GetCurrentVideoDriver() -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the number of available video displays."]
    #[doc = ""]
    #[doc = " \\returns a number >= 1 or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetDisplayBounds"]
    pub fn SDL_GetNumVideoDisplays() -> libc::c_int;
}
extern "C" {
    #[doc = " Get the name of a display in UTF-8 encoding."]
    #[doc = ""]
    #[doc = " \\param displayIndex the index of display from which the name should be"]
    #[doc = "                     queried"]
    #[doc = " \\returns the name of a display or NULL for an invalid display index or"]
    #[doc = "          failure; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetNumVideoDisplays"]
    pub fn SDL_GetDisplayName(displayIndex: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the desktop area represented by a display."]
    #[doc = ""]
    #[doc = " The primary display (`displayIndex` zero) is always located at 0,0."]
    #[doc = ""]
    #[doc = " \\param displayIndex the index of the display to query"]
    #[doc = " \\param rect the SDL_Rect structure filled in with the display bounds"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetNumVideoDisplays"]
    pub fn SDL_GetDisplayBounds(displayIndex: libc::c_int, rect: *mut SDL_Rect) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the usable desktop area represented by a display."]
    #[doc = ""]
    #[doc = " The primary display (`displayIndex` zero) is always located at 0,0."]
    #[doc = ""]
    #[doc = " This is the same area as SDL_GetDisplayBounds() reports, but with portions"]
    #[doc = " reserved by the system removed. For example, on Apple's macOS, this"]
    #[doc = " subtracts the area occupied by the menu bar and dock."]
    #[doc = ""]
    #[doc = " Setting a window to be fullscreen generally bypasses these unusable areas,"]
    #[doc = " so these are good guidelines for the maximum space available to a"]
    #[doc = " non-fullscreen window."]
    #[doc = ""]
    #[doc = " The parameter `rect` is ignored if it is NULL."]
    #[doc = ""]
    #[doc = " This function also returns -1 if the parameter `displayIndex` is out of"]
    #[doc = " range."]
    #[doc = ""]
    #[doc = " \\param displayIndex the index of the display to query the usable bounds"]
    #[doc = "                     from"]
    #[doc = " \\param rect the SDL_Rect structure filled in with the display bounds"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.5."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetDisplayBounds"]
    #[doc = " \\sa SDL_GetNumVideoDisplays"]
    pub fn SDL_GetDisplayUsableBounds(
        displayIndex: libc::c_int,
        rect: *mut SDL_Rect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the dots/pixels-per-inch for a display."]
    #[doc = ""]
    #[doc = " Diagonal, horizontal and vertical DPI can all be optionally returned if the"]
    #[doc = " appropriate parameter is non-NULL."]
    #[doc = ""]
    #[doc = " A failure of this function usually means that either no DPI information is"]
    #[doc = " available or the `displayIndex` is out of range."]
    #[doc = ""]
    #[doc = " \\param displayIndex the index of the display from which DPI information"]
    #[doc = "                     should be queried"]
    #[doc = " \\param ddpi a pointer filled in with the diagonal DPI of the display; may"]
    #[doc = "             be NULL"]
    #[doc = " \\param hdpi a pointer filled in with the horizontal DPI of the display; may"]
    #[doc = "             be NULL"]
    #[doc = " \\param vdpi a pointer filled in with the vertical DPI of the display; may"]
    #[doc = "             be NULL"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.4."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetNumVideoDisplays"]
    pub fn SDL_GetDisplayDPI(
        displayIndex: libc::c_int,
        ddpi: *mut f32,
        hdpi: *mut f32,
        vdpi: *mut f32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the orientation of a display."]
    #[doc = ""]
    #[doc = " \\param displayIndex the index of the display to query"]
    #[doc = " \\returns The SDL_DisplayOrientation enum value of the display, or"]
    #[doc = "          `SDL_ORIENTATION_UNKNOWN` if it isn't available."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.9."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetNumVideoDisplays"]
    pub fn SDL_GetDisplayOrientation(displayIndex: libc::c_int) -> SDL_DisplayOrientation;
}
extern "C" {
    #[doc = " Get the number of available display modes."]
    #[doc = ""]
    #[doc = " The `displayIndex` needs to be in the range from 0 to"]
    #[doc = " SDL_GetNumVideoDisplays() - 1."]
    #[doc = ""]
    #[doc = " \\param displayIndex the index of the display to query"]
    #[doc = " \\returns a number >= 1 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetDisplayMode"]
    #[doc = " \\sa SDL_GetNumVideoDisplays"]
    pub fn SDL_GetNumDisplayModes(displayIndex: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Get information about a specific display mode."]
    #[doc = ""]
    #[doc = " The display modes are sorted in this priority:"]
    #[doc = ""]
    #[doc = " - width -> largest to smallest"]
    #[doc = " - height -> largest to smallest"]
    #[doc = " - bits per pixel -> more colors to fewer colors"]
    #[doc = " - packed pixel layout -> largest to smallest"]
    #[doc = " - refresh rate -> highest to lowest"]
    #[doc = ""]
    #[doc = " \\param displayIndex the index of the display to query"]
    #[doc = " \\param modeIndex the index of the display mode to query"]
    #[doc = " \\param mode an SDL_DisplayMode structure filled in with the mode at"]
    #[doc = "             `modeIndex`"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetNumDisplayModes"]
    pub fn SDL_GetDisplayMode(
        displayIndex: libc::c_int,
        modeIndex: libc::c_int,
        mode: *mut SDL_DisplayMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get information about the desktop's display mode."]
    #[doc = ""]
    #[doc = " There's a difference between this function and SDL_GetCurrentDisplayMode()"]
    #[doc = " when SDL runs fullscreen and has changed the resolution. In that case this"]
    #[doc = " function will return the previous native display mode, and not the current"]
    #[doc = " display mode."]
    #[doc = ""]
    #[doc = " \\param displayIndex the index of the display to query"]
    #[doc = " \\param mode an SDL_DisplayMode structure filled in with the current display"]
    #[doc = "             mode"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetCurrentDisplayMode"]
    #[doc = " \\sa SDL_GetDisplayMode"]
    #[doc = " \\sa SDL_SetWindowDisplayMode"]
    pub fn SDL_GetDesktopDisplayMode(
        displayIndex: libc::c_int,
        mode: *mut SDL_DisplayMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get information about the current display mode."]
    #[doc = ""]
    #[doc = " There's a difference between this function and SDL_GetDesktopDisplayMode()"]
    #[doc = " when SDL runs fullscreen and has changed the resolution. In that case this"]
    #[doc = " function will return the current display mode, and not the previous native"]
    #[doc = " display mode."]
    #[doc = ""]
    #[doc = " \\param displayIndex the index of the display to query"]
    #[doc = " \\param mode an SDL_DisplayMode structure filled in with the current display"]
    #[doc = "             mode"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetDesktopDisplayMode"]
    #[doc = " \\sa SDL_GetDisplayMode"]
    #[doc = " \\sa SDL_GetNumVideoDisplays"]
    #[doc = " \\sa SDL_SetWindowDisplayMode"]
    pub fn SDL_GetCurrentDisplayMode(
        displayIndex: libc::c_int,
        mode: *mut SDL_DisplayMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the closest match to the requested display mode."]
    #[doc = ""]
    #[doc = " The available display modes are scanned and `closest` is filled in with the"]
    #[doc = " closest mode matching the requested mode and returned. The mode format and"]
    #[doc = " refresh rate default to the desktop mode if they are set to 0. The modes"]
    #[doc = " are scanned with size being first priority, format being second priority,"]
    #[doc = " and finally checking the refresh rate. If all the available modes are too"]
    #[doc = " small, then NULL is returned."]
    #[doc = ""]
    #[doc = " \\param displayIndex the index of the display to query"]
    #[doc = " \\param mode an SDL_DisplayMode structure containing the desired display"]
    #[doc = "             mode"]
    #[doc = " \\param closest an SDL_DisplayMode structure filled in with the closest"]
    #[doc = "                match of the available display modes"]
    #[doc = " \\returns the passed in value `closest` or NULL if no matching video mode"]
    #[doc = "          was available; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetDisplayMode"]
    #[doc = " \\sa SDL_GetNumDisplayModes"]
    pub fn SDL_GetClosestDisplayMode(
        displayIndex: libc::c_int,
        mode: *const SDL_DisplayMode,
        closest: *mut SDL_DisplayMode,
    ) -> *mut SDL_DisplayMode;
}
extern "C" {
    #[doc = " Get the index of the display associated with a window."]
    #[doc = ""]
    #[doc = " \\param window the window to query"]
    #[doc = " \\returns the index of the display containing the center of the window on"]
    #[doc = "          success or a negative error code on failure; call SDL_GetError()"]
    #[doc = "          for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetDisplayBounds"]
    #[doc = " \\sa SDL_GetNumVideoDisplays"]
    pub fn SDL_GetWindowDisplayIndex(window: *mut SDL_Window) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the display mode to use when a window is visible at fullscreen."]
    #[doc = ""]
    #[doc = " This only affects the display mode used when the window is fullscreen. To"]
    #[doc = " change the window size when the window is not fullscreen, use"]
    #[doc = " SDL_SetWindowSize()."]
    #[doc = ""]
    #[doc = " \\param window the window to affect"]
    #[doc = " \\param mode the SDL_DisplayMode structure representing the mode to use, or"]
    #[doc = "             NULL to use the window's dimensions and the desktop's format"]
    #[doc = "             and refresh rate"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetWindowDisplayMode"]
    #[doc = " \\sa SDL_SetWindowFullscreen"]
    pub fn SDL_SetWindowDisplayMode(
        window: *mut SDL_Window,
        mode: *const SDL_DisplayMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Query the display mode to use when a window is visible at fullscreen."]
    #[doc = ""]
    #[doc = " \\param window the window to query"]
    #[doc = " \\param mode an SDL_DisplayMode structure filled in with the fullscreen"]
    #[doc = "             display mode"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_SetWindowDisplayMode"]
    #[doc = " \\sa SDL_SetWindowFullscreen"]
    pub fn SDL_GetWindowDisplayMode(
        window: *mut SDL_Window,
        mode: *mut SDL_DisplayMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the raw ICC profile data for the screen the window is currently on."]
    #[doc = ""]
    #[doc = " Data returned should be freed with SDL_free."]
    #[doc = ""]
    #[doc = " \\param window the window to query"]
    #[doc = " \\param size the size of the ICC profile"]
    #[doc = " \\returns the raw ICC profile data on success or NULL on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    pub fn SDL_GetWindowICCProfile(window: *mut SDL_Window, size: *mut size_t)
        -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Get the pixel format associated with the window."]
    #[doc = ""]
    #[doc = " \\param window the window to query"]
    #[doc = " \\returns the pixel format of the window on success or"]
    #[doc = "          SDL_PIXELFORMAT_UNKNOWN on failure; call SDL_GetError() for more"]
    #[doc = "          information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_GetWindowPixelFormat(window: *mut SDL_Window) -> Uint32;
}
extern "C" {
    #[doc = " Create a window with the specified position, dimensions, and flags."]
    #[doc = ""]
    #[doc = " `flags` may be any of the following OR'd together:"]
    #[doc = ""]
    #[doc = " - `SDL_WINDOW_FULLSCREEN`: fullscreen window"]
    #[doc = " - `SDL_WINDOW_FULLSCREEN_DESKTOP`: fullscreen window at desktop resolution"]
    #[doc = " - `SDL_WINDOW_OPENGL`: window usable with an OpenGL context"]
    #[doc = " - `SDL_WINDOW_VULKAN`: window usable with a Vulkan instance"]
    #[doc = " - `SDL_WINDOW_METAL`: window usable with a Metal instance"]
    #[doc = " - `SDL_WINDOW_HIDDEN`: window is not visible"]
    #[doc = " - `SDL_WINDOW_BORDERLESS`: no window decoration"]
    #[doc = " - `SDL_WINDOW_RESIZABLE`: window can be resized"]
    #[doc = " - `SDL_WINDOW_MINIMIZED`: window is minimized"]
    #[doc = " - `SDL_WINDOW_MAXIMIZED`: window is maximized"]
    #[doc = " - `SDL_WINDOW_INPUT_GRABBED`: window has grabbed input focus"]
    #[doc = " - `SDL_WINDOW_ALLOW_HIGHDPI`: window should be created in high-DPI mode if"]
    #[doc = "   supported (>= SDL 2.0.1)"]
    #[doc = ""]
    #[doc = " `SDL_WINDOW_SHOWN` is ignored by SDL_CreateWindow(). The SDL_Window is"]
    #[doc = " implicitly shown if SDL_WINDOW_HIDDEN is not set. `SDL_WINDOW_SHOWN` may be"]
    #[doc = " queried later using SDL_GetWindowFlags()."]
    #[doc = ""]
    #[doc = " On Apple's macOS, you **must** set the NSHighResolutionCapable Info.plist"]
    #[doc = " property to YES, otherwise you will not receive a High-DPI OpenGL canvas."]
    #[doc = ""]
    #[doc = " If the window is created with the `SDL_WINDOW_ALLOW_HIGHDPI` flag, its size"]
    #[doc = " in pixels may differ from its size in screen coordinates on platforms with"]
    #[doc = " high-DPI support (e.g. iOS and macOS). Use SDL_GetWindowSize() to query the"]
    #[doc = " client area's size in screen coordinates, and SDL_GL_GetDrawableSize() or"]
    #[doc = " SDL_GetRendererOutputSize() to query the drawable size in pixels."]
    #[doc = ""]
    #[doc = " If the window is set fullscreen, the width and height parameters `w` and"]
    #[doc = " `h` will not be used. However, invalid size parameters (e.g. too large) may"]
    #[doc = " still fail. Window size is actually limited to 16384 x 16384 for all"]
    #[doc = " platforms at window creation."]
    #[doc = ""]
    #[doc = " If the window is created with any of the SDL_WINDOW_OPENGL or"]
    #[doc = " SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function"]
    #[doc = " (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the"]
    #[doc = " corresponding UnloadLibrary function is called by SDL_DestroyWindow()."]
    #[doc = ""]
    #[doc = " If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,"]
    #[doc = " SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail."]
    #[doc = ""]
    #[doc = " If SDL_WINDOW_METAL is specified on an OS that does not support Metal,"]
    #[doc = " SDL_CreateWindow() will fail."]
    #[doc = ""]
    #[doc = " On non-Apple devices, SDL requires you to either not link to the Vulkan"]
    #[doc = " loader or link to a dynamic library version. This limitation may be removed"]
    #[doc = " in a future version of SDL."]
    #[doc = ""]
    #[doc = " \\param title the title of the window, in UTF-8 encoding"]
    #[doc = " \\param x the x position of the window, `SDL_WINDOWPOS_CENTERED`, or"]
    #[doc = "          `SDL_WINDOWPOS_UNDEFINED`"]
    #[doc = " \\param y the y position of the window, `SDL_WINDOWPOS_CENTERED`, or"]
    #[doc = "          `SDL_WINDOWPOS_UNDEFINED`"]
    #[doc = " \\param w the width of the window, in screen coordinates"]
    #[doc = " \\param h the height of the window, in screen coordinates"]
    #[doc = " \\param flags 0, or one or more SDL_WindowFlags OR'd together"]
    #[doc = " \\returns the window that was created or NULL on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateWindowFrom"]
    #[doc = " \\sa SDL_DestroyWindow"]
    pub fn SDL_CreateWindow(
        title: *const libc::c_char,
        x: libc::c_int,
        y: libc::c_int,
        w: libc::c_int,
        h: libc::c_int,
        flags: Uint32,
    ) -> *mut SDL_Window;
}
extern "C" {
    #[doc = " Create an SDL window from an existing native window."]
    #[doc = ""]
    #[doc = " In some cases (e.g. OpenGL) and on some platforms (e.g. Microsoft Windows)"]
    #[doc = " the hint `SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT` needs to be configured"]
    #[doc = " before using SDL_CreateWindowFrom()."]
    #[doc = ""]
    #[doc = " \\param data a pointer to driver-dependent window creation data, typically"]
    #[doc = "             your native window cast to a void*"]
    #[doc = " \\returns the window that was created or NULL on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateWindow"]
    #[doc = " \\sa SDL_DestroyWindow"]
    pub fn SDL_CreateWindowFrom(data: *const libc::c_void) -> *mut SDL_Window;
}
extern "C" {
    #[doc = " Get the numeric ID of a window."]
    #[doc = ""]
    #[doc = " The numeric ID is what SDL_WindowEvent references, and is necessary to map"]
    #[doc = " these events to specific SDL_Window objects."]
    #[doc = ""]
    #[doc = " \\param window the window to query"]
    #[doc = " \\returns the ID of the window on success or 0 on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetWindowFromID"]
    pub fn SDL_GetWindowID(window: *mut SDL_Window) -> Uint32;
}
extern "C" {
    #[doc = " Get a window from a stored ID."]
    #[doc = ""]
    #[doc = " The numeric ID is what SDL_WindowEvent references, and is necessary to map"]
    #[doc = " these events to specific SDL_Window objects."]
    #[doc = ""]
    #[doc = " \\param id the ID of the window"]
    #[doc = " \\returns the window associated with `id` or NULL if it doesn't exist; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetWindowID"]
    pub fn SDL_GetWindowFromID(id: Uint32) -> *mut SDL_Window;
}
extern "C" {
    #[doc = " Get the window flags."]
    #[doc = ""]
    #[doc = " \\param window the window to query"]
    #[doc = " \\returns a mask of the SDL_WindowFlags associated with `window`"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateWindow"]
    #[doc = " \\sa SDL_HideWindow"]
    #[doc = " \\sa SDL_MaximizeWindow"]
    #[doc = " \\sa SDL_MinimizeWindow"]
    #[doc = " \\sa SDL_SetWindowFullscreen"]
    #[doc = " \\sa SDL_SetWindowGrab"]
    #[doc = " \\sa SDL_ShowWindow"]
    pub fn SDL_GetWindowFlags(window: *mut SDL_Window) -> Uint32;
}
extern "C" {
    #[doc = " Set the title of a window."]
    #[doc = ""]
    #[doc = " This string is expected to be in UTF-8 encoding."]
    #[doc = ""]
    #[doc = " \\param window the window to change"]
    #[doc = " \\param title the desired window title in UTF-8 format"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetWindowTitle"]
    pub fn SDL_SetWindowTitle(window: *mut SDL_Window, title: *const libc::c_char);
}
extern "C" {
    #[doc = " Get the title of a window."]
    #[doc = ""]
    #[doc = " \\param window the window to query"]
    #[doc = " \\returns the title of the window in UTF-8 format or \"\" if there is no"]
    #[doc = "          title."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_SetWindowTitle"]
    pub fn SDL_GetWindowTitle(window: *mut SDL_Window) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Set the icon for a window."]
    #[doc = ""]
    #[doc = " \\param window the window to change"]
    #[doc = " \\param icon an SDL_Surface structure containing the icon for the window"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_SetWindowIcon(window: *mut SDL_Window, icon: *mut SDL_Surface);
}
extern "C" {
    #[doc = " Associate an arbitrary named pointer with a window."]
    #[doc = ""]
    #[doc = " `name` is case-sensitive."]
    #[doc = ""]
    #[doc = " \\param window the window to associate with the pointer"]
    #[doc = " \\param name the name of the pointer"]
    #[doc = " \\param userdata the associated pointer"]
    #[doc = " \\returns the previous value associated with `name`."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetWindowData"]
    pub fn SDL_SetWindowData(
        window: *mut SDL_Window,
        name: *const libc::c_char,
        userdata: *mut libc::c_void,
    ) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Retrieve the data pointer associated with a window."]
    #[doc = ""]
    #[doc = " \\param window the window to query"]
    #[doc = " \\param name the name of the pointer"]
    #[doc = " \\returns the value associated with `name`."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_SetWindowData"]
    pub fn SDL_GetWindowData(
        window: *mut SDL_Window,
        name: *const libc::c_char,
    ) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Set the position of a window."]
    #[doc = ""]
    #[doc = " The window coordinate origin is the upper left of the display."]
    #[doc = ""]
    #[doc = " \\param window the window to reposition"]
    #[doc = " \\param x the x coordinate of the window in screen coordinates, or"]
    #[doc = "          `SDL_WINDOWPOS_CENTERED` or `SDL_WINDOWPOS_UNDEFINED`"]
    #[doc = " \\param y the y coordinate of the window in screen coordinates, or"]
    #[doc = "          `SDL_WINDOWPOS_CENTERED` or `SDL_WINDOWPOS_UNDEFINED`"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetWindowPosition"]
    pub fn SDL_SetWindowPosition(window: *mut SDL_Window, x: libc::c_int, y: libc::c_int);
}
extern "C" {
    #[doc = " Get the position of a window."]
    #[doc = ""]
    #[doc = " If you do not need the value for one of the positions a NULL may be passed"]
    #[doc = " in the `x` or `y` parameter."]
    #[doc = ""]
    #[doc = " \\param window the window to query"]
    #[doc = " \\param x a pointer filled in with the x position of the window, in screen"]
    #[doc = "          coordinates, may be NULL"]
    #[doc = " \\param y a pointer filled in with the y position of the window, in screen"]
    #[doc = "          coordinates, may be NULL"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_SetWindowPosition"]
    pub fn SDL_GetWindowPosition(window: *mut SDL_Window, x: *mut libc::c_int, y: *mut libc::c_int);
}
extern "C" {
    #[doc = " Set the size of a window's client area."]
    #[doc = ""]
    #[doc = " The window size in screen coordinates may differ from the size in pixels,"]
    #[doc = " if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform"]
    #[doc = " with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize() or"]
    #[doc = " SDL_GetRendererOutputSize() to get the real client area size in pixels."]
    #[doc = ""]
    #[doc = " Fullscreen windows automatically match the size of the display mode, and"]
    #[doc = " you should use SDL_SetWindowDisplayMode() to change their size."]
    #[doc = ""]
    #[doc = " \\param window the window to change"]
    #[doc = " \\param w the width of the window in pixels, in screen coordinates, must be"]
    #[doc = "          > 0"]
    #[doc = " \\param h the height of the window in pixels, in screen coordinates, must be"]
    #[doc = "          > 0"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetWindowSize"]
    #[doc = " \\sa SDL_SetWindowDisplayMode"]
    pub fn SDL_SetWindowSize(window: *mut SDL_Window, w: libc::c_int, h: libc::c_int);
}
extern "C" {
    #[doc = " Get the size of a window's client area."]
    #[doc = ""]
    #[doc = " NULL can safely be passed as the `w` or `h` parameter if the width or"]
    #[doc = " height value is not desired."]
    #[doc = ""]
    #[doc = " The window size in screen coordinates may differ from the size in pixels,"]
    #[doc = " if the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a platform"]
    #[doc = " with high-dpi support (e.g. iOS or macOS). Use SDL_GL_GetDrawableSize(),"]
    #[doc = " SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to get the"]
    #[doc = " real client area size in pixels."]
    #[doc = ""]
    #[doc = " \\param window the window to query the width and height from"]
    #[doc = " \\param w a pointer filled in with the width of the window, in screen"]
    #[doc = "          coordinates, may be NULL"]
    #[doc = " \\param h a pointer filled in with the height of the window, in screen"]
    #[doc = "          coordinates, may be NULL"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GL_GetDrawableSize"]
    #[doc = " \\sa SDL_Vulkan_GetDrawableSize"]
    #[doc = " \\sa SDL_SetWindowSize"]
    pub fn SDL_GetWindowSize(window: *mut SDL_Window, w: *mut libc::c_int, h: *mut libc::c_int);
}
extern "C" {
    #[doc = " Get the size of a window's borders (decorations) around the client area."]
    #[doc = ""]
    #[doc = " Note: If this function fails (returns -1), the size values will be"]
    #[doc = " initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the"]
    #[doc = " window in question was borderless."]
    #[doc = ""]
    #[doc = " Note: This function may fail on systems where the window has not yet been"]
    #[doc = " decorated by the display server (for example, immediately after calling"]
    #[doc = " SDL_CreateWindow). It is recommended that you wait at least until the"]
    #[doc = " window has been presented and composited, so that the window system has a"]
    #[doc = " chance to decorate the window and provide the border dimensions to SDL."]
    #[doc = ""]
    #[doc = " This function also returns -1 if getting the information is not supported."]
    #[doc = ""]
    #[doc = " \\param window the window to query the size values of the border"]
    #[doc = "               (decorations) from"]
    #[doc = " \\param top pointer to variable for storing the size of the top border; NULL"]
    #[doc = "            is permitted"]
    #[doc = " \\param left pointer to variable for storing the size of the left border;"]
    #[doc = "             NULL is permitted"]
    #[doc = " \\param bottom pointer to variable for storing the size of the bottom"]
    #[doc = "               border; NULL is permitted"]
    #[doc = " \\param right pointer to variable for storing the size of the right border;"]
    #[doc = "              NULL is permitted"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.5."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetWindowSize"]
    pub fn SDL_GetWindowBordersSize(
        window: *mut SDL_Window,
        top: *mut libc::c_int,
        left: *mut libc::c_int,
        bottom: *mut libc::c_int,
        right: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the minimum size of a window's client area."]
    #[doc = ""]
    #[doc = " \\param window the window to change"]
    #[doc = " \\param min_w the minimum width of the window in pixels"]
    #[doc = " \\param min_h the minimum height of the window in pixels"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetWindowMinimumSize"]
    #[doc = " \\sa SDL_SetWindowMaximumSize"]
    pub fn SDL_SetWindowMinimumSize(
        window: *mut SDL_Window,
        min_w: libc::c_int,
        min_h: libc::c_int,
    );
}
extern "C" {
    #[doc = " Get the minimum size of a window's client area."]
    #[doc = ""]
    #[doc = " \\param window the window to query"]
    #[doc = " \\param w a pointer filled in with the minimum width of the window, may be"]
    #[doc = "          NULL"]
    #[doc = " \\param h a pointer filled in with the minimum height of the window, may be"]
    #[doc = "          NULL"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetWindowMaximumSize"]
    #[doc = " \\sa SDL_SetWindowMinimumSize"]
    pub fn SDL_GetWindowMinimumSize(
        window: *mut SDL_Window,
        w: *mut libc::c_int,
        h: *mut libc::c_int,
    );
}
extern "C" {
    #[doc = " Set the maximum size of a window's client area."]
    #[doc = ""]
    #[doc = " \\param window the window to change"]
    #[doc = " \\param max_w the maximum width of the window in pixels"]
    #[doc = " \\param max_h the maximum height of the window in pixels"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetWindowMaximumSize"]
    #[doc = " \\sa SDL_SetWindowMinimumSize"]
    pub fn SDL_SetWindowMaximumSize(
        window: *mut SDL_Window,
        max_w: libc::c_int,
        max_h: libc::c_int,
    );
}
extern "C" {
    #[doc = " Get the maximum size of a window's client area."]
    #[doc = ""]
    #[doc = " \\param window the window to query"]
    #[doc = " \\param w a pointer filled in with the maximum width of the window, may be"]
    #[doc = "          NULL"]
    #[doc = " \\param h a pointer filled in with the maximum height of the window, may be"]
    #[doc = "          NULL"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetWindowMinimumSize"]
    #[doc = " \\sa SDL_SetWindowMaximumSize"]
    pub fn SDL_GetWindowMaximumSize(
        window: *mut SDL_Window,
        w: *mut libc::c_int,
        h: *mut libc::c_int,
    );
}
extern "C" {
    #[doc = " Set the border state of a window."]
    #[doc = ""]
    #[doc = " This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add"]
    #[doc = " or remove the border from the actual window. This is a no-op if the"]
    #[doc = " window's border already matches the requested state."]
    #[doc = ""]
    #[doc = " You can't change the border state of a fullscreen window."]
    #[doc = ""]
    #[doc = " \\param window the window of which to change the border state"]
    #[doc = " \\param bordered SDL_FALSE to remove border, SDL_TRUE to add border"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetWindowFlags"]
    pub fn SDL_SetWindowBordered(window: *mut SDL_Window, bordered: SDL_bool);
}
extern "C" {
    #[doc = " Set the user-resizable state of a window."]
    #[doc = ""]
    #[doc = " This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and"]
    #[doc = " allow/disallow user resizing of the window. This is a no-op if the window's"]
    #[doc = " resizable state already matches the requested state."]
    #[doc = ""]
    #[doc = " You can't change the resizable state of a fullscreen window."]
    #[doc = ""]
    #[doc = " \\param window the window of which to change the resizable state"]
    #[doc = " \\param resizable SDL_TRUE to allow resizing, SDL_FALSE to disallow"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.5."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetWindowFlags"]
    pub fn SDL_SetWindowResizable(window: *mut SDL_Window, resizable: SDL_bool);
}
extern "C" {
    #[doc = " Set the window to always be above the others."]
    #[doc = ""]
    #[doc = " This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This"]
    #[doc = " will bring the window to the front and keep the window above the rest."]
    #[doc = ""]
    #[doc = " \\param window The window of which to change the always on top state"]
    #[doc = " \\param on_top SDL_TRUE to set the window always on top, SDL_FALSE to"]
    #[doc = "               disable"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.16."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetWindowFlags"]
    pub fn SDL_SetWindowAlwaysOnTop(window: *mut SDL_Window, on_top: SDL_bool);
}
extern "C" {
    #[doc = " Show a window."]
    #[doc = ""]
    #[doc = " \\param window the window to show"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HideWindow"]
    #[doc = " \\sa SDL_RaiseWindow"]
    pub fn SDL_ShowWindow(window: *mut SDL_Window);
}
extern "C" {
    #[doc = " Hide a window."]
    #[doc = ""]
    #[doc = " \\param window the window to hide"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_ShowWindow"]
    pub fn SDL_HideWindow(window: *mut SDL_Window);
}
extern "C" {
    #[doc = " Raise a window above other windows and set the input focus."]
    #[doc = ""]
    #[doc = " \\param window the window to raise"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_RaiseWindow(window: *mut SDL_Window);
}
extern "C" {
    #[doc = " Make a window as large as possible."]
    #[doc = ""]
    #[doc = " \\param window the window to maximize"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_MinimizeWindow"]
    #[doc = " \\sa SDL_RestoreWindow"]
    pub fn SDL_MaximizeWindow(window: *mut SDL_Window);
}
extern "C" {
    #[doc = " Minimize a window to an iconic representation."]
    #[doc = ""]
    #[doc = " \\param window the window to minimize"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_MaximizeWindow"]
    #[doc = " \\sa SDL_RestoreWindow"]
    pub fn SDL_MinimizeWindow(window: *mut SDL_Window);
}
extern "C" {
    #[doc = " Restore the size and position of a minimized or maximized window."]
    #[doc = ""]
    #[doc = " \\param window the window to restore"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_MaximizeWindow"]
    #[doc = " \\sa SDL_MinimizeWindow"]
    pub fn SDL_RestoreWindow(window: *mut SDL_Window);
}
extern "C" {
    #[doc = " Set a window's fullscreen state."]
    #[doc = ""]
    #[doc = " `flags` may be `SDL_WINDOW_FULLSCREEN`, for \"real\" fullscreen with a"]
    #[doc = " videomode change; `SDL_WINDOW_FULLSCREEN_DESKTOP` for \"fake\" fullscreen"]
    #[doc = " that takes the size of the desktop; and 0 for windowed mode."]
    #[doc = ""]
    #[doc = " \\param window the window to change"]
    #[doc = " \\param flags `SDL_WINDOW_FULLSCREEN`, `SDL_WINDOW_FULLSCREEN_DESKTOP` or 0"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetWindowDisplayMode"]
    #[doc = " \\sa SDL_SetWindowDisplayMode"]
    pub fn SDL_SetWindowFullscreen(window: *mut SDL_Window, flags: Uint32) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the SDL surface associated with the window."]
    #[doc = ""]
    #[doc = " A new surface will be created with the optimal format for the window, if"]
    #[doc = " necessary. This surface will be freed when the window is destroyed. Do not"]
    #[doc = " free this surface."]
    #[doc = ""]
    #[doc = " This surface will be invalidated if the window is resized. After resizing a"]
    #[doc = " window this function must be called again to return a valid surface."]
    #[doc = ""]
    #[doc = " You may not combine this with 3D or the rendering API on this window."]
    #[doc = ""]
    #[doc = " This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`."]
    #[doc = ""]
    #[doc = " \\param window the window to query"]
    #[doc = " \\returns the surface associated with the window, or NULL on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_UpdateWindowSurface"]
    #[doc = " \\sa SDL_UpdateWindowSurfaceRects"]
    pub fn SDL_GetWindowSurface(window: *mut SDL_Window) -> *mut SDL_Surface;
}
extern "C" {
    #[doc = " Copy the window surface to the screen."]
    #[doc = ""]
    #[doc = " This is the function you use to reflect any changes to the surface on the"]
    #[doc = " screen."]
    #[doc = ""]
    #[doc = " This function is equivalent to the SDL 1.2 API SDL_Flip()."]
    #[doc = ""]
    #[doc = " \\param window the window to update"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetWindowSurface"]
    #[doc = " \\sa SDL_UpdateWindowSurfaceRects"]
    pub fn SDL_UpdateWindowSurface(window: *mut SDL_Window) -> libc::c_int;
}
extern "C" {
    #[doc = " Copy areas of the window surface to the screen."]
    #[doc = ""]
    #[doc = " This is the function you use to reflect changes to portions of the surface"]
    #[doc = " on the screen."]
    #[doc = ""]
    #[doc = " This function is equivalent to the SDL 1.2 API SDL_UpdateRects()."]
    #[doc = ""]
    #[doc = " \\param window the window to update"]
    #[doc = " \\param rects an array of SDL_Rect structures representing areas of the"]
    #[doc = "              surface to copy"]
    #[doc = " \\param numrects the number of rectangles"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetWindowSurface"]
    #[doc = " \\sa SDL_UpdateWindowSurface"]
    pub fn SDL_UpdateWindowSurfaceRects(
        window: *mut SDL_Window,
        rects: *const SDL_Rect,
        numrects: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set a window's input grab mode."]
    #[doc = ""]
    #[doc = " When input is grabbed, the mouse is confined to the window. This function"]
    #[doc = " will also grab the keyboard if `SDL_HINT_GRAB_KEYBOARD` is set. To grab the"]
    #[doc = " keyboard without also grabbing the mouse, use SDL_SetWindowKeyboardGrab()."]
    #[doc = ""]
    #[doc = " If the caller enables a grab while another window is currently grabbed, the"]
    #[doc = " other window loses its grab in favor of the caller's window."]
    #[doc = ""]
    #[doc = " \\param window the window for which the input grab mode should be set"]
    #[doc = " \\param grabbed SDL_TRUE to grab input or SDL_FALSE to release input"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetGrabbedWindow"]
    #[doc = " \\sa SDL_GetWindowGrab"]
    pub fn SDL_SetWindowGrab(window: *mut SDL_Window, grabbed: SDL_bool);
}
extern "C" {
    #[doc = " Set a window's keyboard grab mode."]
    #[doc = ""]
    #[doc = " Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or"]
    #[doc = " the Meta/Super key. Note that not all system keyboard shortcuts can be"]
    #[doc = " captured by applications (one example is Ctrl+Alt+Del on Windows)."]
    #[doc = ""]
    #[doc = " This is primarily intended for specialized applications such as VNC clients"]
    #[doc = " or VM frontends. Normal games should not use keyboard grab."]
    #[doc = ""]
    #[doc = " When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the"]
    #[doc = " window is full-screen to ensure the user is not trapped in your"]
    #[doc = " application. If you have a custom keyboard shortcut to exit fullscreen"]
    #[doc = " mode, you may suppress this behavior with"]
    #[doc = " `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`."]
    #[doc = ""]
    #[doc = " If the caller enables a grab while another window is currently grabbed, the"]
    #[doc = " other window loses its grab in favor of the caller's window."]
    #[doc = ""]
    #[doc = " \\param window The window for which the keyboard grab mode should be set."]
    #[doc = " \\param grabbed This is SDL_TRUE to grab keyboard, and SDL_FALSE to release."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.16."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetWindowKeyboardGrab"]
    #[doc = " \\sa SDL_SetWindowMouseGrab"]
    #[doc = " \\sa SDL_SetWindowGrab"]
    pub fn SDL_SetWindowKeyboardGrab(window: *mut SDL_Window, grabbed: SDL_bool);
}
extern "C" {
    #[doc = " Set a window's mouse grab mode."]
    #[doc = ""]
    #[doc = " Mouse grab confines the mouse cursor to the window."]
    #[doc = ""]
    #[doc = " \\param window The window for which the mouse grab mode should be set."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.16."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetWindowMouseGrab"]
    #[doc = " \\sa SDL_SetWindowKeyboardGrab"]
    #[doc = " \\sa SDL_SetWindowGrab"]
    pub fn SDL_SetWindowMouseGrab(window: *mut SDL_Window, grabbed: SDL_bool);
}
extern "C" {
    #[doc = " Get a window's input grab mode."]
    #[doc = ""]
    #[doc = " \\param window the window to query"]
    #[doc = " \\returns SDL_TRUE if input is grabbed, SDL_FALSE otherwise."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_SetWindowGrab"]
    pub fn SDL_GetWindowGrab(window: *mut SDL_Window) -> SDL_bool;
}
extern "C" {
    #[doc = " Get a window's keyboard grab mode."]
    #[doc = ""]
    #[doc = " \\param window the window to query"]
    #[doc = " \\returns SDL_TRUE if keyboard is grabbed, and SDL_FALSE otherwise."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.16."]
    #[doc = ""]
    #[doc = " \\sa SDL_SetWindowKeyboardGrab"]
    #[doc = " \\sa SDL_GetWindowGrab"]
    pub fn SDL_GetWindowKeyboardGrab(window: *mut SDL_Window) -> SDL_bool;
}
extern "C" {
    #[doc = " Get a window's mouse grab mode."]
    #[doc = ""]
    #[doc = " \\param window the window to query"]
    #[doc = " \\returns SDL_TRUE if mouse is grabbed, and SDL_FALSE otherwise."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.16."]
    #[doc = ""]
    #[doc = " \\sa SDL_SetWindowKeyboardGrab"]
    #[doc = " \\sa SDL_GetWindowGrab"]
    pub fn SDL_GetWindowMouseGrab(window: *mut SDL_Window) -> SDL_bool;
}
extern "C" {
    #[doc = " Get the window that currently has an input grab enabled."]
    #[doc = ""]
    #[doc = " \\returns the window if input is grabbed or NULL otherwise."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.4."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetWindowGrab"]
    #[doc = " \\sa SDL_SetWindowGrab"]
    pub fn SDL_GetGrabbedWindow() -> *mut SDL_Window;
}
extern "C" {
    #[doc = " Confines the cursor to the specified area of a window."]
    #[doc = ""]
    #[doc = " Note that this does NOT grab the cursor, it only defines the area a cursor"]
    #[doc = " is restricted to when the window has mouse focus."]
    #[doc = ""]
    #[doc = " \\param window The window that will be associated with the barrier."]
    #[doc = " \\param rect A rectangle area in window-relative coordinates. If NULL the"]
    #[doc = "             barrier for the specified window will be destroyed."]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetWindowMouseRect"]
    #[doc = " \\sa SDL_SetWindowMouseGrab"]
    pub fn SDL_SetWindowMouseRect(window: *mut SDL_Window, rect: *const SDL_Rect) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the mouse confinement rectangle of a window."]
    #[doc = ""]
    #[doc = " \\param window The window to query"]
    #[doc = " \\returns A pointer to the mouse confinement rectangle of a window, or NULL"]
    #[doc = "          if there isn't one."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    #[doc = ""]
    #[doc = " \\sa SDL_SetWindowMouseRect"]
    pub fn SDL_GetWindowMouseRect(window: *mut SDL_Window) -> *const SDL_Rect;
}
extern "C" {
    #[doc = " Set the brightness (gamma multiplier) for a given window's display."]
    #[doc = ""]
    #[doc = " Despite the name and signature, this method sets the brightness of the"]
    #[doc = " entire display, not an individual window. A window is considered to be"]
    #[doc = " owned by the display that contains the window's center pixel. (The index of"]
    #[doc = " this display can be retrieved using SDL_GetWindowDisplayIndex().) The"]
    #[doc = " brightness set will not follow the window if it is moved to another"]
    #[doc = " display."]
    #[doc = ""]
    #[doc = " Many platforms will refuse to set the display brightness in modern times."]
    #[doc = " You are better off using a shader to adjust gamma during rendering, or"]
    #[doc = " something similar."]
    #[doc = ""]
    #[doc = " \\param window the window used to select the display whose brightness will"]
    #[doc = "               be changed"]
    #[doc = " \\param brightness the brightness (gamma multiplier) value to set where 0.0"]
    #[doc = "                   is completely dark and 1.0 is normal brightness"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetWindowBrightness"]
    #[doc = " \\sa SDL_SetWindowGammaRamp"]
    pub fn SDL_SetWindowBrightness(window: *mut SDL_Window, brightness: f32) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the brightness (gamma multiplier) for a given window's display."]
    #[doc = ""]
    #[doc = " Despite the name and signature, this method retrieves the brightness of the"]
    #[doc = " entire display, not an individual window. A window is considered to be"]
    #[doc = " owned by the display that contains the window's center pixel. (The index of"]
    #[doc = " this display can be retrieved using SDL_GetWindowDisplayIndex().)"]
    #[doc = ""]
    #[doc = " \\param window the window used to select the display whose brightness will"]
    #[doc = "               be queried"]
    #[doc = " \\returns the brightness for the display where 0.0 is completely dark and"]
    #[doc = "          1.0 is normal brightness."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_SetWindowBrightness"]
    pub fn SDL_GetWindowBrightness(window: *mut SDL_Window) -> f32;
}
extern "C" {
    #[doc = " Set the opacity for a window."]
    #[doc = ""]
    #[doc = " The parameter `opacity` will be clamped internally between 0.0f"]
    #[doc = " (transparent) and 1.0f (opaque)."]
    #[doc = ""]
    #[doc = " This function also returns -1 if setting the opacity isn't supported."]
    #[doc = ""]
    #[doc = " \\param window the window which will be made transparent or opaque"]
    #[doc = " \\param opacity the opacity value (0.0f - transparent, 1.0f - opaque)"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.5."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetWindowOpacity"]
    pub fn SDL_SetWindowOpacity(window: *mut SDL_Window, opacity: f32) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the opacity of a window."]
    #[doc = ""]
    #[doc = " If transparency isn't supported on this platform, opacity will be reported"]
    #[doc = " as 1.0f without error."]
    #[doc = ""]
    #[doc = " The parameter `opacity` is ignored if it is NULL."]
    #[doc = ""]
    #[doc = " This function also returns -1 if an invalid window was provided."]
    #[doc = ""]
    #[doc = " \\param window the window to get the current opacity value from"]
    #[doc = " \\param out_opacity the float filled in (0.0f - transparent, 1.0f - opaque)"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.5."]
    #[doc = ""]
    #[doc = " \\sa SDL_SetWindowOpacity"]
    pub fn SDL_GetWindowOpacity(window: *mut SDL_Window, out_opacity: *mut f32) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the window as a modal for another window."]
    #[doc = ""]
    #[doc = " \\param modal_window the window that should be set modal"]
    #[doc = " \\param parent_window the parent window for the modal window"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.5."]
    pub fn SDL_SetWindowModalFor(
        modal_window: *mut SDL_Window,
        parent_window: *mut SDL_Window,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Explicitly set input focus to the window."]
    #[doc = ""]
    #[doc = " You almost certainly want SDL_RaiseWindow() instead of this function. Use"]
    #[doc = " this with caution, as you might give focus to a window that is completely"]
    #[doc = " obscured by other windows."]
    #[doc = ""]
    #[doc = " \\param window the window that should get the input focus"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.5."]
    #[doc = ""]
    #[doc = " \\sa SDL_RaiseWindow"]
    pub fn SDL_SetWindowInputFocus(window: *mut SDL_Window) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the gamma ramp for the display that owns a given window."]
    #[doc = ""]
    #[doc = " Set the gamma translation table for the red, green, and blue channels of"]
    #[doc = " the video hardware. Each table is an array of 256 16-bit quantities,"]
    #[doc = " representing a mapping between the input and output for that channel. The"]
    #[doc = " input is the index into the array, and the output is the 16-bit gamma value"]
    #[doc = " at that index, scaled to the output color precision."]
    #[doc = ""]
    #[doc = " Despite the name and signature, this method sets the gamma ramp of the"]
    #[doc = " entire display, not an individual window. A window is considered to be"]
    #[doc = " owned by the display that contains the window's center pixel. (The index of"]
    #[doc = " this display can be retrieved using SDL_GetWindowDisplayIndex().) The gamma"]
    #[doc = " ramp set will not follow the window if it is moved to another display."]
    #[doc = ""]
    #[doc = " \\param window the window used to select the display whose gamma ramp will"]
    #[doc = "               be changed"]
    #[doc = " \\param red a 256 element array of 16-bit quantities representing the"]
    #[doc = "            translation table for the red channel, or NULL"]
    #[doc = " \\param green a 256 element array of 16-bit quantities representing the"]
    #[doc = "              translation table for the green channel, or NULL"]
    #[doc = " \\param blue a 256 element array of 16-bit quantities representing the"]
    #[doc = "             translation table for the blue channel, or NULL"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetWindowGammaRamp"]
    pub fn SDL_SetWindowGammaRamp(
        window: *mut SDL_Window,
        red: *const Uint16,
        green: *const Uint16,
        blue: *const Uint16,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the gamma ramp for a given window's display."]
    #[doc = ""]
    #[doc = " Despite the name and signature, this method retrieves the gamma ramp of the"]
    #[doc = " entire display, not an individual window. A window is considered to be"]
    #[doc = " owned by the display that contains the window's center pixel. (The index of"]
    #[doc = " this display can be retrieved using SDL_GetWindowDisplayIndex().)"]
    #[doc = ""]
    #[doc = " \\param window the window used to select the display whose gamma ramp will"]
    #[doc = "               be queried"]
    #[doc = " \\param red a 256 element array of 16-bit quantities filled in with the"]
    #[doc = "            translation table for the red channel, or NULL"]
    #[doc = " \\param green a 256 element array of 16-bit quantities filled in with the"]
    #[doc = "              translation table for the green channel, or NULL"]
    #[doc = " \\param blue a 256 element array of 16-bit quantities filled in with the"]
    #[doc = "             translation table for the blue channel, or NULL"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_SetWindowGammaRamp"]
    pub fn SDL_GetWindowGammaRamp(
        window: *mut SDL_Window,
        red: *mut Uint16,
        green: *mut Uint16,
        blue: *mut Uint16,
    ) -> libc::c_int;
}
#[repr(u32)]
#[doc = " Possible return values from the SDL_HitTest callback."]
#[doc = ""]
#[doc = " \\sa SDL_HitTest"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_HitTestResult {
    #[doc = "< Region is normal. No special properties."]
    SDL_HITTEST_NORMAL = 0,
    #[doc = "< Region can drag entire window."]
    SDL_HITTEST_DRAGGABLE = 1,
    SDL_HITTEST_RESIZE_TOPLEFT = 2,
    SDL_HITTEST_RESIZE_TOP = 3,
    SDL_HITTEST_RESIZE_TOPRIGHT = 4,
    SDL_HITTEST_RESIZE_RIGHT = 5,
    SDL_HITTEST_RESIZE_BOTTOMRIGHT = 6,
    SDL_HITTEST_RESIZE_BOTTOM = 7,
    SDL_HITTEST_RESIZE_BOTTOMLEFT = 8,
    SDL_HITTEST_RESIZE_LEFT = 9,
}
#[doc = " Callback used for hit-testing."]
#[doc = ""]
#[doc = " \\param win the SDL_Window where hit-testing was set on"]
#[doc = " \\param area an SDL_Point which should be hit-tested"]
#[doc = " \\param data what was passed as `callback_data` to SDL_SetWindowHitTest()"]
#[doc = " \\return an SDL_HitTestResult value."]
#[doc = ""]
#[doc = " \\sa SDL_SetWindowHitTest"]
pub type SDL_HitTest = ::core::option::Option<
    unsafe extern "C" fn(
        win: *mut SDL_Window,
        area: *const SDL_Point,
        data: *mut libc::c_void,
    ) -> SDL_HitTestResult,
>;
extern "C" {
    #[doc = " Provide a callback that decides if a window region has special properties."]
    #[doc = ""]
    #[doc = " Normally windows are dragged and resized by decorations provided by the"]
    #[doc = " system window manager (a title bar, borders, etc), but for some apps, it"]
    #[doc = " makes sense to drag them from somewhere else inside the window itself; for"]
    #[doc = " example, one might have a borderless window that wants to be draggable from"]
    #[doc = " any part, or simulate its own title bar, etc."]
    #[doc = ""]
    #[doc = " This function lets the app provide a callback that designates pieces of a"]
    #[doc = " given window as special. This callback is run during event processing if we"]
    #[doc = " need to tell the OS to treat a region of the window specially; the use of"]
    #[doc = " this callback is known as \"hit testing.\""]
    #[doc = ""]
    #[doc = " Mouse input may not be delivered to your application if it is within a"]
    #[doc = " special area; the OS will often apply that input to moving the window or"]
    #[doc = " resizing the window and not deliver it to the application."]
    #[doc = ""]
    #[doc = " Specifying NULL for a callback disables hit-testing. Hit-testing is"]
    #[doc = " disabled by default."]
    #[doc = ""]
    #[doc = " Platforms that don't support this functionality will return -1"]
    #[doc = " unconditionally, even if you're attempting to disable hit-testing."]
    #[doc = ""]
    #[doc = " Your callback may fire at any time, and its firing does not indicate any"]
    #[doc = " specific behavior (for example, on Windows, this certainly might fire when"]
    #[doc = " the OS is deciding whether to drag your window, but it fires for lots of"]
    #[doc = " other reasons, too, some unrelated to anything you probably care about _and"]
    #[doc = " when the mouse isn't actually at the location it is testing_). Since this"]
    #[doc = " can fire at any time, you should try to keep your callback efficient,"]
    #[doc = " devoid of allocations, etc."]
    #[doc = ""]
    #[doc = " \\param window the window to set hit-testing on"]
    #[doc = " \\param callback the function to call when doing a hit-test"]
    #[doc = " \\param callback_data an app-defined void pointer passed to **callback**"]
    #[doc = " \\returns 0 on success or -1 on error (including unsupported); call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.4."]
    pub fn SDL_SetWindowHitTest(
        window: *mut SDL_Window,
        callback: SDL_HitTest,
        callback_data: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Request a window to demand attention from the user."]
    #[doc = ""]
    #[doc = " \\param window the window to be flashed"]
    #[doc = " \\param operation the flash operation"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.16."]
    pub fn SDL_FlashWindow(window: *mut SDL_Window, operation: SDL_FlashOperation) -> libc::c_int;
}
extern "C" {
    #[doc = " Destroy a window."]
    #[doc = ""]
    #[doc = " If `window` is NULL, this function will return immediately after setting"]
    #[doc = " the SDL error message to \"Invalid window\". See SDL_GetError()."]
    #[doc = ""]
    #[doc = " \\param window the window to destroy"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateWindow"]
    #[doc = " \\sa SDL_CreateWindowFrom"]
    pub fn SDL_DestroyWindow(window: *mut SDL_Window);
}
extern "C" {
    #[doc = " Check whether the screensaver is currently enabled."]
    #[doc = ""]
    #[doc = " The screensaver is disabled by default since SDL 2.0.2. Before SDL 2.0.2"]
    #[doc = " the screensaver was enabled by default."]
    #[doc = ""]
    #[doc = " The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`."]
    #[doc = ""]
    #[doc = " \\returns SDL_TRUE if the screensaver is enabled, SDL_FALSE if it is"]
    #[doc = "          disabled."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_DisableScreenSaver"]
    #[doc = " \\sa SDL_EnableScreenSaver"]
    pub fn SDL_IsScreenSaverEnabled() -> SDL_bool;
}
extern "C" {
    #[doc = " Allow the screen to be blanked by a screen saver."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_DisableScreenSaver"]
    #[doc = " \\sa SDL_IsScreenSaverEnabled"]
    pub fn SDL_EnableScreenSaver();
}
extern "C" {
    #[doc = " Prevent the screen from being blanked by a screen saver."]
    #[doc = ""]
    #[doc = " If you disable the screensaver, it is automatically re-enabled when SDL"]
    #[doc = " quits."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_EnableScreenSaver"]
    #[doc = " \\sa SDL_IsScreenSaverEnabled"]
    pub fn SDL_DisableScreenSaver();
}
extern "C" {
    #[doc = " Dynamically load an OpenGL library."]
    #[doc = ""]
    #[doc = " This should be done after initializing the video driver, but before"]
    #[doc = " creating any OpenGL windows. If no OpenGL library is loaded, the default"]
    #[doc = " library will be loaded upon creation of the first OpenGL window."]
    #[doc = ""]
    #[doc = " If you do this, you need to retrieve all of the GL functions used in your"]
    #[doc = " program from the dynamic library using SDL_GL_GetProcAddress()."]
    #[doc = ""]
    #[doc = " \\param path the platform dependent OpenGL library name, or NULL to open the"]
    #[doc = "             default OpenGL library"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GL_GetProcAddress"]
    #[doc = " \\sa SDL_GL_UnloadLibrary"]
    pub fn SDL_GL_LoadLibrary(path: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Get an OpenGL function by name."]
    #[doc = ""]
    #[doc = " If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all"]
    #[doc = " GL functions must be retrieved this way. Usually this is used to retrieve"]
    #[doc = " function pointers to OpenGL extensions."]
    #[doc = ""]
    #[doc = " There are some quirks to looking up OpenGL functions that require some"]
    #[doc = " extra care from the application. If you code carefully, you can handle"]
    #[doc = " these quirks without any platform-specific code, though:"]
    #[doc = ""]
    #[doc = " - On Windows, function pointers are specific to the current GL context;"]
    #[doc = "   this means you need to have created a GL context and made it current"]
    #[doc = "   before calling SDL_GL_GetProcAddress(). If you recreate your context or"]
    #[doc = "   create a second context, you should assume that any existing function"]
    #[doc = "   pointers aren't valid to use with it. This is (currently) a"]
    #[doc = "   Windows-specific limitation, and in practice lots of drivers don't suffer"]
    #[doc = "   this limitation, but it is still the way the wgl API is documented to"]
    #[doc = "   work and you should expect crashes if you don't respect it. Store a copy"]
    #[doc = "   of the function pointers that comes and goes with context lifespan."]
    #[doc = " - On X11, function pointers returned by this function are valid for any"]
    #[doc = "   context, and can even be looked up before a context is created at all."]
    #[doc = "   This means that, for at least some common OpenGL implementations, if you"]
    #[doc = "   look up a function that doesn't exist, you'll get a non-NULL result that"]
    #[doc = "   is _NOT_ safe to call. You must always make sure the function is actually"]
    #[doc = "   available for a given GL context before calling it, by checking for the"]
    #[doc = "   existence of the appropriate extension with SDL_GL_ExtensionSupported(),"]
    #[doc = "   or verifying that the version of OpenGL you're using offers the function"]
    #[doc = "   as core functionality."]
    #[doc = " - Some OpenGL drivers, on all platforms, *will* return NULL if a function"]
    #[doc = "   isn't supported, but you can't count on this behavior. Check for"]
    #[doc = "   extensions you use, and if you get a NULL anyway, act as if that"]
    #[doc = "   extension wasn't available. This is probably a bug in the driver, but you"]
    #[doc = "   can code defensively for this scenario anyhow."]
    #[doc = " - Just because you're on Linux/Unix, don't assume you'll be using X11."]
    #[doc = "   Next-gen display servers are waiting to replace it, and may or may not"]
    #[doc = "   make the same promises about function pointers."]
    #[doc = " - OpenGL function pointers must be declared `APIENTRY` as in the example"]
    #[doc = "   code. This will ensure the proper calling convention is followed on"]
    #[doc = "   platforms where this matters (Win32) thereby avoiding stack corruption."]
    #[doc = ""]
    #[doc = " \\param proc the name of an OpenGL function"]
    #[doc = " \\returns a pointer to the named OpenGL function. The returned pointer"]
    #[doc = "          should be cast to the appropriate function signature."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GL_ExtensionSupported"]
    #[doc = " \\sa SDL_GL_LoadLibrary"]
    #[doc = " \\sa SDL_GL_UnloadLibrary"]
    pub fn SDL_GL_GetProcAddress(proc_: *const libc::c_char) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary()."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GL_LoadLibrary"]
    pub fn SDL_GL_UnloadLibrary();
}
extern "C" {
    #[doc = " Check if an OpenGL extension is supported for the current context."]
    #[doc = ""]
    #[doc = " This function operates on the current GL context; you must have created a"]
    #[doc = " context and it must be current before calling this function. Do not assume"]
    #[doc = " that all contexts you create will have the same set of extensions"]
    #[doc = " available, or that recreating an existing context will offer the same"]
    #[doc = " extensions again."]
    #[doc = ""]
    #[doc = " While it's probably not a massive overhead, this function is not an O(1)"]
    #[doc = " operation. Check the extensions you care about after creating the GL"]
    #[doc = " context and save that information somewhere instead of calling the function"]
    #[doc = " every time you need to know."]
    #[doc = ""]
    #[doc = " \\param extension the name of the extension to check"]
    #[doc = " \\returns SDL_TRUE if the extension is supported, SDL_FALSE otherwise."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_GL_ExtensionSupported(extension: *const libc::c_char) -> SDL_bool;
}
extern "C" {
    #[doc = " Reset all previously set OpenGL context attributes to their default values."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.2."]
    #[doc = ""]
    #[doc = " \\sa SDL_GL_GetAttribute"]
    #[doc = " \\sa SDL_GL_SetAttribute"]
    pub fn SDL_GL_ResetAttributes();
}
extern "C" {
    #[doc = " Set an OpenGL window attribute before window creation."]
    #[doc = ""]
    #[doc = " This function sets the OpenGL attribute `attr` to `value`. The requested"]
    #[doc = " attributes should be set before creating an OpenGL window. You should use"]
    #[doc = " SDL_GL_GetAttribute() to check the values after creating the OpenGL"]
    #[doc = " context, since the values obtained can differ from the requested ones."]
    #[doc = ""]
    #[doc = " \\param attr an SDL_GLattr enum value specifying the OpenGL attribute to set"]
    #[doc = " \\param value the desired value for the attribute"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GL_GetAttribute"]
    #[doc = " \\sa SDL_GL_ResetAttributes"]
    pub fn SDL_GL_SetAttribute(attr: SDL_GLattr, value: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the actual value for an attribute from the current context."]
    #[doc = ""]
    #[doc = " \\param attr an SDL_GLattr enum value specifying the OpenGL attribute to get"]
    #[doc = " \\param value a pointer filled in with the current value of `attr`"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GL_ResetAttributes"]
    #[doc = " \\sa SDL_GL_SetAttribute"]
    pub fn SDL_GL_GetAttribute(attr: SDL_GLattr, value: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Create an OpenGL context for an OpenGL window, and make it current."]
    #[doc = ""]
    #[doc = " Windows users new to OpenGL should note that, for historical reasons, GL"]
    #[doc = " functions added after OpenGL version 1.1 are not available by default."]
    #[doc = " Those functions must be loaded at run-time, either with an OpenGL"]
    #[doc = " extension-handling library or with SDL_GL_GetProcAddress() and its related"]
    #[doc = " functions."]
    #[doc = ""]
    #[doc = " SDL_GLContext is an alias for `void *`. It's opaque to the application."]
    #[doc = ""]
    #[doc = " \\param window the window to associate with the context"]
    #[doc = " \\returns the OpenGL context associated with `window` or NULL on error; call"]
    #[doc = "          SDL_GetError() for more details."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GL_DeleteContext"]
    #[doc = " \\sa SDL_GL_MakeCurrent"]
    pub fn SDL_GL_CreateContext(window: *mut SDL_Window) -> SDL_GLContext;
}
extern "C" {
    #[doc = " Set up an OpenGL context for rendering into an OpenGL window."]
    #[doc = ""]
    #[doc = " The context must have been created with a compatible window."]
    #[doc = ""]
    #[doc = " \\param window the window to associate with the context"]
    #[doc = " \\param context the OpenGL context to associate with the window"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GL_CreateContext"]
    pub fn SDL_GL_MakeCurrent(window: *mut SDL_Window, context: SDL_GLContext) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the currently active OpenGL window."]
    #[doc = ""]
    #[doc = " \\returns the currently active OpenGL window on success or NULL on failure;"]
    #[doc = "          call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_GL_GetCurrentWindow() -> *mut SDL_Window;
}
extern "C" {
    #[doc = " Get the currently active OpenGL context."]
    #[doc = ""]
    #[doc = " \\returns the currently active OpenGL context or NULL on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GL_MakeCurrent"]
    pub fn SDL_GL_GetCurrentContext() -> SDL_GLContext;
}
extern "C" {
    #[doc = " Get the size of a window's underlying drawable in pixels."]
    #[doc = ""]
    #[doc = " This returns info useful for calling glViewport()."]
    #[doc = ""]
    #[doc = " This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI"]
    #[doc = " drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a"]
    #[doc = " platform with high-DPI support (Apple calls this \"Retina\"), and not"]
    #[doc = " disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint."]
    #[doc = ""]
    #[doc = " \\param window the window from which the drawable size should be queried"]
    #[doc = " \\param w a pointer to variable for storing the width in pixels, may be NULL"]
    #[doc = " \\param h a pointer to variable for storing the height in pixels, may be"]
    #[doc = "          NULL"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.1."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateWindow"]
    #[doc = " \\sa SDL_GetWindowSize"]
    pub fn SDL_GL_GetDrawableSize(
        window: *mut SDL_Window,
        w: *mut libc::c_int,
        h: *mut libc::c_int,
    );
}
extern "C" {
    #[doc = " Set the swap interval for the current OpenGL context."]
    #[doc = ""]
    #[doc = " Some systems allow specifying -1 for the interval, to enable adaptive"]
    #[doc = " vsync. Adaptive vsync works the same as vsync, but if you've already missed"]
    #[doc = " the vertical retrace for a given frame, it swaps buffers immediately, which"]
    #[doc = " might be less jarring for the user during occasional framerate drops. If an"]
    #[doc = " application requests adaptive vsync and the system does not support it,"]
    #[doc = " this function will fail and return -1. In such a case, you should probably"]
    #[doc = " retry the call with 1 for the interval."]
    #[doc = ""]
    #[doc = " Adaptive vsync is implemented for some glX drivers with"]
    #[doc = " GLX_EXT_swap_control_tear:"]
    #[doc = ""]
    #[doc = " https://www.opengl.org/registry/specs/EXT/glx_swap_control_tear.txt"]
    #[doc = ""]
    #[doc = " and for some Windows drivers with WGL_EXT_swap_control_tear:"]
    #[doc = ""]
    #[doc = " https://www.opengl.org/registry/specs/EXT/wgl_swap_control_tear.txt"]
    #[doc = ""]
    #[doc = " Read more on the Khronos wiki:"]
    #[doc = " https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync"]
    #[doc = ""]
    #[doc = " \\param interval 0 for immediate updates, 1 for updates synchronized with"]
    #[doc = "                 the vertical retrace, -1 for adaptive vsync"]
    #[doc = " \\returns 0 on success or -1 if setting the swap interval is not supported;"]
    #[doc = "          call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GL_GetSwapInterval"]
    pub fn SDL_GL_SetSwapInterval(interval: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the swap interval for the current OpenGL context."]
    #[doc = ""]
    #[doc = " If the system can't determine the swap interval, or there isn't a valid"]
    #[doc = " current context, this function will return 0 as a safe default."]
    #[doc = ""]
    #[doc = " \\returns 0 if there is no vertical retrace synchronization, 1 if the buffer"]
    #[doc = "          swap is synchronized with the vertical retrace, and -1 if late"]
    #[doc = "          swaps happen immediately instead of waiting for the next retrace;"]
    #[doc = "          call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GL_SetSwapInterval"]
    pub fn SDL_GL_GetSwapInterval() -> libc::c_int;
}
extern "C" {
    #[doc = " Update a window with OpenGL rendering."]
    #[doc = ""]
    #[doc = " This is used with double-buffered OpenGL contexts, which are the default."]
    #[doc = ""]
    #[doc = " On macOS, make sure you bind 0 to the draw framebuffer before swapping the"]
    #[doc = " window, otherwise nothing will happen. If you aren't using"]
    #[doc = " glBindFramebuffer(), this is the default and you won't have to do anything"]
    #[doc = " extra."]
    #[doc = ""]
    #[doc = " \\param window the window to change"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_GL_SwapWindow(window: *mut SDL_Window);
}
extern "C" {
    #[doc = " Delete an OpenGL context."]
    #[doc = ""]
    #[doc = " \\param context the OpenGL context to be deleted"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GL_CreateContext"]
    pub fn SDL_GL_DeleteContext(context: SDL_GLContext);
}
#[repr(u32)]
#[doc = "  \\brief The SDL keyboard scancode representation."]
#[doc = ""]
#[doc = "  Values of this type are used to represent keyboard keys, among other places"]
#[doc = "  in the \\link SDL_Keysym::scancode key.keysym.scancode \\endlink field of the"]
#[doc = "  SDL_Event structure."]
#[doc = ""]
#[doc = "  The values in this enumeration are based on the USB usage page standard:"]
#[doc = "  https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_Scancode {
    SDL_SCANCODE_UNKNOWN = 0,
    SDL_SCANCODE_A = 4,
    SDL_SCANCODE_B = 5,
    SDL_SCANCODE_C = 6,
    SDL_SCANCODE_D = 7,
    SDL_SCANCODE_E = 8,
    SDL_SCANCODE_F = 9,
    SDL_SCANCODE_G = 10,
    SDL_SCANCODE_H = 11,
    SDL_SCANCODE_I = 12,
    SDL_SCANCODE_J = 13,
    SDL_SCANCODE_K = 14,
    SDL_SCANCODE_L = 15,
    SDL_SCANCODE_M = 16,
    SDL_SCANCODE_N = 17,
    SDL_SCANCODE_O = 18,
    SDL_SCANCODE_P = 19,
    SDL_SCANCODE_Q = 20,
    SDL_SCANCODE_R = 21,
    SDL_SCANCODE_S = 22,
    SDL_SCANCODE_T = 23,
    SDL_SCANCODE_U = 24,
    SDL_SCANCODE_V = 25,
    SDL_SCANCODE_W = 26,
    SDL_SCANCODE_X = 27,
    SDL_SCANCODE_Y = 28,
    SDL_SCANCODE_Z = 29,
    SDL_SCANCODE_1 = 30,
    SDL_SCANCODE_2 = 31,
    SDL_SCANCODE_3 = 32,
    SDL_SCANCODE_4 = 33,
    SDL_SCANCODE_5 = 34,
    SDL_SCANCODE_6 = 35,
    SDL_SCANCODE_7 = 36,
    SDL_SCANCODE_8 = 37,
    SDL_SCANCODE_9 = 38,
    SDL_SCANCODE_0 = 39,
    SDL_SCANCODE_RETURN = 40,
    SDL_SCANCODE_ESCAPE = 41,
    SDL_SCANCODE_BACKSPACE = 42,
    SDL_SCANCODE_TAB = 43,
    SDL_SCANCODE_SPACE = 44,
    SDL_SCANCODE_MINUS = 45,
    SDL_SCANCODE_EQUALS = 46,
    SDL_SCANCODE_LEFTBRACKET = 47,
    SDL_SCANCODE_RIGHTBRACKET = 48,
    #[doc = "< Located at the lower left of the return"]
    #[doc = "   key on ISO keyboards and at the right end"]
    #[doc = "   of the QWERTY row on ANSI keyboards."]
    #[doc = "   Produces REVERSE SOLIDUS (backslash) and"]
    #[doc = "   VERTICAL LINE in a US layout, REVERSE"]
    #[doc = "   SOLIDUS and VERTICAL LINE in a UK Mac"]
    #[doc = "   layout, NUMBER SIGN and TILDE in a UK"]
    #[doc = "   Windows layout, DOLLAR SIGN and POUND SIGN"]
    #[doc = "   in a Swiss German layout, NUMBER SIGN and"]
    #[doc = "   APOSTROPHE in a German layout, GRAVE"]
    #[doc = "   ACCENT and POUND SIGN in a French Mac"]
    #[doc = "   layout, and ASTERISK and MICRO SIGN in a"]
    #[doc = "   French Windows layout."]
    SDL_SCANCODE_BACKSLASH = 49,
    #[doc = "< ISO USB keyboards actually use this code"]
    #[doc = "   instead of 49 for the same key, but all"]
    #[doc = "   OSes I've seen treat the two codes"]
    #[doc = "   identically. So, as an implementor, unless"]
    #[doc = "   your keyboard generates both of those"]
    #[doc = "   codes and your OS treats them differently,"]
    #[doc = "   you should generate SDL_SCANCODE_BACKSLASH"]
    #[doc = "   instead of this code. As a user, you"]
    #[doc = "   should not rely on this code because SDL"]
    #[doc = "   will never generate it with most (all?)"]
    #[doc = "   keyboards."]
    SDL_SCANCODE_NONUSHASH = 50,
    SDL_SCANCODE_SEMICOLON = 51,
    SDL_SCANCODE_APOSTROPHE = 52,
    #[doc = "< Located in the top left corner (on both ANSI"]
    #[doc = "   and ISO keyboards). Produces GRAVE ACCENT and"]
    #[doc = "   TILDE in a US Windows layout and in US and UK"]
    #[doc = "   Mac layouts on ANSI keyboards, GRAVE ACCENT"]
    #[doc = "   and NOT SIGN in a UK Windows layout, SECTION"]
    #[doc = "   SIGN and PLUS-MINUS SIGN in US and UK Mac"]
    #[doc = "   layouts on ISO keyboards, SECTION SIGN and"]
    #[doc = "   DEGREE SIGN in a Swiss German layout (Mac:"]
    #[doc = "   only on ISO keyboards), CIRCUMFLEX ACCENT and"]
    #[doc = "   DEGREE SIGN in a German layout (Mac: only on"]
    #[doc = "   ISO keyboards), SUPERSCRIPT TWO and TILDE in a"]
    #[doc = "   French Windows layout, COMMERCIAL AT and"]
    #[doc = "   NUMBER SIGN in a French Mac layout on ISO"]
    #[doc = "   keyboards, and LESS-THAN SIGN and GREATER-THAN"]
    #[doc = "   SIGN in a Swiss German, German, or French Mac"]
    #[doc = "   layout on ANSI keyboards."]
    SDL_SCANCODE_GRAVE = 53,
    SDL_SCANCODE_COMMA = 54,
    SDL_SCANCODE_PERIOD = 55,
    SDL_SCANCODE_SLASH = 56,
    SDL_SCANCODE_CAPSLOCK = 57,
    SDL_SCANCODE_F1 = 58,
    SDL_SCANCODE_F2 = 59,
    SDL_SCANCODE_F3 = 60,
    SDL_SCANCODE_F4 = 61,
    SDL_SCANCODE_F5 = 62,
    SDL_SCANCODE_F6 = 63,
    SDL_SCANCODE_F7 = 64,
    SDL_SCANCODE_F8 = 65,
    SDL_SCANCODE_F9 = 66,
    SDL_SCANCODE_F10 = 67,
    SDL_SCANCODE_F11 = 68,
    SDL_SCANCODE_F12 = 69,
    SDL_SCANCODE_PRINTSCREEN = 70,
    SDL_SCANCODE_SCROLLLOCK = 71,
    SDL_SCANCODE_PAUSE = 72,
    #[doc = "< insert on PC, help on some Mac keyboards (but"]
    #[doc = "does send code 73, not 117)"]
    SDL_SCANCODE_INSERT = 73,
    SDL_SCANCODE_HOME = 74,
    SDL_SCANCODE_PAGEUP = 75,
    SDL_SCANCODE_DELETE = 76,
    SDL_SCANCODE_END = 77,
    SDL_SCANCODE_PAGEDOWN = 78,
    SDL_SCANCODE_RIGHT = 79,
    SDL_SCANCODE_LEFT = 80,
    SDL_SCANCODE_DOWN = 81,
    SDL_SCANCODE_UP = 82,
    #[doc = "< num lock on PC, clear on Mac keyboards"]
    SDL_SCANCODE_NUMLOCKCLEAR = 83,
    SDL_SCANCODE_KP_DIVIDE = 84,
    SDL_SCANCODE_KP_MULTIPLY = 85,
    SDL_SCANCODE_KP_MINUS = 86,
    SDL_SCANCODE_KP_PLUS = 87,
    SDL_SCANCODE_KP_ENTER = 88,
    SDL_SCANCODE_KP_1 = 89,
    SDL_SCANCODE_KP_2 = 90,
    SDL_SCANCODE_KP_3 = 91,
    SDL_SCANCODE_KP_4 = 92,
    SDL_SCANCODE_KP_5 = 93,
    SDL_SCANCODE_KP_6 = 94,
    SDL_SCANCODE_KP_7 = 95,
    SDL_SCANCODE_KP_8 = 96,
    SDL_SCANCODE_KP_9 = 97,
    SDL_SCANCODE_KP_0 = 98,
    SDL_SCANCODE_KP_PERIOD = 99,
    #[doc = "< This is the additional key that ISO"]
    #[doc = "   keyboards have over ANSI ones,"]
    #[doc = "   located between left shift and Y."]
    #[doc = "   Produces GRAVE ACCENT and TILDE in a"]
    #[doc = "   US or UK Mac layout, REVERSE SOLIDUS"]
    #[doc = "   (backslash) and VERTICAL LINE in a"]
    #[doc = "   US or UK Windows layout, and"]
    #[doc = "   LESS-THAN SIGN and GREATER-THAN SIGN"]
    #[doc = "   in a Swiss German, German, or French"]
    #[doc = "   layout."]
    SDL_SCANCODE_NONUSBACKSLASH = 100,
    #[doc = "< windows contextual menu, compose"]
    SDL_SCANCODE_APPLICATION = 101,
    #[doc = "< The USB document says this is a status flag,"]
    #[doc = "   not a physical key - but some Mac keyboards"]
    #[doc = "   do have a power key."]
    SDL_SCANCODE_POWER = 102,
    SDL_SCANCODE_KP_EQUALS = 103,
    SDL_SCANCODE_F13 = 104,
    SDL_SCANCODE_F14 = 105,
    SDL_SCANCODE_F15 = 106,
    SDL_SCANCODE_F16 = 107,
    SDL_SCANCODE_F17 = 108,
    SDL_SCANCODE_F18 = 109,
    SDL_SCANCODE_F19 = 110,
    SDL_SCANCODE_F20 = 111,
    SDL_SCANCODE_F21 = 112,
    SDL_SCANCODE_F22 = 113,
    SDL_SCANCODE_F23 = 114,
    SDL_SCANCODE_F24 = 115,
    SDL_SCANCODE_EXECUTE = 116,
    SDL_SCANCODE_HELP = 117,
    SDL_SCANCODE_MENU = 118,
    SDL_SCANCODE_SELECT = 119,
    SDL_SCANCODE_STOP = 120,
    #[doc = "< redo"]
    SDL_SCANCODE_AGAIN = 121,
    SDL_SCANCODE_UNDO = 122,
    SDL_SCANCODE_CUT = 123,
    SDL_SCANCODE_COPY = 124,
    SDL_SCANCODE_PASTE = 125,
    SDL_SCANCODE_FIND = 126,
    SDL_SCANCODE_MUTE = 127,
    SDL_SCANCODE_VOLUMEUP = 128,
    SDL_SCANCODE_VOLUMEDOWN = 129,
    SDL_SCANCODE_KP_COMMA = 133,
    SDL_SCANCODE_KP_EQUALSAS400 = 134,
    #[doc = "< used on Asian keyboards, see"]
    #[doc = "footnotes in USB doc"]
    SDL_SCANCODE_INTERNATIONAL1 = 135,
    SDL_SCANCODE_INTERNATIONAL2 = 136,
    #[doc = "< Yen"]
    SDL_SCANCODE_INTERNATIONAL3 = 137,
    SDL_SCANCODE_INTERNATIONAL4 = 138,
    SDL_SCANCODE_INTERNATIONAL5 = 139,
    SDL_SCANCODE_INTERNATIONAL6 = 140,
    SDL_SCANCODE_INTERNATIONAL7 = 141,
    SDL_SCANCODE_INTERNATIONAL8 = 142,
    SDL_SCANCODE_INTERNATIONAL9 = 143,
    #[doc = "< Hangul/English toggle"]
    SDL_SCANCODE_LANG1 = 144,
    #[doc = "< Hanja conversion"]
    SDL_SCANCODE_LANG2 = 145,
    #[doc = "< Katakana"]
    SDL_SCANCODE_LANG3 = 146,
    #[doc = "< Hiragana"]
    SDL_SCANCODE_LANG4 = 147,
    #[doc = "< Zenkaku/Hankaku"]
    SDL_SCANCODE_LANG5 = 148,
    #[doc = "< reserved"]
    SDL_SCANCODE_LANG6 = 149,
    #[doc = "< reserved"]
    SDL_SCANCODE_LANG7 = 150,
    #[doc = "< reserved"]
    SDL_SCANCODE_LANG8 = 151,
    #[doc = "< reserved"]
    SDL_SCANCODE_LANG9 = 152,
    #[doc = "< Erase-Eaze"]
    SDL_SCANCODE_ALTERASE = 153,
    SDL_SCANCODE_SYSREQ = 154,
    SDL_SCANCODE_CANCEL = 155,
    SDL_SCANCODE_CLEAR = 156,
    SDL_SCANCODE_PRIOR = 157,
    SDL_SCANCODE_RETURN2 = 158,
    SDL_SCANCODE_SEPARATOR = 159,
    SDL_SCANCODE_OUT = 160,
    SDL_SCANCODE_OPER = 161,
    SDL_SCANCODE_CLEARAGAIN = 162,
    SDL_SCANCODE_CRSEL = 163,
    SDL_SCANCODE_EXSEL = 164,
    SDL_SCANCODE_KP_00 = 176,
    SDL_SCANCODE_KP_000 = 177,
    SDL_SCANCODE_THOUSANDSSEPARATOR = 178,
    SDL_SCANCODE_DECIMALSEPARATOR = 179,
    SDL_SCANCODE_CURRENCYUNIT = 180,
    SDL_SCANCODE_CURRENCYSUBUNIT = 181,
    SDL_SCANCODE_KP_LEFTPAREN = 182,
    SDL_SCANCODE_KP_RIGHTPAREN = 183,
    SDL_SCANCODE_KP_LEFTBRACE = 184,
    SDL_SCANCODE_KP_RIGHTBRACE = 185,
    SDL_SCANCODE_KP_TAB = 186,
    SDL_SCANCODE_KP_BACKSPACE = 187,
    SDL_SCANCODE_KP_A = 188,
    SDL_SCANCODE_KP_B = 189,
    SDL_SCANCODE_KP_C = 190,
    SDL_SCANCODE_KP_D = 191,
    SDL_SCANCODE_KP_E = 192,
    SDL_SCANCODE_KP_F = 193,
    SDL_SCANCODE_KP_XOR = 194,
    SDL_SCANCODE_KP_POWER = 195,
    SDL_SCANCODE_KP_PERCENT = 196,
    SDL_SCANCODE_KP_LESS = 197,
    SDL_SCANCODE_KP_GREATER = 198,
    SDL_SCANCODE_KP_AMPERSAND = 199,
    SDL_SCANCODE_KP_DBLAMPERSAND = 200,
    SDL_SCANCODE_KP_VERTICALBAR = 201,
    SDL_SCANCODE_KP_DBLVERTICALBAR = 202,
    SDL_SCANCODE_KP_COLON = 203,
    SDL_SCANCODE_KP_HASH = 204,
    SDL_SCANCODE_KP_SPACE = 205,
    SDL_SCANCODE_KP_AT = 206,
    SDL_SCANCODE_KP_EXCLAM = 207,
    SDL_SCANCODE_KP_MEMSTORE = 208,
    SDL_SCANCODE_KP_MEMRECALL = 209,
    SDL_SCANCODE_KP_MEMCLEAR = 210,
    SDL_SCANCODE_KP_MEMADD = 211,
    SDL_SCANCODE_KP_MEMSUBTRACT = 212,
    SDL_SCANCODE_KP_MEMMULTIPLY = 213,
    SDL_SCANCODE_KP_MEMDIVIDE = 214,
    SDL_SCANCODE_KP_PLUSMINUS = 215,
    SDL_SCANCODE_KP_CLEAR = 216,
    SDL_SCANCODE_KP_CLEARENTRY = 217,
    SDL_SCANCODE_KP_BINARY = 218,
    SDL_SCANCODE_KP_OCTAL = 219,
    SDL_SCANCODE_KP_DECIMAL = 220,
    SDL_SCANCODE_KP_HEXADECIMAL = 221,
    SDL_SCANCODE_LCTRL = 224,
    SDL_SCANCODE_LSHIFT = 225,
    #[doc = "< alt, option"]
    SDL_SCANCODE_LALT = 226,
    #[doc = "< windows, command (apple), meta"]
    SDL_SCANCODE_LGUI = 227,
    SDL_SCANCODE_RCTRL = 228,
    SDL_SCANCODE_RSHIFT = 229,
    #[doc = "< alt gr, option"]
    SDL_SCANCODE_RALT = 230,
    #[doc = "< windows, command (apple), meta"]
    SDL_SCANCODE_RGUI = 231,
    #[doc = "< I'm not sure if this is really not covered"]
    #[doc = "   by any of the above, but since there's a"]
    #[doc = "   special KMOD_MODE for it I'm adding it here"]
    SDL_SCANCODE_MODE = 257,
    SDL_SCANCODE_AUDIONEXT = 258,
    SDL_SCANCODE_AUDIOPREV = 259,
    SDL_SCANCODE_AUDIOSTOP = 260,
    SDL_SCANCODE_AUDIOPLAY = 261,
    SDL_SCANCODE_AUDIOMUTE = 262,
    SDL_SCANCODE_MEDIASELECT = 263,
    SDL_SCANCODE_WWW = 264,
    SDL_SCANCODE_MAIL = 265,
    SDL_SCANCODE_CALCULATOR = 266,
    SDL_SCANCODE_COMPUTER = 267,
    SDL_SCANCODE_AC_SEARCH = 268,
    SDL_SCANCODE_AC_HOME = 269,
    SDL_SCANCODE_AC_BACK = 270,
    SDL_SCANCODE_AC_FORWARD = 271,
    SDL_SCANCODE_AC_STOP = 272,
    SDL_SCANCODE_AC_REFRESH = 273,
    SDL_SCANCODE_AC_BOOKMARKS = 274,
    SDL_SCANCODE_BRIGHTNESSDOWN = 275,
    SDL_SCANCODE_BRIGHTNESSUP = 276,
    #[doc = "< display mirroring/dual display"]
    #[doc = "switch, video mode switch"]
    SDL_SCANCODE_DISPLAYSWITCH = 277,
    SDL_SCANCODE_KBDILLUMTOGGLE = 278,
    SDL_SCANCODE_KBDILLUMDOWN = 279,
    SDL_SCANCODE_KBDILLUMUP = 280,
    SDL_SCANCODE_EJECT = 281,
    SDL_SCANCODE_SLEEP = 282,
    SDL_SCANCODE_APP1 = 283,
    SDL_SCANCODE_APP2 = 284,
    SDL_SCANCODE_AUDIOREWIND = 285,
    SDL_SCANCODE_AUDIOFASTFORWARD = 286,
    #[doc = "< not a key, just marks the number of scancodes"]
    #[doc = "for array bounds"]
    SDL_NUM_SCANCODES = 512,
}
#[doc = "  \\brief The SDL virtual key representation."]
#[doc = ""]
#[doc = "  Values of this type are used to represent keyboard keys using the current"]
#[doc = "  layout of the keyboard.  These values include Unicode values representing"]
#[doc = "  the unmodified character that would be generated by pressing the key, or"]
#[doc = "  an SDLK_* constant for those keys that do not generate characters."]
#[doc = ""]
#[doc = "  A special exception is the number keys at the top of the keyboard which"]
#[doc = "  always map to SDLK_0...SDLK_9, regardless of layout."]
pub type SDL_Keycode = Sint32;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_KeyCode {
    SDLK_UNKNOWN = 0,
    SDLK_RETURN = 13,
    SDLK_ESCAPE = 27,
    SDLK_BACKSPACE = 8,
    SDLK_TAB = 9,
    SDLK_SPACE = 32,
    SDLK_EXCLAIM = 33,
    SDLK_QUOTEDBL = 34,
    SDLK_HASH = 35,
    SDLK_PERCENT = 37,
    SDLK_DOLLAR = 36,
    SDLK_AMPERSAND = 38,
    SDLK_QUOTE = 39,
    SDLK_LEFTPAREN = 40,
    SDLK_RIGHTPAREN = 41,
    SDLK_ASTERISK = 42,
    SDLK_PLUS = 43,
    SDLK_COMMA = 44,
    SDLK_MINUS = 45,
    SDLK_PERIOD = 46,
    SDLK_SLASH = 47,
    SDLK_0 = 48,
    SDLK_1 = 49,
    SDLK_2 = 50,
    SDLK_3 = 51,
    SDLK_4 = 52,
    SDLK_5 = 53,
    SDLK_6 = 54,
    SDLK_7 = 55,
    SDLK_8 = 56,
    SDLK_9 = 57,
    SDLK_COLON = 58,
    SDLK_SEMICOLON = 59,
    SDLK_LESS = 60,
    SDLK_EQUALS = 61,
    SDLK_GREATER = 62,
    SDLK_QUESTION = 63,
    SDLK_AT = 64,
    SDLK_LEFTBRACKET = 91,
    SDLK_BACKSLASH = 92,
    SDLK_RIGHTBRACKET = 93,
    SDLK_CARET = 94,
    SDLK_UNDERSCORE = 95,
    SDLK_BACKQUOTE = 96,
    SDLK_a = 97,
    SDLK_b = 98,
    SDLK_c = 99,
    SDLK_d = 100,
    SDLK_e = 101,
    SDLK_f = 102,
    SDLK_g = 103,
    SDLK_h = 104,
    SDLK_i = 105,
    SDLK_j = 106,
    SDLK_k = 107,
    SDLK_l = 108,
    SDLK_m = 109,
    SDLK_n = 110,
    SDLK_o = 111,
    SDLK_p = 112,
    SDLK_q = 113,
    SDLK_r = 114,
    SDLK_s = 115,
    SDLK_t = 116,
    SDLK_u = 117,
    SDLK_v = 118,
    SDLK_w = 119,
    SDLK_x = 120,
    SDLK_y = 121,
    SDLK_z = 122,
    SDLK_CAPSLOCK = 1073741881,
    SDLK_F1 = 1073741882,
    SDLK_F2 = 1073741883,
    SDLK_F3 = 1073741884,
    SDLK_F4 = 1073741885,
    SDLK_F5 = 1073741886,
    SDLK_F6 = 1073741887,
    SDLK_F7 = 1073741888,
    SDLK_F8 = 1073741889,
    SDLK_F9 = 1073741890,
    SDLK_F10 = 1073741891,
    SDLK_F11 = 1073741892,
    SDLK_F12 = 1073741893,
    SDLK_PRINTSCREEN = 1073741894,
    SDLK_SCROLLLOCK = 1073741895,
    SDLK_PAUSE = 1073741896,
    SDLK_INSERT = 1073741897,
    SDLK_HOME = 1073741898,
    SDLK_PAGEUP = 1073741899,
    SDLK_DELETE = 127,
    SDLK_END = 1073741901,
    SDLK_PAGEDOWN = 1073741902,
    SDLK_RIGHT = 1073741903,
    SDLK_LEFT = 1073741904,
    SDLK_DOWN = 1073741905,
    SDLK_UP = 1073741906,
    SDLK_NUMLOCKCLEAR = 1073741907,
    SDLK_KP_DIVIDE = 1073741908,
    SDLK_KP_MULTIPLY = 1073741909,
    SDLK_KP_MINUS = 1073741910,
    SDLK_KP_PLUS = 1073741911,
    SDLK_KP_ENTER = 1073741912,
    SDLK_KP_1 = 1073741913,
    SDLK_KP_2 = 1073741914,
    SDLK_KP_3 = 1073741915,
    SDLK_KP_4 = 1073741916,
    SDLK_KP_5 = 1073741917,
    SDLK_KP_6 = 1073741918,
    SDLK_KP_7 = 1073741919,
    SDLK_KP_8 = 1073741920,
    SDLK_KP_9 = 1073741921,
    SDLK_KP_0 = 1073741922,
    SDLK_KP_PERIOD = 1073741923,
    SDLK_APPLICATION = 1073741925,
    SDLK_POWER = 1073741926,
    SDLK_KP_EQUALS = 1073741927,
    SDLK_F13 = 1073741928,
    SDLK_F14 = 1073741929,
    SDLK_F15 = 1073741930,
    SDLK_F16 = 1073741931,
    SDLK_F17 = 1073741932,
    SDLK_F18 = 1073741933,
    SDLK_F19 = 1073741934,
    SDLK_F20 = 1073741935,
    SDLK_F21 = 1073741936,
    SDLK_F22 = 1073741937,
    SDLK_F23 = 1073741938,
    SDLK_F24 = 1073741939,
    SDLK_EXECUTE = 1073741940,
    SDLK_HELP = 1073741941,
    SDLK_MENU = 1073741942,
    SDLK_SELECT = 1073741943,
    SDLK_STOP = 1073741944,
    SDLK_AGAIN = 1073741945,
    SDLK_UNDO = 1073741946,
    SDLK_CUT = 1073741947,
    SDLK_COPY = 1073741948,
    SDLK_PASTE = 1073741949,
    SDLK_FIND = 1073741950,
    SDLK_MUTE = 1073741951,
    SDLK_VOLUMEUP = 1073741952,
    SDLK_VOLUMEDOWN = 1073741953,
    SDLK_KP_COMMA = 1073741957,
    SDLK_KP_EQUALSAS400 = 1073741958,
    SDLK_ALTERASE = 1073741977,
    SDLK_SYSREQ = 1073741978,
    SDLK_CANCEL = 1073741979,
    SDLK_CLEAR = 1073741980,
    SDLK_PRIOR = 1073741981,
    SDLK_RETURN2 = 1073741982,
    SDLK_SEPARATOR = 1073741983,
    SDLK_OUT = 1073741984,
    SDLK_OPER = 1073741985,
    SDLK_CLEARAGAIN = 1073741986,
    SDLK_CRSEL = 1073741987,
    SDLK_EXSEL = 1073741988,
    SDLK_KP_00 = 1073742000,
    SDLK_KP_000 = 1073742001,
    SDLK_THOUSANDSSEPARATOR = 1073742002,
    SDLK_DECIMALSEPARATOR = 1073742003,
    SDLK_CURRENCYUNIT = 1073742004,
    SDLK_CURRENCYSUBUNIT = 1073742005,
    SDLK_KP_LEFTPAREN = 1073742006,
    SDLK_KP_RIGHTPAREN = 1073742007,
    SDLK_KP_LEFTBRACE = 1073742008,
    SDLK_KP_RIGHTBRACE = 1073742009,
    SDLK_KP_TAB = 1073742010,
    SDLK_KP_BACKSPACE = 1073742011,
    SDLK_KP_A = 1073742012,
    SDLK_KP_B = 1073742013,
    SDLK_KP_C = 1073742014,
    SDLK_KP_D = 1073742015,
    SDLK_KP_E = 1073742016,
    SDLK_KP_F = 1073742017,
    SDLK_KP_XOR = 1073742018,
    SDLK_KP_POWER = 1073742019,
    SDLK_KP_PERCENT = 1073742020,
    SDLK_KP_LESS = 1073742021,
    SDLK_KP_GREATER = 1073742022,
    SDLK_KP_AMPERSAND = 1073742023,
    SDLK_KP_DBLAMPERSAND = 1073742024,
    SDLK_KP_VERTICALBAR = 1073742025,
    SDLK_KP_DBLVERTICALBAR = 1073742026,
    SDLK_KP_COLON = 1073742027,
    SDLK_KP_HASH = 1073742028,
    SDLK_KP_SPACE = 1073742029,
    SDLK_KP_AT = 1073742030,
    SDLK_KP_EXCLAM = 1073742031,
    SDLK_KP_MEMSTORE = 1073742032,
    SDLK_KP_MEMRECALL = 1073742033,
    SDLK_KP_MEMCLEAR = 1073742034,
    SDLK_KP_MEMADD = 1073742035,
    SDLK_KP_MEMSUBTRACT = 1073742036,
    SDLK_KP_MEMMULTIPLY = 1073742037,
    SDLK_KP_MEMDIVIDE = 1073742038,
    SDLK_KP_PLUSMINUS = 1073742039,
    SDLK_KP_CLEAR = 1073742040,
    SDLK_KP_CLEARENTRY = 1073742041,
    SDLK_KP_BINARY = 1073742042,
    SDLK_KP_OCTAL = 1073742043,
    SDLK_KP_DECIMAL = 1073742044,
    SDLK_KP_HEXADECIMAL = 1073742045,
    SDLK_LCTRL = 1073742048,
    SDLK_LSHIFT = 1073742049,
    SDLK_LALT = 1073742050,
    SDLK_LGUI = 1073742051,
    SDLK_RCTRL = 1073742052,
    SDLK_RSHIFT = 1073742053,
    SDLK_RALT = 1073742054,
    SDLK_RGUI = 1073742055,
    SDLK_MODE = 1073742081,
    SDLK_AUDIONEXT = 1073742082,
    SDLK_AUDIOPREV = 1073742083,
    SDLK_AUDIOSTOP = 1073742084,
    SDLK_AUDIOPLAY = 1073742085,
    SDLK_AUDIOMUTE = 1073742086,
    SDLK_MEDIASELECT = 1073742087,
    SDLK_WWW = 1073742088,
    SDLK_MAIL = 1073742089,
    SDLK_CALCULATOR = 1073742090,
    SDLK_COMPUTER = 1073742091,
    SDLK_AC_SEARCH = 1073742092,
    SDLK_AC_HOME = 1073742093,
    SDLK_AC_BACK = 1073742094,
    SDLK_AC_FORWARD = 1073742095,
    SDLK_AC_STOP = 1073742096,
    SDLK_AC_REFRESH = 1073742097,
    SDLK_AC_BOOKMARKS = 1073742098,
    SDLK_BRIGHTNESSDOWN = 1073742099,
    SDLK_BRIGHTNESSUP = 1073742100,
    SDLK_DISPLAYSWITCH = 1073742101,
    SDLK_KBDILLUMTOGGLE = 1073742102,
    SDLK_KBDILLUMDOWN = 1073742103,
    SDLK_KBDILLUMUP = 1073742104,
    SDLK_EJECT = 1073742105,
    SDLK_SLEEP = 1073742106,
    SDLK_APP1 = 1073742107,
    SDLK_APP2 = 1073742108,
    SDLK_AUDIOREWIND = 1073742109,
    SDLK_AUDIOFASTFORWARD = 1073742110,
}
impl SDL_Keymod {
    pub const KMOD_RESERVED: SDL_Keymod = SDL_Keymod::KMOD_SCROLL;
}
#[repr(u32)]
#[doc = " \\brief Enumeration of valid key mods (possibly OR'd together)."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_Keymod {
    KMOD_NONE = 0,
    KMOD_LSHIFT = 1,
    KMOD_RSHIFT = 2,
    KMOD_LCTRL = 64,
    KMOD_RCTRL = 128,
    KMOD_LALT = 256,
    KMOD_RALT = 512,
    KMOD_LGUI = 1024,
    KMOD_RGUI = 2048,
    KMOD_NUM = 4096,
    KMOD_CAPS = 8192,
    KMOD_MODE = 16384,
    KMOD_SCROLL = 32768,
    KMOD_CTRL = 192,
    KMOD_SHIFT = 3,
    KMOD_ALT = 768,
    KMOD_GUI = 3072,
}
#[doc = "  \\brief The SDL keysym structure, used in key events."]
#[doc = ""]
#[doc = "  \\note  If you are looking for translated character input, see the ::SDL_TEXTINPUT event."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Keysym {
    #[doc = "< SDL physical key code - see ::SDL_Scancode for details"]
    pub scancode: SDL_Scancode,
    #[doc = "< SDL virtual key code - see ::SDL_Keycode for details"]
    pub sym: SDL_Keycode,
    #[doc = "< current key modifiers"]
    pub mod_: Uint16,
    pub unused: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_Keysym() {
    assert_eq!(
        ::core::mem::size_of::<SDL_Keysym>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_Keysym))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_Keysym>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_Keysym))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Keysym>())).scancode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Keysym),
            "::",
            stringify!(scancode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Keysym>())).sym as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Keysym),
            "::",
            stringify!(sym)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Keysym>())).mod_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Keysym),
            "::",
            stringify!(mod_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Keysym>())).unused as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Keysym),
            "::",
            stringify!(unused)
        )
    );
}
extern "C" {
    #[doc = " Query the window which currently has keyboard focus."]
    #[doc = ""]
    #[doc = " \\returns the window with keyboard focus."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_GetKeyboardFocus() -> *mut SDL_Window;
}
extern "C" {
    #[doc = " Get a snapshot of the current state of the keyboard."]
    #[doc = ""]
    #[doc = " The pointer returned is a pointer to an internal SDL array. It will be"]
    #[doc = " valid for the whole lifetime of the application and should not be freed by"]
    #[doc = " the caller."]
    #[doc = ""]
    #[doc = " A array element with a value of 1 means that the key is pressed and a value"]
    #[doc = " of 0 means that it is not. Indexes into this array are obtained by using"]
    #[doc = " SDL_Scancode values."]
    #[doc = ""]
    #[doc = " Use SDL_PumpEvents() to update the state array."]
    #[doc = ""]
    #[doc = " This function gives you the current state after all events have been"]
    #[doc = " processed, so if a key or button has been pressed and released before you"]
    #[doc = " process events, then the pressed state will never show up in the"]
    #[doc = " SDL_GetKeyboardState() calls."]
    #[doc = ""]
    #[doc = " Note: This function doesn't take into account whether shift has been"]
    #[doc = " pressed or not."]
    #[doc = ""]
    #[doc = " \\param numkeys if non-NULL, receives the length of the returned array"]
    #[doc = " \\returns a pointer to an array of key states."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_PumpEvents"]
    pub fn SDL_GetKeyboardState(numkeys: *mut libc::c_int) -> *const Uint8;
}
extern "C" {
    #[doc = " Get the current key modifier state for the keyboard."]
    #[doc = ""]
    #[doc = " \\returns an OR'd combination of the modifier keys for the keyboard. See"]
    #[doc = "          SDL_Keymod for details."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetKeyboardState"]
    #[doc = " \\sa SDL_SetModState"]
    pub fn SDL_GetModState() -> SDL_Keymod;
}
extern "C" {
    #[doc = " Set the current key modifier state for the keyboard."]
    #[doc = ""]
    #[doc = " The inverse of SDL_GetModState(), SDL_SetModState() allows you to impose"]
    #[doc = " modifier key states on your application. Simply pass your desired modifier"]
    #[doc = " states into `modstate`. This value may be a bitwise, OR'd combination of"]
    #[doc = " SDL_Keymod values."]
    #[doc = ""]
    #[doc = " This does not change the keyboard state, only the key modifier flags that"]
    #[doc = " SDL reports."]
    #[doc = ""]
    #[doc = " \\param modstate the desired SDL_Keymod for the keyboard"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetModState"]
    pub fn SDL_SetModState(modstate: SDL_Keymod);
}
extern "C" {
    #[doc = " Get the key code corresponding to the given scancode according to the"]
    #[doc = " current keyboard layout."]
    #[doc = ""]
    #[doc = " See SDL_Keycode for details."]
    #[doc = ""]
    #[doc = " \\param scancode the desired SDL_Scancode to query"]
    #[doc = " \\returns the SDL_Keycode that corresponds to the given SDL_Scancode."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetKeyName"]
    #[doc = " \\sa SDL_GetScancodeFromKey"]
    pub fn SDL_GetKeyFromScancode(scancode: SDL_Scancode) -> SDL_Keycode;
}
extern "C" {
    #[doc = " Get the scancode corresponding to the given key code according to the"]
    #[doc = " current keyboard layout."]
    #[doc = ""]
    #[doc = " See SDL_Scancode for details."]
    #[doc = ""]
    #[doc = " \\param key the desired SDL_Keycode to query"]
    #[doc = " \\returns the SDL_Scancode that corresponds to the given SDL_Keycode."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetKeyFromScancode"]
    #[doc = " \\sa SDL_GetScancodeName"]
    pub fn SDL_GetScancodeFromKey(key: SDL_Keycode) -> SDL_Scancode;
}
extern "C" {
    #[doc = " Get a human-readable name for a scancode."]
    #[doc = ""]
    #[doc = " See SDL_Scancode for details."]
    #[doc = ""]
    #[doc = " **Warning**: The returned name is by design not stable across platforms,"]
    #[doc = " e.g. the name for `SDL_SCANCODE_LGUI` is \"Left GUI\" under Linux but \"Left"]
    #[doc = " Windows\" under Microsoft Windows, and some scancodes like"]
    #[doc = " `SDL_SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even"]
    #[doc = " scancodes that share names, e.g. `SDL_SCANCODE_RETURN` and"]
    #[doc = " `SDL_SCANCODE_RETURN2` (both called \"Return\"). This function is therefore"]
    #[doc = " unsuitable for creating a stable cross-platform two-way mapping between"]
    #[doc = " strings and scancodes."]
    #[doc = ""]
    #[doc = " \\param scancode the desired SDL_Scancode to query"]
    #[doc = " \\returns a pointer to the name for the scancode. If the scancode doesn't"]
    #[doc = "          have a name this function returns an empty string (\"\")."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetScancodeFromKey"]
    #[doc = " \\sa SDL_GetScancodeFromName"]
    pub fn SDL_GetScancodeName(scancode: SDL_Scancode) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get a scancode from a human-readable name."]
    #[doc = ""]
    #[doc = " \\param name the human-readable scancode name"]
    #[doc = " \\returns the SDL_Scancode, or `SDL_SCANCODE_UNKNOWN` if the name wasn't"]
    #[doc = "          recognized; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetKeyFromName"]
    #[doc = " \\sa SDL_GetScancodeFromKey"]
    #[doc = " \\sa SDL_GetScancodeName"]
    pub fn SDL_GetScancodeFromName(name: *const libc::c_char) -> SDL_Scancode;
}
extern "C" {
    #[doc = " Get a human-readable name for a key."]
    #[doc = ""]
    #[doc = " See SDL_Scancode and SDL_Keycode for details."]
    #[doc = ""]
    #[doc = " \\param key the desired SDL_Keycode to query"]
    #[doc = " \\returns a pointer to a UTF-8 string that stays valid at least until the"]
    #[doc = "          next call to this function. If you need it around any longer, you"]
    #[doc = "          must copy it. If the key doesn't have a name, this function"]
    #[doc = "          returns an empty string (\"\")."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetKeyFromName"]
    #[doc = " \\sa SDL_GetKeyFromScancode"]
    #[doc = " \\sa SDL_GetScancodeFromKey"]
    pub fn SDL_GetKeyName(key: SDL_Keycode) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get a key code from a human-readable name."]
    #[doc = ""]
    #[doc = " \\param name the human-readable key name"]
    #[doc = " \\returns key code, or `SDLK_UNKNOWN` if the name wasn't recognized; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetKeyFromScancode"]
    #[doc = " \\sa SDL_GetKeyName"]
    #[doc = " \\sa SDL_GetScancodeFromName"]
    pub fn SDL_GetKeyFromName(name: *const libc::c_char) -> SDL_Keycode;
}
extern "C" {
    #[doc = " Start accepting Unicode text input events."]
    #[doc = ""]
    #[doc = " This function will start accepting Unicode text input events in the focused"]
    #[doc = " SDL window, and start emitting SDL_TextInputEvent (SDL_TEXTINPUT) and"]
    #[doc = " SDL_TextEditingEvent (SDL_TEXTEDITING) events. Please use this function in"]
    #[doc = " pair with SDL_StopTextInput()."]
    #[doc = ""]
    #[doc = " On some platforms using this function activates the screen keyboard."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_SetTextInputRect"]
    #[doc = " \\sa SDL_StopTextInput"]
    pub fn SDL_StartTextInput();
}
extern "C" {
    #[doc = " Check whether or not Unicode text input events are enabled."]
    #[doc = ""]
    #[doc = " \\returns SDL_TRUE if text input events are enabled else SDL_FALSE."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_StartTextInput"]
    pub fn SDL_IsTextInputActive() -> SDL_bool;
}
extern "C" {
    #[doc = " Stop receiving any text input events."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_StartTextInput"]
    pub fn SDL_StopTextInput();
}
extern "C" {
    #[doc = " Set the rectangle used to type Unicode text inputs."]
    #[doc = ""]
    #[doc = " \\param rect the SDL_Rect structure representing the rectangle to receive"]
    #[doc = "             text (ignored if NULL)"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_StartTextInput"]
    pub fn SDL_SetTextInputRect(rect: *mut SDL_Rect);
}
extern "C" {
    #[doc = " Check whether the platform has screen keyboard support."]
    #[doc = ""]
    #[doc = " \\returns SDL_TRUE if the platform has some screen keyboard support or"]
    #[doc = "          SDL_FALSE if not."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_StartTextInput"]
    #[doc = " \\sa SDL_IsScreenKeyboardShown"]
    pub fn SDL_HasScreenKeyboardSupport() -> SDL_bool;
}
extern "C" {
    #[doc = " Check whether the screen keyboard is shown for given window."]
    #[doc = ""]
    #[doc = " \\param window the window for which screen keyboard should be queried"]
    #[doc = " \\returns SDL_TRUE if screen keyboard is shown or SDL_FALSE if not."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HasScreenKeyboardSupport"]
    pub fn SDL_IsScreenKeyboardShown(window: *mut SDL_Window) -> SDL_bool;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Cursor {
    _unused: [u8; 0],
}
#[repr(u32)]
#[doc = " \\brief Cursor types for SDL_CreateSystemCursor()."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_SystemCursor {
    #[doc = "< Arrow"]
    SDL_SYSTEM_CURSOR_ARROW = 0,
    #[doc = "< I-beam"]
    SDL_SYSTEM_CURSOR_IBEAM = 1,
    #[doc = "< Wait"]
    SDL_SYSTEM_CURSOR_WAIT = 2,
    #[doc = "< Crosshair"]
    SDL_SYSTEM_CURSOR_CROSSHAIR = 3,
    #[doc = "< Small wait cursor (or Wait if not available)"]
    SDL_SYSTEM_CURSOR_WAITARROW = 4,
    #[doc = "< Double arrow pointing northwest and southeast"]
    SDL_SYSTEM_CURSOR_SIZENWSE = 5,
    #[doc = "< Double arrow pointing northeast and southwest"]
    SDL_SYSTEM_CURSOR_SIZENESW = 6,
    #[doc = "< Double arrow pointing west and east"]
    SDL_SYSTEM_CURSOR_SIZEWE = 7,
    #[doc = "< Double arrow pointing north and south"]
    SDL_SYSTEM_CURSOR_SIZENS = 8,
    #[doc = "< Four pointed arrow pointing north, south, east, and west"]
    SDL_SYSTEM_CURSOR_SIZEALL = 9,
    #[doc = "< Slashed circle or crossbones"]
    SDL_SYSTEM_CURSOR_NO = 10,
    #[doc = "< Hand"]
    SDL_SYSTEM_CURSOR_HAND = 11,
    SDL_NUM_SYSTEM_CURSORS = 12,
}
#[repr(u32)]
#[doc = " \\brief Scroll direction types for the Scroll event"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_MouseWheelDirection {
    #[doc = "< The scroll direction is normal"]
    SDL_MOUSEWHEEL_NORMAL = 0,
    #[doc = "< The scroll direction is flipped / natural"]
    SDL_MOUSEWHEEL_FLIPPED = 1,
}
extern "C" {
    #[doc = " Get the window which currently has mouse focus."]
    #[doc = ""]
    #[doc = " \\returns the window with mouse focus."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_GetMouseFocus() -> *mut SDL_Window;
}
extern "C" {
    #[doc = " Retrieve the current state of the mouse."]
    #[doc = ""]
    #[doc = " The current button state is returned as a button bitmask, which can be"]
    #[doc = " tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the"]
    #[doc = " left, 2 for middle, 3 for the right button), and `x` and `y` are set to the"]
    #[doc = " mouse cursor position relative to the focus window. You can pass NULL for"]
    #[doc = " either `x` or `y`."]
    #[doc = ""]
    #[doc = " \\param x the x coordinate of the mouse cursor position relative to the"]
    #[doc = "          focus window"]
    #[doc = " \\param y the y coordinate of the mouse cursor position relative to the"]
    #[doc = "          focus window"]
    #[doc = " \\returns a 32-bit button bitmask of the current button state."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetGlobalMouseState"]
    #[doc = " \\sa SDL_GetRelativeMouseState"]
    #[doc = " \\sa SDL_PumpEvents"]
    pub fn SDL_GetMouseState(x: *mut libc::c_int, y: *mut libc::c_int) -> Uint32;
}
extern "C" {
    #[doc = " Get the current state of the mouse in relation to the desktop."]
    #[doc = ""]
    #[doc = " This works similarly to SDL_GetMouseState(), but the coordinates will be"]
    #[doc = " reported relative to the top-left of the desktop. This can be useful if you"]
    #[doc = " need to track the mouse outside of a specific window and SDL_CaptureMouse()"]
    #[doc = " doesn't fit your needs. For example, it could be useful if you need to"]
    #[doc = " track the mouse while dragging a window, where coordinates relative to a"]
    #[doc = " window might not be in sync at all times."]
    #[doc = ""]
    #[doc = " Note: SDL_GetMouseState() returns the mouse position as SDL understands it"]
    #[doc = " from the last pump of the event queue. This function, however, queries the"]
    #[doc = " OS for the current mouse position, and as such, might be a slightly less"]
    #[doc = " efficient function. Unless you know what you're doing and have a good"]
    #[doc = " reason to use this function, you probably want SDL_GetMouseState() instead."]
    #[doc = ""]
    #[doc = " \\param x filled in with the current X coord relative to the desktop; can be"]
    #[doc = "          NULL"]
    #[doc = " \\param y filled in with the current Y coord relative to the desktop; can be"]
    #[doc = "          NULL"]
    #[doc = " \\returns the current button state as a bitmask which can be tested using"]
    #[doc = "          the SDL_BUTTON(X) macros."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.4."]
    #[doc = ""]
    #[doc = " \\sa SDL_CaptureMouse"]
    pub fn SDL_GetGlobalMouseState(x: *mut libc::c_int, y: *mut libc::c_int) -> Uint32;
}
extern "C" {
    #[doc = " Retrieve the relative state of the mouse."]
    #[doc = ""]
    #[doc = " The current button state is returned as a button bitmask, which can be"]
    #[doc = " tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the"]
    #[doc = " left, 2 for middle, 3 for the right button), and `x` and `y` are set to the"]
    #[doc = " mouse deltas since the last call to SDL_GetRelativeMouseState() or since"]
    #[doc = " event initialization. You can pass NULL for either `x` or `y`."]
    #[doc = ""]
    #[doc = " \\param x a pointer filled with the last recorded x coordinate of the mouse"]
    #[doc = " \\param y a pointer filled with the last recorded y coordinate of the mouse"]
    #[doc = " \\returns a 32-bit button bitmask of the relative button state."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetMouseState"]
    pub fn SDL_GetRelativeMouseState(x: *mut libc::c_int, y: *mut libc::c_int) -> Uint32;
}
extern "C" {
    #[doc = " Move the mouse cursor to the given position within the window."]
    #[doc = ""]
    #[doc = " This function generates a mouse motion event."]
    #[doc = ""]
    #[doc = " Note that this function will appear to succeed, but not actually move the"]
    #[doc = " mouse when used over Microsoft Remote Desktop."]
    #[doc = ""]
    #[doc = " \\param window the window to move the mouse into, or NULL for the current"]
    #[doc = "               mouse focus"]
    #[doc = " \\param x the x coordinate within the window"]
    #[doc = " \\param y the y coordinate within the window"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_WarpMouseGlobal"]
    pub fn SDL_WarpMouseInWindow(window: *mut SDL_Window, x: libc::c_int, y: libc::c_int);
}
extern "C" {
    #[doc = " Move the mouse to the given position in global screen space."]
    #[doc = ""]
    #[doc = " This function generates a mouse motion event."]
    #[doc = ""]
    #[doc = " A failure of this function usually means that it is unsupported by a"]
    #[doc = " platform."]
    #[doc = ""]
    #[doc = " Note that this function will appear to succeed, but not actually move the"]
    #[doc = " mouse when used over Microsoft Remote Desktop."]
    #[doc = ""]
    #[doc = " \\param x the x coordinate"]
    #[doc = " \\param y the y coordinate"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.4."]
    #[doc = ""]
    #[doc = " \\sa SDL_WarpMouseInWindow"]
    pub fn SDL_WarpMouseGlobal(x: libc::c_int, y: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Set relative mouse mode."]
    #[doc = ""]
    #[doc = " While the mouse is in relative mode, the cursor is hidden, and the driver"]
    #[doc = " will try to report continuous motion in the current window. Only relative"]
    #[doc = " motion events will be delivered, the mouse position will not change."]
    #[doc = ""]
    #[doc = " Note that this function will not be able to provide continuous relative"]
    #[doc = " motion when used over Microsoft Remote Desktop, instead motion is limited"]
    #[doc = " to the bounds of the screen."]
    #[doc = ""]
    #[doc = " This function will flush any pending mouse motion."]
    #[doc = ""]
    #[doc = " \\param enabled SDL_TRUE to enable relative mode, SDL_FALSE to disable."]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = "          If relative mode is not supported, this returns -1."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetRelativeMouseMode"]
    pub fn SDL_SetRelativeMouseMode(enabled: SDL_bool) -> libc::c_int;
}
extern "C" {
    #[doc = " Capture the mouse and to track input outside an SDL window."]
    #[doc = ""]
    #[doc = " Capturing enables your app to obtain mouse events globally, instead of just"]
    #[doc = " within your window. Not all video targets support this function. When"]
    #[doc = " capturing is enabled, the current window will get all mouse events, but"]
    #[doc = " unlike relative mode, no change is made to the cursor and it is not"]
    #[doc = " restrained to your window."]
    #[doc = ""]
    #[doc = " This function may also deny mouse input to other windows--both those in"]
    #[doc = " your application and others on the system--so you should use this function"]
    #[doc = " sparingly, and in small bursts. For example, you might want to track the"]
    #[doc = " mouse while the user is dragging something, until the user releases a mouse"]
    #[doc = " button. It is not recommended that you capture the mouse for long periods"]
    #[doc = " of time, such as the entire time your app is running. For that, you should"]
    #[doc = " probably use SDL_SetRelativeMouseMode() or SDL_SetWindowGrab(), depending"]
    #[doc = " on your goals."]
    #[doc = ""]
    #[doc = " While captured, mouse events still report coordinates relative to the"]
    #[doc = " current (foreground) window, but those coordinates may be outside the"]
    #[doc = " bounds of the window (including negative values). Capturing is only allowed"]
    #[doc = " for the foreground window. If the window loses focus while capturing, the"]
    #[doc = " capture will be disabled automatically."]
    #[doc = ""]
    #[doc = " While capturing is enabled, the current window will have the"]
    #[doc = " `SDL_WINDOW_MOUSE_CAPTURE` flag set."]
    #[doc = ""]
    #[doc = " \\param enabled SDL_TRUE to enable capturing, SDL_FALSE to disable."]
    #[doc = " \\returns 0 on success or -1 if not supported; call SDL_GetError() for more"]
    #[doc = "          information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.4."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetGlobalMouseState"]
    pub fn SDL_CaptureMouse(enabled: SDL_bool) -> libc::c_int;
}
extern "C" {
    #[doc = " Query whether relative mouse mode is enabled."]
    #[doc = ""]
    #[doc = " \\returns SDL_TRUE if relative mode is enabled or SDL_FALSE otherwise."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_SetRelativeMouseMode"]
    pub fn SDL_GetRelativeMouseMode() -> SDL_bool;
}
extern "C" {
    #[doc = " Create a cursor using the specified bitmap data and mask (in MSB format)."]
    #[doc = ""]
    #[doc = " `mask` has to be in MSB (Most Significant Bit) format."]
    #[doc = ""]
    #[doc = " The cursor width (`w`) must be a multiple of 8 bits."]
    #[doc = ""]
    #[doc = " The cursor is created in black and white according to the following:"]
    #[doc = ""]
    #[doc = " - data=0, mask=1: white"]
    #[doc = " - data=1, mask=1: black"]
    #[doc = " - data=0, mask=0: transparent"]
    #[doc = " - data=1, mask=0: inverted color if possible, black if not."]
    #[doc = ""]
    #[doc = " Cursors created with this function must be freed with SDL_FreeCursor()."]
    #[doc = ""]
    #[doc = " If you want to have a color cursor, or create your cursor from an"]
    #[doc = " SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can"]
    #[doc = " hide the cursor and draw your own as part of your game's rendering, but it"]
    #[doc = " will be bound to the framerate."]
    #[doc = ""]
    #[doc = " Also, since SDL 2.0.0, SDL_CreateSystemCursor() is available, which"]
    #[doc = " provides twelve readily available system cursors to pick from."]
    #[doc = ""]
    #[doc = " \\param data the color value for each pixel of the cursor"]
    #[doc = " \\param mask the mask value for each pixel of the cursor"]
    #[doc = " \\param w the width of the cursor"]
    #[doc = " \\param h the height of the cursor"]
    #[doc = " \\param hot_x the X-axis location of the upper left corner of the cursor"]
    #[doc = "              relative to the actual mouse position"]
    #[doc = " \\param hot_y the Y-axis location of the upper left corner of the cursor"]
    #[doc = "              relative to the actual mouse position"]
    #[doc = " \\returns a new cursor with the specified parameters on success or NULL on"]
    #[doc = "          failure; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_FreeCursor"]
    #[doc = " \\sa SDL_SetCursor"]
    #[doc = " \\sa SDL_ShowCursor"]
    pub fn SDL_CreateCursor(
        data: *const Uint8,
        mask: *const Uint8,
        w: libc::c_int,
        h: libc::c_int,
        hot_x: libc::c_int,
        hot_y: libc::c_int,
    ) -> *mut SDL_Cursor;
}
extern "C" {
    #[doc = " Create a color cursor."]
    #[doc = ""]
    #[doc = " \\param surface an SDL_Surface structure representing the cursor image"]
    #[doc = " \\param hot_x the x position of the cursor hot spot"]
    #[doc = " \\param hot_y the y position of the cursor hot spot"]
    #[doc = " \\returns the new cursor on success or NULL on failure; call SDL_GetError()"]
    #[doc = "          for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateCursor"]
    #[doc = " \\sa SDL_FreeCursor"]
    pub fn SDL_CreateColorCursor(
        surface: *mut SDL_Surface,
        hot_x: libc::c_int,
        hot_y: libc::c_int,
    ) -> *mut SDL_Cursor;
}
extern "C" {
    #[doc = " Create a system cursor."]
    #[doc = ""]
    #[doc = " \\param id an SDL_SystemCursor enum value"]
    #[doc = " \\returns a cursor on success or NULL on failure; call SDL_GetError() for"]
    #[doc = "          more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_FreeCursor"]
    pub fn SDL_CreateSystemCursor(id: SDL_SystemCursor) -> *mut SDL_Cursor;
}
extern "C" {
    #[doc = " Set the active cursor."]
    #[doc = ""]
    #[doc = " This function sets the currently active cursor to the specified one. If the"]
    #[doc = " cursor is currently visible, the change will be immediately represented on"]
    #[doc = " the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if"]
    #[doc = " this is desired for any reason."]
    #[doc = ""]
    #[doc = " \\param cursor a cursor to make active"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateCursor"]
    #[doc = " \\sa SDL_GetCursor"]
    #[doc = " \\sa SDL_ShowCursor"]
    pub fn SDL_SetCursor(cursor: *mut SDL_Cursor);
}
extern "C" {
    #[doc = " Get the active cursor."]
    #[doc = ""]
    #[doc = " This function returns a pointer to the current cursor which is owned by the"]
    #[doc = " library. It is not necessary to free the cursor with SDL_FreeCursor()."]
    #[doc = ""]
    #[doc = " \\returns the active cursor or NULL if there is no mouse."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_SetCursor"]
    pub fn SDL_GetCursor() -> *mut SDL_Cursor;
}
extern "C" {
    #[doc = " Get the default cursor."]
    #[doc = ""]
    #[doc = " \\returns the default cursor on success or NULL on failure."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateSystemCursor"]
    pub fn SDL_GetDefaultCursor() -> *mut SDL_Cursor;
}
extern "C" {
    #[doc = " Free a previously-created cursor."]
    #[doc = ""]
    #[doc = " Use this function to free cursor resources created with SDL_CreateCursor(),"]
    #[doc = " SDL_CreateColorCursor() or SDL_CreateSystemCursor()."]
    #[doc = ""]
    #[doc = " \\param cursor the cursor to free"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateColorCursor"]
    #[doc = " \\sa SDL_CreateCursor"]
    #[doc = " \\sa SDL_CreateSystemCursor"]
    pub fn SDL_FreeCursor(cursor: *mut SDL_Cursor);
}
extern "C" {
    #[doc = " Toggle whether or not the cursor is shown."]
    #[doc = ""]
    #[doc = " The cursor starts off displayed but can be turned off. Passing `SDL_ENABLE`"]
    #[doc = " displays the cursor and passing `SDL_DISABLE` hides it."]
    #[doc = ""]
    #[doc = " The current state of the mouse cursor can be queried by passing"]
    #[doc = " `SDL_QUERY`; either `SDL_DISABLE` or `SDL_ENABLE` will be returned."]
    #[doc = ""]
    #[doc = " \\param toggle `SDL_ENABLE` to show the cursor, `SDL_DISABLE` to hide it,"]
    #[doc = "               `SDL_QUERY` to query the current state without changing it."]
    #[doc = " \\returns `SDL_ENABLE` if the cursor is shown, or `SDL_DISABLE` if the"]
    #[doc = "          cursor is hidden, or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateCursor"]
    #[doc = " \\sa SDL_SetCursor"]
    pub fn SDL_ShowCursor(toggle: libc::c_int) -> libc::c_int;
}
#[doc = " The joystick structure used to identify an SDL joystick"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SDL_Joystick {
    _unused: [u8; 0],
}
pub type SDL_Joystick = _SDL_Joystick;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_JoystickGUID {
    pub data: [Uint8; 16usize],
}
#[test]
fn bindgen_test_layout_SDL_JoystickGUID() {
    assert_eq!(
        ::core::mem::size_of::<SDL_JoystickGUID>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_JoystickGUID))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_JoystickGUID>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_JoystickGUID))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoystickGUID>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoystickGUID),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " This is a unique ID for a joystick for the time it is connected to the system,"]
#[doc = " and is never reused for the lifetime of the application. If the joystick is"]
#[doc = " disconnected and reconnected, it will get a new ID."]
#[doc = ""]
#[doc = " The ID value starts at 0 and increments from there. The value -1 is an invalid ID."]
pub type SDL_JoystickID = Sint32;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_JoystickType {
    SDL_JOYSTICK_TYPE_UNKNOWN = 0,
    SDL_JOYSTICK_TYPE_GAMECONTROLLER = 1,
    SDL_JOYSTICK_TYPE_WHEEL = 2,
    SDL_JOYSTICK_TYPE_ARCADE_STICK = 3,
    SDL_JOYSTICK_TYPE_FLIGHT_STICK = 4,
    SDL_JOYSTICK_TYPE_DANCE_PAD = 5,
    SDL_JOYSTICK_TYPE_GUITAR = 6,
    SDL_JOYSTICK_TYPE_DRUM_KIT = 7,
    SDL_JOYSTICK_TYPE_ARCADE_PAD = 8,
    SDL_JOYSTICK_TYPE_THROTTLE = 9,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_JoystickPowerLevel {
    SDL_JOYSTICK_POWER_UNKNOWN = -1,
    SDL_JOYSTICK_POWER_EMPTY = 0,
    SDL_JOYSTICK_POWER_LOW = 1,
    SDL_JOYSTICK_POWER_MEDIUM = 2,
    SDL_JOYSTICK_POWER_FULL = 3,
    SDL_JOYSTICK_POWER_WIRED = 4,
    SDL_JOYSTICK_POWER_MAX = 5,
}
extern "C" {
    #[doc = " Locking for multi-threaded access to the joystick API"]
    #[doc = ""]
    #[doc = " If you are using the joystick API or handling events from multiple threads"]
    #[doc = " you should use these locking functions to protect access to the joysticks."]
    #[doc = ""]
    #[doc = " In particular, you are guaranteed that the joystick list won't change, so"]
    #[doc = " the API functions that take a joystick index will be valid, and joystick"]
    #[doc = " and game controller events will not be delivered."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.7."]
    pub fn SDL_LockJoysticks();
}
extern "C" {
    #[doc = " Unlocking for multi-threaded access to the joystick API"]
    #[doc = ""]
    #[doc = " If you are using the joystick API or handling events from multiple threads"]
    #[doc = " you should use these locking functions to protect access to the joysticks."]
    #[doc = ""]
    #[doc = " In particular, you are guaranteed that the joystick list won't change, so"]
    #[doc = " the API functions that take a joystick index will be valid, and joystick"]
    #[doc = " and game controller events will not be delivered."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.7."]
    pub fn SDL_UnlockJoysticks();
}
extern "C" {
    #[doc = " Count the number of joysticks attached to the system."]
    #[doc = ""]
    #[doc = " \\returns the number of attached joysticks on success or a negative error"]
    #[doc = "          code on failure; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_JoystickName"]
    #[doc = " \\sa SDL_JoystickOpen"]
    pub fn SDL_NumJoysticks() -> libc::c_int;
}
extern "C" {
    #[doc = " Get the implementation dependent name of a joystick."]
    #[doc = ""]
    #[doc = " This can be called before any joysticks are opened."]
    #[doc = ""]
    #[doc = " \\param device_index the index of the joystick to query (the N'th joystick"]
    #[doc = "                     on the system)"]
    #[doc = " \\returns the name of the selected joystick. If no name can be found, this"]
    #[doc = "          function returns NULL; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_JoystickName"]
    #[doc = " \\sa SDL_JoystickOpen"]
    pub fn SDL_JoystickNameForIndex(device_index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the player index of a joystick, or -1 if it's not available This can be"]
    #[doc = " called before any joysticks are opened."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.9."]
    pub fn SDL_JoystickGetDevicePlayerIndex(device_index: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the implementation-dependent GUID for the joystick at a given device"]
    #[doc = " index."]
    #[doc = ""]
    #[doc = " This function can be called before any joysticks are opened."]
    #[doc = ""]
    #[doc = " \\param device_index the index of the joystick to query (the N'th joystick"]
    #[doc = "                     on the system"]
    #[doc = " \\returns the GUID of the selected joystick. If called on an invalid index,"]
    #[doc = "          this function returns a zero GUID"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_JoystickGetGUID"]
    #[doc = " \\sa SDL_JoystickGetGUIDString"]
    pub fn SDL_JoystickGetDeviceGUID(device_index: libc::c_int) -> SDL_JoystickGUID;
}
extern "C" {
    #[doc = " Get the USB vendor ID of a joystick, if available."]
    #[doc = ""]
    #[doc = " This can be called before any joysticks are opened. If the vendor ID isn't"]
    #[doc = " available this function returns 0."]
    #[doc = ""]
    #[doc = " \\param device_index the index of the joystick to query (the N'th joystick"]
    #[doc = "                     on the system"]
    #[doc = " \\returns the USB vendor ID of the selected joystick. If called on an"]
    #[doc = "          invalid index, this function returns zero"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.6."]
    pub fn SDL_JoystickGetDeviceVendor(device_index: libc::c_int) -> Uint16;
}
extern "C" {
    #[doc = " Get the USB product ID of a joystick, if available."]
    #[doc = ""]
    #[doc = " This can be called before any joysticks are opened. If the product ID isn't"]
    #[doc = " available this function returns 0."]
    #[doc = ""]
    #[doc = " \\param device_index the index of the joystick to query (the N'th joystick"]
    #[doc = "                     on the system"]
    #[doc = " \\returns the USB product ID of the selected joystick. If called on an"]
    #[doc = "          invalid index, this function returns zero"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.6."]
    pub fn SDL_JoystickGetDeviceProduct(device_index: libc::c_int) -> Uint16;
}
extern "C" {
    #[doc = " Get the product version of a joystick, if available."]
    #[doc = ""]
    #[doc = " This can be called before any joysticks are opened. If the product version"]
    #[doc = " isn't available this function returns 0."]
    #[doc = ""]
    #[doc = " \\param device_index the index of the joystick to query (the N'th joystick"]
    #[doc = "                     on the system"]
    #[doc = " \\returns the product version of the selected joystick. If called on an"]
    #[doc = "          invalid index, this function returns zero"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.6."]
    pub fn SDL_JoystickGetDeviceProductVersion(device_index: libc::c_int) -> Uint16;
}
extern "C" {
    #[doc = " Get the type of a joystick, if available."]
    #[doc = ""]
    #[doc = " This can be called before any joysticks are opened."]
    #[doc = ""]
    #[doc = " \\param device_index the index of the joystick to query (the N'th joystick"]
    #[doc = "                     on the system"]
    #[doc = " \\returns the SDL_JoystickType of the selected joystick. If called on an"]
    #[doc = "          invalid index, this function returns `SDL_JOYSTICK_TYPE_UNKNOWN`"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.6."]
    pub fn SDL_JoystickGetDeviceType(device_index: libc::c_int) -> SDL_JoystickType;
}
extern "C" {
    #[doc = " Get the instance ID of a joystick."]
    #[doc = ""]
    #[doc = " This can be called before any joysticks are opened. If the index is out of"]
    #[doc = " range, this function will return -1."]
    #[doc = ""]
    #[doc = " \\param device_index the index of the joystick to query (the N'th joystick"]
    #[doc = "                     on the system"]
    #[doc = " \\returns the instance id of the selected joystick. If called on an invalid"]
    #[doc = "          index, this function returns zero"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.6."]
    pub fn SDL_JoystickGetDeviceInstanceID(device_index: libc::c_int) -> SDL_JoystickID;
}
extern "C" {
    #[doc = " Open a joystick for use."]
    #[doc = ""]
    #[doc = " The `device_index` argument refers to the N'th joystick presently"]
    #[doc = " recognized by SDL on the system. It is **NOT** the same as the instance ID"]
    #[doc = " used to identify the joystick in future events. See"]
    #[doc = " SDL_JoystickInstanceID() for more details about instance IDs."]
    #[doc = ""]
    #[doc = " The joystick subsystem must be initialized before a joystick can be opened"]
    #[doc = " for use."]
    #[doc = ""]
    #[doc = " \\param device_index the index of the joystick to query"]
    #[doc = " \\returns a joystick identifier or NULL if an error occurred; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_JoystickClose"]
    #[doc = " \\sa SDL_JoystickInstanceID"]
    pub fn SDL_JoystickOpen(device_index: libc::c_int) -> *mut SDL_Joystick;
}
extern "C" {
    #[doc = " Get the SDL_Joystick associated with an instance id."]
    #[doc = ""]
    #[doc = " \\param instance_id the instance id to get the SDL_Joystick for"]
    #[doc = " \\returns an SDL_Joystick on success or NULL on failure; call SDL_GetError()"]
    #[doc = "          for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.4."]
    pub fn SDL_JoystickFromInstanceID(instance_id: SDL_JoystickID) -> *mut SDL_Joystick;
}
extern "C" {
    #[doc = " Get the SDL_Joystick associated with a player index."]
    #[doc = ""]
    #[doc = " \\param player_index the player index to get the SDL_Joystick for"]
    #[doc = " \\returns an SDL_Joystick on success or NULL on failure; call SDL_GetError()"]
    #[doc = "          for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.12."]
    pub fn SDL_JoystickFromPlayerIndex(player_index: libc::c_int) -> *mut SDL_Joystick;
}
extern "C" {
    #[doc = " Attach a new virtual joystick."]
    #[doc = ""]
    #[doc = " \\returns the joystick's device index, or -1 if an error occurred."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.14."]
    pub fn SDL_JoystickAttachVirtual(
        type_: SDL_JoystickType,
        naxes: libc::c_int,
        nbuttons: libc::c_int,
        nhats: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Detach a virtual joystick."]
    #[doc = ""]
    #[doc = " \\param device_index a value previously returned from"]
    #[doc = "                     SDL_JoystickAttachVirtual()"]
    #[doc = " \\returns 0 on success, or -1 if an error occurred."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.14."]
    pub fn SDL_JoystickDetachVirtual(device_index: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Query whether or not the joystick at a given device index is virtual."]
    #[doc = ""]
    #[doc = " \\param device_index a joystick device index."]
    #[doc = " \\returns SDL_TRUE if the joystick is virtual, SDL_FALSE otherwise."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.14."]
    pub fn SDL_JoystickIsVirtual(device_index: libc::c_int) -> SDL_bool;
}
extern "C" {
    #[doc = " Set values on an opened, virtual-joystick's axis."]
    #[doc = ""]
    #[doc = " Please note that values set here will not be applied until the next call to"]
    #[doc = " SDL_JoystickUpdate, which can either be called directly, or can be called"]
    #[doc = " indirectly through various other SDL APIs, including, but not limited to"]
    #[doc = " the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,"]
    #[doc = " SDL_WaitEvent."]
    #[doc = ""]
    #[doc = " \\param joystick the virtual joystick on which to set state."]
    #[doc = " \\param axis the specific axis on the virtual joystick to set."]
    #[doc = " \\param value the new value for the specified axis."]
    #[doc = " \\returns 0 on success, -1 on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.14."]
    pub fn SDL_JoystickSetVirtualAxis(
        joystick: *mut SDL_Joystick,
        axis: libc::c_int,
        value: Sint16,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set values on an opened, virtual-joystick's button."]
    #[doc = ""]
    #[doc = " Please note that values set here will not be applied until the next call to"]
    #[doc = " SDL_JoystickUpdate, which can either be called directly, or can be called"]
    #[doc = " indirectly through various other SDL APIs, including, but not limited to"]
    #[doc = " the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,"]
    #[doc = " SDL_WaitEvent."]
    #[doc = ""]
    #[doc = " \\param joystick the virtual joystick on which to set state."]
    #[doc = " \\param button the specific button on the virtual joystick to set."]
    #[doc = " \\param value the new value for the specified button."]
    #[doc = " \\returns 0 on success, -1 on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.14."]
    pub fn SDL_JoystickSetVirtualButton(
        joystick: *mut SDL_Joystick,
        button: libc::c_int,
        value: Uint8,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set values on an opened, virtual-joystick's hat."]
    #[doc = ""]
    #[doc = " Please note that values set here will not be applied until the next call to"]
    #[doc = " SDL_JoystickUpdate, which can either be called directly, or can be called"]
    #[doc = " indirectly through various other SDL APIs, including, but not limited to"]
    #[doc = " the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,"]
    #[doc = " SDL_WaitEvent."]
    #[doc = ""]
    #[doc = " \\param joystick the virtual joystick on which to set state."]
    #[doc = " \\param hat the specific hat on the virtual joystick to set."]
    #[doc = " \\param value the new value for the specified hat."]
    #[doc = " \\returns 0 on success, -1 on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.14."]
    pub fn SDL_JoystickSetVirtualHat(
        joystick: *mut SDL_Joystick,
        hat: libc::c_int,
        value: Uint8,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the implementation dependent name of a joystick."]
    #[doc = ""]
    #[doc = " \\param joystick the SDL_Joystick obtained from SDL_JoystickOpen()"]
    #[doc = " \\returns the name of the selected joystick. If no name can be found, this"]
    #[doc = "          function returns NULL; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_JoystickNameForIndex"]
    #[doc = " \\sa SDL_JoystickOpen"]
    pub fn SDL_JoystickName(joystick: *mut SDL_Joystick) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the player index of an opened joystick."]
    #[doc = ""]
    #[doc = " For XInput controllers this returns the XInput user index. Many joysticks"]
    #[doc = " will not be able to supply this information."]
    #[doc = ""]
    #[doc = " \\param joystick the SDL_Joystick obtained from SDL_JoystickOpen()"]
    #[doc = " \\returns the player index, or -1 if it's not available."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.9."]
    pub fn SDL_JoystickGetPlayerIndex(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the player index of an opened joystick."]
    #[doc = ""]
    #[doc = " \\param joystick the SDL_Joystick obtained from SDL_JoystickOpen()"]
    #[doc = " \\param player_index the player index to set."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.12."]
    pub fn SDL_JoystickSetPlayerIndex(joystick: *mut SDL_Joystick, player_index: libc::c_int);
}
extern "C" {
    #[doc = " Get the implementation-dependent GUID for the joystick."]
    #[doc = ""]
    #[doc = " This function requires an open joystick."]
    #[doc = ""]
    #[doc = " \\param joystick the SDL_Joystick obtained from SDL_JoystickOpen()"]
    #[doc = " \\returns the GUID of the given joystick. If called on an invalid index,"]
    #[doc = "          this function returns a zero GUID; call SDL_GetError() for more"]
    #[doc = "          information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_JoystickGetDeviceGUID"]
    #[doc = " \\sa SDL_JoystickGetGUIDString"]
    pub fn SDL_JoystickGetGUID(joystick: *mut SDL_Joystick) -> SDL_JoystickGUID;
}
extern "C" {
    #[doc = " Get the USB vendor ID of an opened joystick, if available."]
    #[doc = ""]
    #[doc = " If the vendor ID isn't available this function returns 0."]
    #[doc = ""]
    #[doc = " \\param joystick the SDL_Joystick obtained from SDL_JoystickOpen()"]
    #[doc = " \\returns the USB vendor ID of the selected joystick, or 0 if unavailable."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.6."]
    pub fn SDL_JoystickGetVendor(joystick: *mut SDL_Joystick) -> Uint16;
}
extern "C" {
    #[doc = " Get the USB product ID of an opened joystick, if available."]
    #[doc = ""]
    #[doc = " If the product ID isn't available this function returns 0."]
    #[doc = ""]
    #[doc = " \\param joystick the SDL_Joystick obtained from SDL_JoystickOpen()"]
    #[doc = " \\returns the USB product ID of the selected joystick, or 0 if unavailable."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.6."]
    pub fn SDL_JoystickGetProduct(joystick: *mut SDL_Joystick) -> Uint16;
}
extern "C" {
    #[doc = " Get the product version of an opened joystick, if available."]
    #[doc = ""]
    #[doc = " If the product version isn't available this function returns 0."]
    #[doc = ""]
    #[doc = " \\param joystick the SDL_Joystick obtained from SDL_JoystickOpen()"]
    #[doc = " \\returns the product version of the selected joystick, or 0 if unavailable."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.6."]
    pub fn SDL_JoystickGetProductVersion(joystick: *mut SDL_Joystick) -> Uint16;
}
extern "C" {
    #[doc = " Get the serial number of an opened joystick, if available."]
    #[doc = ""]
    #[doc = " Returns the serial number of the joystick, or NULL if it is not available."]
    #[doc = ""]
    #[doc = " \\param joystick the SDL_Joystick obtained from SDL_JoystickOpen()"]
    #[doc = " \\returns the serial number of the selected joystick, or NULL if"]
    #[doc = "          unavailable."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.14."]
    pub fn SDL_JoystickGetSerial(joystick: *mut SDL_Joystick) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the type of an opened joystick."]
    #[doc = ""]
    #[doc = " \\param joystick the SDL_Joystick obtained from SDL_JoystickOpen()"]
    #[doc = " \\returns the SDL_JoystickType of the selected joystick."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.6."]
    pub fn SDL_JoystickGetType(joystick: *mut SDL_Joystick) -> SDL_JoystickType;
}
extern "C" {
    #[doc = " Get an ASCII string representation for a given SDL_JoystickGUID."]
    #[doc = ""]
    #[doc = " You should supply at least 33 bytes for pszGUID."]
    #[doc = ""]
    #[doc = " \\param guid the SDL_JoystickGUID you wish to convert to string"]
    #[doc = " \\param pszGUID buffer in which to write the ASCII string"]
    #[doc = " \\param cbGUID the size of pszGUID"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_JoystickGetDeviceGUID"]
    #[doc = " \\sa SDL_JoystickGetGUID"]
    #[doc = " \\sa SDL_JoystickGetGUIDFromString"]
    pub fn SDL_JoystickGetGUIDString(
        guid: SDL_JoystickGUID,
        pszGUID: *mut libc::c_char,
        cbGUID: libc::c_int,
    );
}
extern "C" {
    #[doc = " Convert a GUID string into a SDL_JoystickGUID structure."]
    #[doc = ""]
    #[doc = " Performs no error checking. If this function is given a string containing"]
    #[doc = " an invalid GUID, the function will silently succeed, but the GUID generated"]
    #[doc = " will not be useful."]
    #[doc = ""]
    #[doc = " \\param pchGUID string containing an ASCII representation of a GUID"]
    #[doc = " \\returns a SDL_JoystickGUID structure."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_JoystickGetGUIDString"]
    pub fn SDL_JoystickGetGUIDFromString(pchGUID: *const libc::c_char) -> SDL_JoystickGUID;
}
extern "C" {
    #[doc = " Get the status of a specified joystick."]
    #[doc = ""]
    #[doc = " \\param joystick the joystick to query"]
    #[doc = " \\returns SDL_TRUE if the joystick has been opened, SDL_FALSE if it has not;"]
    #[doc = "          call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_JoystickClose"]
    #[doc = " \\sa SDL_JoystickOpen"]
    pub fn SDL_JoystickGetAttached(joystick: *mut SDL_Joystick) -> SDL_bool;
}
extern "C" {
    #[doc = " Get the instance ID of an opened joystick."]
    #[doc = ""]
    #[doc = " \\param joystick an SDL_Joystick structure containing joystick information"]
    #[doc = " \\returns the instance ID of the specified joystick on success or a negative"]
    #[doc = "          error code on failure; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_JoystickOpen"]
    pub fn SDL_JoystickInstanceID(joystick: *mut SDL_Joystick) -> SDL_JoystickID;
}
extern "C" {
    #[doc = " Get the number of general axis controls on a joystick."]
    #[doc = ""]
    #[doc = " Often, the directional pad on a game controller will either look like 4"]
    #[doc = " separate buttons or a POV hat, and not axes, but all of this is up to the"]
    #[doc = " device and platform."]
    #[doc = ""]
    #[doc = " \\param joystick an SDL_Joystick structure containing joystick information"]
    #[doc = " \\returns the number of axis controls/number of axes on success or a"]
    #[doc = "          negative error code on failure; call SDL_GetError() for more"]
    #[doc = "          information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_JoystickGetAxis"]
    #[doc = " \\sa SDL_JoystickOpen"]
    pub fn SDL_JoystickNumAxes(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the number of trackballs on a joystick."]
    #[doc = ""]
    #[doc = " Joystick trackballs have only relative motion events associated with them"]
    #[doc = " and their state cannot be polled."]
    #[doc = ""]
    #[doc = " Most joysticks do not have trackballs."]
    #[doc = ""]
    #[doc = " \\param joystick an SDL_Joystick structure containing joystick information"]
    #[doc = " \\returns the number of trackballs on success or a negative error code on"]
    #[doc = "          failure; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_JoystickGetBall"]
    pub fn SDL_JoystickNumBalls(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the number of POV hats on a joystick."]
    #[doc = ""]
    #[doc = " \\param joystick an SDL_Joystick structure containing joystick information"]
    #[doc = " \\returns the number of POV hats on success or a negative error code on"]
    #[doc = "          failure; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_JoystickGetHat"]
    #[doc = " \\sa SDL_JoystickOpen"]
    pub fn SDL_JoystickNumHats(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the number of buttons on a joystick."]
    #[doc = ""]
    #[doc = " \\param joystick an SDL_Joystick structure containing joystick information"]
    #[doc = " \\returns the number of buttons on success or a negative error code on"]
    #[doc = "          failure; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_JoystickGetButton"]
    #[doc = " \\sa SDL_JoystickOpen"]
    pub fn SDL_JoystickNumButtons(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
    #[doc = " Update the current state of the open joysticks."]
    #[doc = ""]
    #[doc = " This is called automatically by the event loop if any joystick events are"]
    #[doc = " enabled."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_JoystickEventState"]
    pub fn SDL_JoystickUpdate();
}
extern "C" {
    #[doc = " Enable/disable joystick event polling."]
    #[doc = ""]
    #[doc = " If joystick events are disabled, you must call SDL_JoystickUpdate()"]
    #[doc = " yourself and manually check the state of the joystick when you want"]
    #[doc = " joystick information."]
    #[doc = ""]
    #[doc = " It is recommended that you leave joystick event handling enabled."]
    #[doc = ""]
    #[doc = " **WARNING**: Calling this function may delete all events currently in SDL's"]
    #[doc = " event queue."]
    #[doc = ""]
    #[doc = " \\param state can be one of `SDL_QUERY`, `SDL_IGNORE`, or `SDL_ENABLE`"]
    #[doc = " \\returns 1 if enabled, 0 if disabled, or a negative error code on failure;"]
    #[doc = "          call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = "          If `state` is `SDL_QUERY` then the current state is returned,"]
    #[doc = "          otherwise the new processing state is returned."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GameControllerEventState"]
    pub fn SDL_JoystickEventState(state: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the current state of an axis control on a joystick."]
    #[doc = ""]
    #[doc = " SDL makes no promises about what part of the joystick any given axis refers"]
    #[doc = " to. Your game should have some sort of configuration UI to let users"]
    #[doc = " specify what each axis should be bound to. Alternately, SDL's higher-level"]
    #[doc = " Game Controller API makes a great effort to apply order to this lower-level"]
    #[doc = " interface, so you know that a specific axis is the \"left thumb stick,\" etc."]
    #[doc = ""]
    #[doc = " The value returned by SDL_JoystickGetAxis() is a signed integer (-32768 to"]
    #[doc = " 32767) representing the current position of the axis. It may be necessary"]
    #[doc = " to impose certain tolerances on these values to account for jitter."]
    #[doc = ""]
    #[doc = " \\param joystick an SDL_Joystick structure containing joystick information"]
    #[doc = " \\param axis the axis to query; the axis indices start at index 0"]
    #[doc = " \\returns a 16-bit signed integer representing the current position of the"]
    #[doc = "          axis or 0 on failure; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_JoystickNumAxes"]
    pub fn SDL_JoystickGetAxis(joystick: *mut SDL_Joystick, axis: libc::c_int) -> Sint16;
}
extern "C" {
    #[doc = " Get the initial state of an axis control on a joystick."]
    #[doc = ""]
    #[doc = " The state is a value ranging from -32768 to 32767."]
    #[doc = ""]
    #[doc = " The axis indices start at index 0."]
    #[doc = ""]
    #[doc = " \\param joystick an SDL_Joystick structure containing joystick information"]
    #[doc = " \\param axis the axis to query; the axis indices start at index 0"]
    #[doc = " \\param state Upon return, the initial value is supplied here."]
    #[doc = " \\return SDL_TRUE if this axis has any initial value, or SDL_FALSE if not."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.6."]
    pub fn SDL_JoystickGetAxisInitialState(
        joystick: *mut SDL_Joystick,
        axis: libc::c_int,
        state: *mut Sint16,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = " Get the current state of a POV hat on a joystick."]
    #[doc = ""]
    #[doc = " The returned value will be one of the following positions:"]
    #[doc = ""]
    #[doc = " - `SDL_HAT_CENTERED`"]
    #[doc = " - `SDL_HAT_UP`"]
    #[doc = " - `SDL_HAT_RIGHT`"]
    #[doc = " - `SDL_HAT_DOWN`"]
    #[doc = " - `SDL_HAT_LEFT`"]
    #[doc = " - `SDL_HAT_RIGHTUP`"]
    #[doc = " - `SDL_HAT_RIGHTDOWN`"]
    #[doc = " - `SDL_HAT_LEFTUP`"]
    #[doc = " - `SDL_HAT_LEFTDOWN`"]
    #[doc = ""]
    #[doc = " \\param joystick an SDL_Joystick structure containing joystick information"]
    #[doc = " \\param hat the hat index to get the state from; indices start at index 0"]
    #[doc = " \\returns the current hat position."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_JoystickNumHats"]
    pub fn SDL_JoystickGetHat(joystick: *mut SDL_Joystick, hat: libc::c_int) -> Uint8;
}
extern "C" {
    #[doc = " Get the ball axis change since the last poll."]
    #[doc = ""]
    #[doc = " Trackballs can only return relative motion since the last call to"]
    #[doc = " SDL_JoystickGetBall(), these motion deltas are placed into `dx` and `dy`."]
    #[doc = ""]
    #[doc = " Most joysticks do not have trackballs."]
    #[doc = ""]
    #[doc = " \\param joystick the SDL_Joystick to query"]
    #[doc = " \\param ball the ball index to query; ball indices start at index 0"]
    #[doc = " \\param dx stores the difference in the x axis position since the last poll"]
    #[doc = " \\param dy stores the difference in the y axis position since the last poll"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_JoystickNumBalls"]
    pub fn SDL_JoystickGetBall(
        joystick: *mut SDL_Joystick,
        ball: libc::c_int,
        dx: *mut libc::c_int,
        dy: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the current state of a button on a joystick."]
    #[doc = ""]
    #[doc = " \\param joystick an SDL_Joystick structure containing joystick information"]
    #[doc = " \\param button the button index to get the state from; indices start at"]
    #[doc = "               index 0"]
    #[doc = " \\returns 1 if the specified button is pressed, 0 otherwise."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_JoystickNumButtons"]
    pub fn SDL_JoystickGetButton(joystick: *mut SDL_Joystick, button: libc::c_int) -> Uint8;
}
extern "C" {
    #[doc = " Start a rumble effect."]
    #[doc = ""]
    #[doc = " Each call to this function cancels any previous rumble effect, and calling"]
    #[doc = " it with 0 intensity stops any rumbling."]
    #[doc = ""]
    #[doc = " \\param joystick The joystick to vibrate"]
    #[doc = " \\param low_frequency_rumble The intensity of the low frequency (left)"]
    #[doc = "                             rumble motor, from 0 to 0xFFFF"]
    #[doc = " \\param high_frequency_rumble The intensity of the high frequency (right)"]
    #[doc = "                              rumble motor, from 0 to 0xFFFF"]
    #[doc = " \\param duration_ms The duration of the rumble effect, in milliseconds"]
    #[doc = " \\returns 0, or -1 if rumble isn't supported on this joystick"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.9."]
    #[doc = ""]
    #[doc = " \\sa SDL_JoystickHasRumble"]
    pub fn SDL_JoystickRumble(
        joystick: *mut SDL_Joystick,
        low_frequency_rumble: Uint16,
        high_frequency_rumble: Uint16,
        duration_ms: Uint32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Start a rumble effect in the joystick's triggers"]
    #[doc = ""]
    #[doc = " Each call to this function cancels any previous trigger rumble effect, and"]
    #[doc = " calling it with 0 intensity stops any rumbling."]
    #[doc = ""]
    #[doc = " Note that this function is for _trigger_ rumble; the first joystick to"]
    #[doc = " support this was the PlayStation 5's DualShock 5 controller. If you want"]
    #[doc = " the (more common) whole-controller rumble, use SDL_JoystickRumble()"]
    #[doc = " instead."]
    #[doc = ""]
    #[doc = " \\param joystick The joystick to vibrate"]
    #[doc = " \\param left_rumble The intensity of the left trigger rumble motor, from 0"]
    #[doc = "                    to 0xFFFF"]
    #[doc = " \\param right_rumble The intensity of the right trigger rumble motor, from 0"]
    #[doc = "                     to 0xFFFF"]
    #[doc = " \\param duration_ms The duration of the rumble effect, in milliseconds"]
    #[doc = " \\returns 0, or -1 if trigger rumble isn't supported on this joystick"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.14."]
    #[doc = ""]
    #[doc = " \\sa SDL_JoystickHasRumbleTriggers"]
    pub fn SDL_JoystickRumbleTriggers(
        joystick: *mut SDL_Joystick,
        left_rumble: Uint16,
        right_rumble: Uint16,
        duration_ms: Uint32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Query whether a joystick has an LED."]
    #[doc = ""]
    #[doc = " An example of a joystick LED is the light on the back of a PlayStation 4's"]
    #[doc = " DualShock 4 controller."]
    #[doc = ""]
    #[doc = " \\param joystick The joystick to query"]
    #[doc = " \\return SDL_TRUE if the joystick has a modifiable LED, SDL_FALSE otherwise."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.14."]
    pub fn SDL_JoystickHasLED(joystick: *mut SDL_Joystick) -> SDL_bool;
}
extern "C" {
    #[doc = " Query whether a joystick has rumble support."]
    #[doc = ""]
    #[doc = " \\param joystick The joystick to query"]
    #[doc = " \\return SDL_TRUE if the joystick has rumble, SDL_FALSE otherwise."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    #[doc = ""]
    #[doc = " \\sa SDL_JoystickRumble"]
    pub fn SDL_JoystickHasRumble(joystick: *mut SDL_Joystick) -> SDL_bool;
}
extern "C" {
    #[doc = " Query whether a joystick has rumble support on triggers."]
    #[doc = ""]
    #[doc = " \\param joystick The joystick to query"]
    #[doc = " \\return SDL_TRUE if the joystick has trigger rumble, SDL_FALSE otherwise."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    #[doc = ""]
    #[doc = " \\sa SDL_JoystickRumbleTriggers"]
    pub fn SDL_JoystickHasRumbleTriggers(joystick: *mut SDL_Joystick) -> SDL_bool;
}
extern "C" {
    #[doc = " Update a joystick's LED color."]
    #[doc = ""]
    #[doc = " An example of a joystick LED is the light on the back of a PlayStation 4's"]
    #[doc = " DualShock 4 controller."]
    #[doc = ""]
    #[doc = " \\param joystick The joystick to update"]
    #[doc = " \\param red The intensity of the red LED"]
    #[doc = " \\param green The intensity of the green LED"]
    #[doc = " \\param blue The intensity of the blue LED"]
    #[doc = " \\returns 0 on success, -1 if this joystick does not have a modifiable LED"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.14."]
    pub fn SDL_JoystickSetLED(
        joystick: *mut SDL_Joystick,
        red: Uint8,
        green: Uint8,
        blue: Uint8,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Send a joystick specific effect packet"]
    #[doc = ""]
    #[doc = " \\param joystick The joystick to affect"]
    #[doc = " \\param data The data to send to the joystick"]
    #[doc = " \\param size The size of the data to send to the joystick"]
    #[doc = " \\returns 0, or -1 if this joystick or driver doesn't support effect packets"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.16."]
    pub fn SDL_JoystickSendEffect(
        joystick: *mut SDL_Joystick,
        data: *const libc::c_void,
        size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Close a joystick previously opened with SDL_JoystickOpen()."]
    #[doc = ""]
    #[doc = " \\param joystick The joystick device to close"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_JoystickOpen"]
    pub fn SDL_JoystickClose(joystick: *mut SDL_Joystick);
}
extern "C" {
    #[doc = " Get the battery level of a joystick as SDL_JoystickPowerLevel."]
    #[doc = ""]
    #[doc = " \\param joystick the SDL_Joystick to query"]
    #[doc = " \\returns the current battery level as SDL_JoystickPowerLevel on success or"]
    #[doc = "          `SDL_JOYSTICK_POWER_UNKNOWN` if it is unknown"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.4."]
    pub fn SDL_JoystickCurrentPowerLevel(joystick: *mut SDL_Joystick) -> SDL_JoystickPowerLevel;
}
#[doc = "  \\brief SDL_sensor.h"]
#[doc = ""]
#[doc = "  In order to use these functions, SDL_Init() must have been called"]
#[doc = "  with the ::SDL_INIT_SENSOR flag.  This causes SDL to scan the system"]
#[doc = "  for sensors, and load appropriate drivers."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SDL_Sensor {
    _unused: [u8; 0],
}
pub type SDL_Sensor = _SDL_Sensor;
#[doc = " This is a unique ID for a sensor for the time it is connected to the system,"]
#[doc = " and is never reused for the lifetime of the application."]
#[doc = ""]
#[doc = " The ID value starts at 0 and increments from there. The value -1 is an invalid ID."]
pub type SDL_SensorID = Sint32;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_SensorType {
    #[doc = "< Returned for an invalid sensor"]
    SDL_SENSOR_INVALID = -1,
    #[doc = "< Unknown sensor type"]
    SDL_SENSOR_UNKNOWN = 0,
    #[doc = "< Accelerometer"]
    SDL_SENSOR_ACCEL = 1,
    #[doc = "< Gyroscope"]
    SDL_SENSOR_GYRO = 2,
}
extern "C" {
    #[doc = " Locking for multi-threaded access to the sensor API"]
    #[doc = ""]
    #[doc = " If you are using the sensor API or handling events from multiple threads"]
    #[doc = " you should use these locking functions to protect access to the sensors."]
    #[doc = ""]
    #[doc = " In particular, you are guaranteed that the sensor list won't change, so the"]
    #[doc = " API functions that take a sensor index will be valid, and sensor events"]
    #[doc = " will not be delivered."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.14."]
    pub fn SDL_LockSensors();
}
extern "C" {
    pub fn SDL_UnlockSensors();
}
extern "C" {
    #[doc = " Count the number of sensors attached to the system right now."]
    #[doc = ""]
    #[doc = " \\returns the number of sensors detected."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.9."]
    pub fn SDL_NumSensors() -> libc::c_int;
}
extern "C" {
    #[doc = " Get the implementation dependent name of a sensor."]
    #[doc = ""]
    #[doc = " \\param device_index The sensor to obtain name from"]
    #[doc = " \\returns the sensor name, or NULL if `device_index` is out of range."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.9."]
    pub fn SDL_SensorGetDeviceName(device_index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the type of a sensor."]
    #[doc = ""]
    #[doc = " \\param device_index The sensor to get the type from"]
    #[doc = " \\returns the SDL_SensorType, or `SDL_SENSOR_INVALID` if `device_index` is"]
    #[doc = "          out of range."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.9."]
    pub fn SDL_SensorGetDeviceType(device_index: libc::c_int) -> SDL_SensorType;
}
extern "C" {
    #[doc = " Get the platform dependent type of a sensor."]
    #[doc = ""]
    #[doc = " \\param device_index The sensor to check"]
    #[doc = " \\returns the sensor platform dependent type, or -1 if `device_index` is out"]
    #[doc = "          of range."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.9."]
    pub fn SDL_SensorGetDeviceNonPortableType(device_index: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the instance ID of a sensor."]
    #[doc = ""]
    #[doc = " \\param device_index The sensor to get instance id from"]
    #[doc = " \\returns the sensor instance ID, or -1 if `device_index` is out of range."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.9."]
    pub fn SDL_SensorGetDeviceInstanceID(device_index: libc::c_int) -> SDL_SensorID;
}
extern "C" {
    #[doc = " Open a sensor for use."]
    #[doc = ""]
    #[doc = " \\param device_index The sensor to open"]
    #[doc = " \\returns an SDL_Sensor sensor object, or NULL if an error occurred."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.9."]
    pub fn SDL_SensorOpen(device_index: libc::c_int) -> *mut SDL_Sensor;
}
extern "C" {
    #[doc = " Return the SDL_Sensor associated with an instance id."]
    #[doc = ""]
    #[doc = " \\param instance_id The sensor from instance id"]
    #[doc = " \\returns an SDL_Sensor object."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.9."]
    pub fn SDL_SensorFromInstanceID(instance_id: SDL_SensorID) -> *mut SDL_Sensor;
}
extern "C" {
    #[doc = " Get the implementation dependent name of a sensor"]
    #[doc = ""]
    #[doc = " \\param sensor The SDL_Sensor object"]
    #[doc = " \\returns the sensor name, or NULL if `sensor` is NULL."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.9."]
    pub fn SDL_SensorGetName(sensor: *mut SDL_Sensor) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the type of a sensor."]
    #[doc = ""]
    #[doc = " \\param sensor The SDL_Sensor object to inspect"]
    #[doc = " \\returns the SDL_SensorType type, or `SDL_SENSOR_INVALID` if `sensor` is"]
    #[doc = "          NULL."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.9."]
    pub fn SDL_SensorGetType(sensor: *mut SDL_Sensor) -> SDL_SensorType;
}
extern "C" {
    #[doc = " Get the platform dependent type of a sensor."]
    #[doc = ""]
    #[doc = " \\param sensor The SDL_Sensor object to inspect"]
    #[doc = " \\returns the sensor platform dependent type, or -1 if `sensor` is NULL."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.9."]
    pub fn SDL_SensorGetNonPortableType(sensor: *mut SDL_Sensor) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the instance ID of a sensor."]
    #[doc = ""]
    #[doc = " \\param sensor The SDL_Sensor object to inspect"]
    #[doc = " \\returns the sensor instance ID, or -1 if `sensor` is NULL."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.9."]
    pub fn SDL_SensorGetInstanceID(sensor: *mut SDL_Sensor) -> SDL_SensorID;
}
extern "C" {
    #[doc = " Get the current state of an opened sensor."]
    #[doc = ""]
    #[doc = " The number of values and interpretation of the data is sensor dependent."]
    #[doc = ""]
    #[doc = " \\param sensor The SDL_Sensor object to query"]
    #[doc = " \\param data A pointer filled with the current sensor state"]
    #[doc = " \\param num_values The number of values to write to data"]
    #[doc = " \\returns 0 or -1 if an error occurred."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.9."]
    pub fn SDL_SensorGetData(
        sensor: *mut SDL_Sensor,
        data: *mut f32,
        num_values: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Close a sensor previously opened with SDL_SensorOpen()."]
    #[doc = ""]
    #[doc = " \\param sensor The SDL_Sensor object to close"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.9."]
    pub fn SDL_SensorClose(sensor: *mut SDL_Sensor);
}
extern "C" {
    #[doc = " Update the current state of the open sensors."]
    #[doc = ""]
    #[doc = " This is called automatically by the event loop if sensor events are"]
    #[doc = " enabled."]
    #[doc = ""]
    #[doc = " This needs to be called from the thread that initialized the sensor"]
    #[doc = " subsystem."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.9."]
    pub fn SDL_SensorUpdate();
}
#[doc = " The gamecontroller structure used to identify an SDL game controller"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SDL_GameController {
    _unused: [u8; 0],
}
pub type SDL_GameController = _SDL_GameController;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_GameControllerType {
    SDL_CONTROLLER_TYPE_UNKNOWN = 0,
    SDL_CONTROLLER_TYPE_XBOX360 = 1,
    SDL_CONTROLLER_TYPE_XBOXONE = 2,
    SDL_CONTROLLER_TYPE_PS3 = 3,
    SDL_CONTROLLER_TYPE_PS4 = 4,
    SDL_CONTROLLER_TYPE_NINTENDO_SWITCH_PRO = 5,
    SDL_CONTROLLER_TYPE_VIRTUAL = 6,
    SDL_CONTROLLER_TYPE_PS5 = 7,
    SDL_CONTROLLER_TYPE_AMAZON_LUNA = 8,
    SDL_CONTROLLER_TYPE_GOOGLE_STADIA = 9,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_GameControllerBindType {
    SDL_CONTROLLER_BINDTYPE_NONE = 0,
    SDL_CONTROLLER_BINDTYPE_BUTTON = 1,
    SDL_CONTROLLER_BINDTYPE_AXIS = 2,
    SDL_CONTROLLER_BINDTYPE_HAT = 3,
}
#[doc = "  Get the SDL joystick layer binding for this controller button/axis mapping"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_GameControllerButtonBind {
    pub bindType: SDL_GameControllerBindType,
    pub value: SDL_GameControllerButtonBind__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_GameControllerButtonBind__bindgen_ty_1 {
    pub button: libc::c_int,
    pub axis: libc::c_int,
    pub hat: SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1 {
    pub hat: libc::c_int,
    pub hat_mask: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1>()))
                .hat as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(hat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1>()))
                .hat_mask as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(hat_mask)
        )
    );
}
#[test]
fn bindgen_test_layout_SDL_GameControllerButtonBind__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SDL_GameControllerButtonBind__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(SDL_GameControllerButtonBind__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_GameControllerButtonBind__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_GameControllerButtonBind__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_GameControllerButtonBind__bindgen_ty_1>())).button
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GameControllerButtonBind__bindgen_ty_1),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_GameControllerButtonBind__bindgen_ty_1>())).axis as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GameControllerButtonBind__bindgen_ty_1),
            "::",
            stringify!(axis)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_GameControllerButtonBind__bindgen_ty_1>())).hat as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GameControllerButtonBind__bindgen_ty_1),
            "::",
            stringify!(hat)
        )
    );
}
#[test]
fn bindgen_test_layout_SDL_GameControllerButtonBind() {
    assert_eq!(
        ::core::mem::size_of::<SDL_GameControllerButtonBind>(),
        12usize,
        concat!("Size of: ", stringify!(SDL_GameControllerButtonBind))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_GameControllerButtonBind>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_GameControllerButtonBind))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_GameControllerButtonBind>())).bindType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GameControllerButtonBind),
            "::",
            stringify!(bindType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_GameControllerButtonBind>())).value as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GameControllerButtonBind),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Load a set of Game Controller mappings from a seekable SDL data stream."]
    #[doc = ""]
    #[doc = " You can call this function several times, if needed, to load different"]
    #[doc = " database files."]
    #[doc = ""]
    #[doc = " If a new mapping is loaded for an already known controller GUID, the later"]
    #[doc = " version will overwrite the one currently loaded."]
    #[doc = ""]
    #[doc = " Mappings not belonging to the current platform or with no platform field"]
    #[doc = " specified will be ignored (i.e. mappings for Linux will be ignored in"]
    #[doc = " Windows, etc)."]
    #[doc = ""]
    #[doc = " This function will load the text database entirely in memory before"]
    #[doc = " processing it, so take this into consideration if you are in a memory"]
    #[doc = " constrained environment."]
    #[doc = ""]
    #[doc = " \\param rw the data stream for the mappings to be added"]
    #[doc = " \\param freerw non-zero to close the stream after being read"]
    #[doc = " \\returns the number of mappings added or -1 on error; call SDL_GetError()"]
    #[doc = "          for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.2."]
    #[doc = ""]
    #[doc = " \\sa SDL_GameControllerAddMapping"]
    #[doc = " \\sa SDL_GameControllerAddMappingsFromFile"]
    #[doc = " \\sa SDL_GameControllerMappingForGUID"]
    pub fn SDL_GameControllerAddMappingsFromRW(
        rw: *mut SDL_RWops,
        freerw: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Add support for controllers that SDL is unaware of or to cause an existing"]
    #[doc = " controller to have a different binding."]
    #[doc = ""]
    #[doc = " The mapping string has the format \"GUID,name,mapping\", where GUID is the"]
    #[doc = " string value from SDL_JoystickGetGUIDString(), name is the human readable"]
    #[doc = " string for the device and mappings are controller mappings to joystick"]
    #[doc = " ones. Under Windows there is a reserved GUID of \"xinput\" that covers all"]
    #[doc = " XInput devices. The mapping format for joystick is: {| |bX |a joystick"]
    #[doc = " button, index X |- |hX.Y |hat X with value Y |- |aX |axis X of the joystick"]
    #[doc = " |} Buttons can be used as a controller axes and vice versa."]
    #[doc = ""]
    #[doc = " This string shows an example of a valid mapping for a controller:"]
    #[doc = ""]
    #[doc = " ```c"]
    #[doc = " \"341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7\""]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " \\param mappingString the mapping string"]
    #[doc = " \\returns 1 if a new mapping is added, 0 if an existing mapping is updated,"]
    #[doc = "          -1 on error; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GameControllerMapping"]
    #[doc = " \\sa SDL_GameControllerMappingForGUID"]
    pub fn SDL_GameControllerAddMapping(mappingString: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the number of mappings installed."]
    #[doc = ""]
    #[doc = " \\returns the number of mappings."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.6."]
    pub fn SDL_GameControllerNumMappings() -> libc::c_int;
}
extern "C" {
    #[doc = " Get the mapping at a particular index."]
    #[doc = ""]
    #[doc = " \\returns the mapping string. Must be freed with SDL_free(). Returns NULL if"]
    #[doc = "          the index is out of range."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.6."]
    pub fn SDL_GameControllerMappingForIndex(mapping_index: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Get the game controller mapping string for a given GUID."]
    #[doc = ""]
    #[doc = " The returned string must be freed with SDL_free()."]
    #[doc = ""]
    #[doc = " \\param guid a structure containing the GUID for which a mapping is desired"]
    #[doc = " \\returns a mapping string or NULL on error; call SDL_GetError() for more"]
    #[doc = "          information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_JoystickGetDeviceGUID"]
    #[doc = " \\sa SDL_JoystickGetGUID"]
    pub fn SDL_GameControllerMappingForGUID(guid: SDL_JoystickGUID) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Get the current mapping of a Game Controller."]
    #[doc = ""]
    #[doc = " The returned string must be freed with SDL_free()."]
    #[doc = ""]
    #[doc = " Details about mappings are discussed with SDL_GameControllerAddMapping()."]
    #[doc = ""]
    #[doc = " \\param gamecontroller the game controller you want to get the current"]
    #[doc = "                       mapping for"]
    #[doc = " \\returns a string that has the controller's mapping or NULL if no mapping"]
    #[doc = "          is available; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GameControllerAddMapping"]
    #[doc = " \\sa SDL_GameControllerMappingForGUID"]
    pub fn SDL_GameControllerMapping(gamecontroller: *mut SDL_GameController) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Check if the given joystick is supported by the game controller interface."]
    #[doc = ""]
    #[doc = " `joystick_index` is the same as the `device_index` passed to"]
    #[doc = " SDL_JoystickOpen()."]
    #[doc = ""]
    #[doc = " \\param joystick_index the device_index of a device, up to"]
    #[doc = "                       SDL_NumJoysticks()"]
    #[doc = " \\returns SDL_TRUE if the given joystick is supported by the game controller"]
    #[doc = "          interface, SDL_FALSE if it isn't or it's an invalid index."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GameControllerNameForIndex"]
    #[doc = " \\sa SDL_GameControllerOpen"]
    pub fn SDL_IsGameController(joystick_index: libc::c_int) -> SDL_bool;
}
extern "C" {
    #[doc = " Get the implementation dependent name for the game controller."]
    #[doc = ""]
    #[doc = " This function can be called before any controllers are opened."]
    #[doc = ""]
    #[doc = " `joystick_index` is the same as the `device_index` passed to"]
    #[doc = " SDL_JoystickOpen()."]
    #[doc = ""]
    #[doc = " \\param joystick_index the device_index of a device, from zero to"]
    #[doc = "                       SDL_NumJoysticks()-1"]
    #[doc = " \\returns the implementation-dependent name for the game controller, or NULL"]
    #[doc = "          if there is no name or the index is invalid."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GameControllerName"]
    #[doc = " \\sa SDL_GameControllerOpen"]
    #[doc = " \\sa SDL_IsGameController"]
    pub fn SDL_GameControllerNameForIndex(joystick_index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the type of a game controller."]
    #[doc = ""]
    #[doc = " This can be called before any controllers are opened."]
    #[doc = ""]
    #[doc = " \\param joystick_index the device_index of a device, from zero to"]
    #[doc = "                       SDL_NumJoysticks()-1"]
    #[doc = " \\returns the controller type."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.12."]
    pub fn SDL_GameControllerTypeForIndex(joystick_index: libc::c_int) -> SDL_GameControllerType;
}
extern "C" {
    #[doc = " Get the mapping of a game controller."]
    #[doc = ""]
    #[doc = " This can be called before any controllers are opened."]
    #[doc = ""]
    #[doc = " \\param joystick_index the device_index of a device, from zero to"]
    #[doc = "                       SDL_NumJoysticks()-1"]
    #[doc = " \\returns the mapping string. Must be freed with SDL_free(). Returns NULL if"]
    #[doc = "          no mapping is available."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.9."]
    pub fn SDL_GameControllerMappingForDeviceIndex(
        joystick_index: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Open a game controller for use."]
    #[doc = ""]
    #[doc = " `joystick_index` is the same as the `device_index` passed to"]
    #[doc = " SDL_JoystickOpen()."]
    #[doc = ""]
    #[doc = " The index passed as an argument refers to the N'th game controller on the"]
    #[doc = " system. This index is not the value which will identify this controller in"]
    #[doc = " future controller events. The joystick's instance id (SDL_JoystickID) will"]
    #[doc = " be used there instead."]
    #[doc = ""]
    #[doc = " \\param joystick_index the device_index of a device, up to"]
    #[doc = "                       SDL_NumJoysticks()"]
    #[doc = " \\returns a gamecontroller identifier or NULL if an error occurred; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GameControllerClose"]
    #[doc = " \\sa SDL_GameControllerNameForIndex"]
    #[doc = " \\sa SDL_IsGameController"]
    pub fn SDL_GameControllerOpen(joystick_index: libc::c_int) -> *mut SDL_GameController;
}
extern "C" {
    #[doc = " Get the SDL_GameController associated with an instance id."]
    #[doc = ""]
    #[doc = " \\param joyid the instance id to get the SDL_GameController for"]
    #[doc = " \\returns an SDL_GameController on success or NULL on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.4."]
    pub fn SDL_GameControllerFromInstanceID(joyid: SDL_JoystickID) -> *mut SDL_GameController;
}
extern "C" {
    #[doc = " Get the SDL_GameController associated with a player index."]
    #[doc = ""]
    #[doc = " Please note that the player index is _not_ the device index, nor is it the"]
    #[doc = " instance id!"]
    #[doc = ""]
    #[doc = " \\param player_index the player index, which is not the device index or the"]
    #[doc = "                     instance id!"]
    #[doc = " \\returns the SDL_GameController associated with a player index."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.12."]
    #[doc = ""]
    #[doc = " \\sa SDL_GameControllerGetPlayerIndex"]
    #[doc = " \\sa SDL_GameControllerSetPlayerIndex"]
    pub fn SDL_GameControllerFromPlayerIndex(player_index: libc::c_int) -> *mut SDL_GameController;
}
extern "C" {
    #[doc = " Get the implementation-dependent name for an opened game controller."]
    #[doc = ""]
    #[doc = " This is the same name as returned by SDL_GameControllerNameForIndex(), but"]
    #[doc = " it takes a controller identifier instead of the (unstable) device index."]
    #[doc = ""]
    #[doc = " \\param gamecontroller a game controller identifier previously returned by"]
    #[doc = "                       SDL_GameControllerOpen()"]
    #[doc = " \\returns the implementation dependent name for the game controller, or NULL"]
    #[doc = "          if there is no name or the identifier passed is invalid."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GameControllerNameForIndex"]
    #[doc = " \\sa SDL_GameControllerOpen"]
    pub fn SDL_GameControllerName(gamecontroller: *mut SDL_GameController) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the type of this currently opened controller"]
    #[doc = ""]
    #[doc = " This is the same name as returned by SDL_GameControllerTypeForIndex(), but"]
    #[doc = " it takes a controller identifier instead of the (unstable) device index."]
    #[doc = ""]
    #[doc = " \\param gamecontroller the game controller object to query."]
    #[doc = " \\returns the controller type."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.12."]
    pub fn SDL_GameControllerGetType(
        gamecontroller: *mut SDL_GameController,
    ) -> SDL_GameControllerType;
}
extern "C" {
    #[doc = " Get the player index of an opened game controller."]
    #[doc = ""]
    #[doc = " For XInput controllers this returns the XInput user index."]
    #[doc = ""]
    #[doc = " \\param gamecontroller the game controller object to query."]
    #[doc = " \\returns the player index for controller, or -1 if it's not available."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.9."]
    pub fn SDL_GameControllerGetPlayerIndex(gamecontroller: *mut SDL_GameController)
        -> libc::c_int;
}
extern "C" {
    #[doc = " Set the player index of an opened game controller."]
    #[doc = ""]
    #[doc = " \\param gamecontroller the game controller object to adjust."]
    #[doc = " \\param player_index Player index to assign to this controller."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.12."]
    pub fn SDL_GameControllerSetPlayerIndex(
        gamecontroller: *mut SDL_GameController,
        player_index: libc::c_int,
    );
}
extern "C" {
    #[doc = " Get the USB vendor ID of an opened controller, if available."]
    #[doc = ""]
    #[doc = " If the vendor ID isn't available this function returns 0."]
    #[doc = ""]
    #[doc = " \\param gamecontroller the game controller object to query."]
    #[doc = " \\return the USB vendor ID, or zero if unavailable."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.6."]
    pub fn SDL_GameControllerGetVendor(gamecontroller: *mut SDL_GameController) -> Uint16;
}
extern "C" {
    #[doc = " Get the USB product ID of an opened controller, if available."]
    #[doc = ""]
    #[doc = " If the product ID isn't available this function returns 0."]
    #[doc = ""]
    #[doc = " \\param gamecontroller the game controller object to query."]
    #[doc = " \\return the USB product ID, or zero if unavailable."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.6."]
    pub fn SDL_GameControllerGetProduct(gamecontroller: *mut SDL_GameController) -> Uint16;
}
extern "C" {
    #[doc = " Get the product version of an opened controller, if available."]
    #[doc = ""]
    #[doc = " If the product version isn't available this function returns 0."]
    #[doc = ""]
    #[doc = " \\param gamecontroller the game controller object to query."]
    #[doc = " \\return the USB product version, or zero if unavailable."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.6."]
    pub fn SDL_GameControllerGetProductVersion(gamecontroller: *mut SDL_GameController) -> Uint16;
}
extern "C" {
    #[doc = " Get the serial number of an opened controller, if available."]
    #[doc = ""]
    #[doc = " Returns the serial number of the controller, or NULL if it is not"]
    #[doc = " available."]
    #[doc = ""]
    #[doc = " \\param gamecontroller the game controller object to query."]
    #[doc = " \\return the serial number, or NULL if unavailable."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.14."]
    pub fn SDL_GameControllerGetSerial(
        gamecontroller: *mut SDL_GameController,
    ) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Check if a controller has been opened and is currently connected."]
    #[doc = ""]
    #[doc = " \\param gamecontroller a game controller identifier previously returned by"]
    #[doc = "                       SDL_GameControllerOpen()"]
    #[doc = " \\returns SDL_TRUE if the controller has been opened and is currently"]
    #[doc = "          connected, or SDL_FALSE if not."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GameControllerClose"]
    #[doc = " \\sa SDL_GameControllerOpen"]
    pub fn SDL_GameControllerGetAttached(gamecontroller: *mut SDL_GameController) -> SDL_bool;
}
extern "C" {
    #[doc = " Get the Joystick ID from a Game Controller."]
    #[doc = ""]
    #[doc = " This function will give you a SDL_Joystick object, which allows you to use"]
    #[doc = " the SDL_Joystick functions with a SDL_GameController object. This would be"]
    #[doc = " useful for getting a joystick's position at any given time, even if it"]
    #[doc = " hasn't moved (moving it would produce an event, which would have the axis'"]
    #[doc = " value)."]
    #[doc = ""]
    #[doc = " The pointer returned is owned by the SDL_GameController. You should not"]
    #[doc = " call SDL_JoystickClose() on it, for example, since doing so will likely"]
    #[doc = " cause SDL to crash."]
    #[doc = ""]
    #[doc = " \\param gamecontroller the game controller object that you want to get a"]
    #[doc = "                       joystick from"]
    #[doc = " \\returns a SDL_Joystick object; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_GameControllerGetJoystick(
        gamecontroller: *mut SDL_GameController,
    ) -> *mut SDL_Joystick;
}
extern "C" {
    #[doc = " Query or change current state of Game Controller events."]
    #[doc = ""]
    #[doc = " If controller events are disabled, you must call SDL_GameControllerUpdate()"]
    #[doc = " yourself and check the state of the controller when you want controller"]
    #[doc = " information."]
    #[doc = ""]
    #[doc = " Any number can be passed to SDL_GameControllerEventState(), but only -1, 0,"]
    #[doc = " and 1 will have any effect. Other numbers will just be returned."]
    #[doc = ""]
    #[doc = " \\param state can be one of `SDL_QUERY`, `SDL_IGNORE`, or `SDL_ENABLE`"]
    #[doc = " \\returns the same value passed to the function, with exception to -1"]
    #[doc = "          (SDL_QUERY), which will return the current state."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_JoystickEventState"]
    pub fn SDL_GameControllerEventState(state: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Manually pump game controller updates if not using the loop."]
    #[doc = ""]
    #[doc = " This function is called automatically by the event loop if events are"]
    #[doc = " enabled. Under such circumstances, it will not be necessary to call this"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_GameControllerUpdate();
}
#[repr(i32)]
#[doc = "  The list of axes available from a controller"]
#[doc = ""]
#[doc = "  Thumbstick axis values range from SDL_JOYSTICK_AXIS_MIN to SDL_JOYSTICK_AXIS_MAX,"]
#[doc = "  and are centered within ~8000 of zero, though advanced UI will allow users to set"]
#[doc = "  or autodetect the dead zone, which varies between controllers."]
#[doc = ""]
#[doc = "  Trigger axis values range from 0 to SDL_JOYSTICK_AXIS_MAX."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_GameControllerAxis {
    SDL_CONTROLLER_AXIS_INVALID = -1,
    SDL_CONTROLLER_AXIS_LEFTX = 0,
    SDL_CONTROLLER_AXIS_LEFTY = 1,
    SDL_CONTROLLER_AXIS_RIGHTX = 2,
    SDL_CONTROLLER_AXIS_RIGHTY = 3,
    SDL_CONTROLLER_AXIS_TRIGGERLEFT = 4,
    SDL_CONTROLLER_AXIS_TRIGGERRIGHT = 5,
    SDL_CONTROLLER_AXIS_MAX = 6,
}
extern "C" {
    #[doc = " Convert a string into SDL_GameControllerAxis enum."]
    #[doc = ""]
    #[doc = " This function is called internally to translate SDL_GameController mapping"]
    #[doc = " strings for the underlying joystick device into the consistent"]
    #[doc = " SDL_GameController mapping. You do not normally need to call this function"]
    #[doc = " unless you are parsing SDL_GameController mappings in your own code."]
    #[doc = ""]
    #[doc = " Note specially that \"righttrigger\" and \"lefttrigger\" map to"]
    #[doc = " `SDL_CONTROLLER_AXIS_TRIGGERRIGHT` and `SDL_CONTROLLER_AXIS_TRIGGERLEFT`,"]
    #[doc = " respectively."]
    #[doc = ""]
    #[doc = " \\param str string representing a SDL_GameController axis"]
    #[doc = " \\returns the SDL_GameControllerAxis enum corresponding to the input string,"]
    #[doc = "          or `SDL_CONTROLLER_AXIS_INVALID` if no match was found."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GameControllerGetStringForAxis"]
    pub fn SDL_GameControllerGetAxisFromString(str: *const libc::c_char) -> SDL_GameControllerAxis;
}
extern "C" {
    #[doc = " Convert from an SDL_GameControllerAxis enum to a string."]
    #[doc = ""]
    #[doc = " The caller should not SDL_free() the returned string."]
    #[doc = ""]
    #[doc = " \\param axis an enum value for a given SDL_GameControllerAxis"]
    #[doc = " \\returns a string for the given axis, or NULL if an invalid axis is"]
    #[doc = "          specified. The string returned is of the format used by"]
    #[doc = "          SDL_GameController mapping strings."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GameControllerGetAxisFromString"]
    pub fn SDL_GameControllerGetStringForAxis(axis: SDL_GameControllerAxis) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the SDL joystick layer binding for a controller axis mapping."]
    #[doc = ""]
    #[doc = " \\param gamecontroller a game controller"]
    #[doc = " \\param axis an axis enum value (one of the SDL_GameControllerAxis values)"]
    #[doc = " \\returns a SDL_GameControllerButtonBind describing the bind. On failure"]
    #[doc = "          (like the given Controller axis doesn't exist on the device), its"]
    #[doc = "          `.bindType` will be `SDL_CONTROLLER_BINDTYPE_NONE`."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GameControllerGetBindForButton"]
    pub fn SDL_GameControllerGetBindForAxis(
        gamecontroller: *mut SDL_GameController,
        axis: SDL_GameControllerAxis,
    ) -> SDL_GameControllerButtonBind;
}
extern "C" {
    #[doc = " Query whether a game controller has a given axis."]
    #[doc = ""]
    #[doc = " This merely reports whether the controller's mapping defined this axis, as"]
    #[doc = " that is all the information SDL has about the physical device."]
    #[doc = ""]
    #[doc = " \\param gamecontroller a game controller"]
    #[doc = " \\param axis an axis enum value (an SDL_GameControllerAxis value)"]
    #[doc = " \\returns SDL_TRUE if the controller has this axis, SDL_FALSE otherwise."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.14."]
    pub fn SDL_GameControllerHasAxis(
        gamecontroller: *mut SDL_GameController,
        axis: SDL_GameControllerAxis,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = " Get the current state of an axis control on a game controller."]
    #[doc = ""]
    #[doc = " The axis indices start at index 0."]
    #[doc = ""]
    #[doc = " The state is a value ranging from -32768 to 32767. Triggers, however, range"]
    #[doc = " from 0 to 32767 (they never return a negative value)."]
    #[doc = ""]
    #[doc = " \\param gamecontroller a game controller"]
    #[doc = " \\param axis an axis index (one of the SDL_GameControllerAxis values)"]
    #[doc = " \\returns axis state (including 0) on success or 0 (also) on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GameControllerGetButton"]
    pub fn SDL_GameControllerGetAxis(
        gamecontroller: *mut SDL_GameController,
        axis: SDL_GameControllerAxis,
    ) -> Sint16;
}
#[repr(i32)]
#[doc = "  The list of buttons available from a controller"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_GameControllerButton {
    SDL_CONTROLLER_BUTTON_INVALID = -1,
    SDL_CONTROLLER_BUTTON_A = 0,
    SDL_CONTROLLER_BUTTON_B = 1,
    SDL_CONTROLLER_BUTTON_X = 2,
    SDL_CONTROLLER_BUTTON_Y = 3,
    SDL_CONTROLLER_BUTTON_BACK = 4,
    SDL_CONTROLLER_BUTTON_GUIDE = 5,
    SDL_CONTROLLER_BUTTON_START = 6,
    SDL_CONTROLLER_BUTTON_LEFTSTICK = 7,
    SDL_CONTROLLER_BUTTON_RIGHTSTICK = 8,
    SDL_CONTROLLER_BUTTON_LEFTSHOULDER = 9,
    SDL_CONTROLLER_BUTTON_RIGHTSHOULDER = 10,
    SDL_CONTROLLER_BUTTON_DPAD_UP = 11,
    SDL_CONTROLLER_BUTTON_DPAD_DOWN = 12,
    SDL_CONTROLLER_BUTTON_DPAD_LEFT = 13,
    SDL_CONTROLLER_BUTTON_DPAD_RIGHT = 14,
    SDL_CONTROLLER_BUTTON_MISC1 = 15,
    SDL_CONTROLLER_BUTTON_PADDLE1 = 16,
    SDL_CONTROLLER_BUTTON_PADDLE2 = 17,
    SDL_CONTROLLER_BUTTON_PADDLE3 = 18,
    SDL_CONTROLLER_BUTTON_PADDLE4 = 19,
    SDL_CONTROLLER_BUTTON_TOUCHPAD = 20,
    SDL_CONTROLLER_BUTTON_MAX = 21,
}
extern "C" {
    #[doc = " Convert a string into an SDL_GameControllerButton enum."]
    #[doc = ""]
    #[doc = " This function is called internally to translate SDL_GameController mapping"]
    #[doc = " strings for the underlying joystick device into the consistent"]
    #[doc = " SDL_GameController mapping. You do not normally need to call this function"]
    #[doc = " unless you are parsing SDL_GameController mappings in your own code."]
    #[doc = ""]
    #[doc = " \\param str string representing a SDL_GameController axis"]
    #[doc = " \\returns the SDL_GameControllerButton enum corresponding to the input"]
    #[doc = "          string, or `SDL_CONTROLLER_AXIS_INVALID` if no match was found."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_GameControllerGetButtonFromString(
        str: *const libc::c_char,
    ) -> SDL_GameControllerButton;
}
extern "C" {
    #[doc = " Convert from an SDL_GameControllerButton enum to a string."]
    #[doc = ""]
    #[doc = " The caller should not SDL_free() the returned string."]
    #[doc = ""]
    #[doc = " \\param button an enum value for a given SDL_GameControllerButton"]
    #[doc = " \\returns a string for the given button, or NULL if an invalid axis is"]
    #[doc = "          specified. The string returned is of the format used by"]
    #[doc = "          SDL_GameController mapping strings."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GameControllerGetButtonFromString"]
    pub fn SDL_GameControllerGetStringForButton(
        button: SDL_GameControllerButton,
    ) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the SDL joystick layer binding for a controller button mapping."]
    #[doc = ""]
    #[doc = " \\param gamecontroller a game controller"]
    #[doc = " \\param button an button enum value (an SDL_GameControllerButton value)"]
    #[doc = " \\returns a SDL_GameControllerButtonBind describing the bind. On failure"]
    #[doc = "          (like the given Controller button doesn't exist on the device),"]
    #[doc = "          its `.bindType` will be `SDL_CONTROLLER_BINDTYPE_NONE`."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GameControllerGetBindForAxis"]
    pub fn SDL_GameControllerGetBindForButton(
        gamecontroller: *mut SDL_GameController,
        button: SDL_GameControllerButton,
    ) -> SDL_GameControllerButtonBind;
}
extern "C" {
    #[doc = " Query whether a game controller has a given button."]
    #[doc = ""]
    #[doc = " This merely reports whether the controller's mapping defined this button,"]
    #[doc = " as that is all the information SDL has about the physical device."]
    #[doc = ""]
    #[doc = " \\param gamecontroller a game controller"]
    #[doc = " \\param button a button enum value (an SDL_GameControllerButton value)"]
    #[doc = " \\returns SDL_TRUE if the controller has this button, SDL_FALSE otherwise."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.14."]
    pub fn SDL_GameControllerHasButton(
        gamecontroller: *mut SDL_GameController,
        button: SDL_GameControllerButton,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = " Get the current state of a button on a game controller."]
    #[doc = ""]
    #[doc = " \\param gamecontroller a game controller"]
    #[doc = " \\param button a button index (one of the SDL_GameControllerButton values)"]
    #[doc = " \\returns 1 for pressed state or 0 for not pressed state or error; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GameControllerGetAxis"]
    pub fn SDL_GameControllerGetButton(
        gamecontroller: *mut SDL_GameController,
        button: SDL_GameControllerButton,
    ) -> Uint8;
}
extern "C" {
    #[doc = " Get the number of touchpads on a game controller."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.14."]
    pub fn SDL_GameControllerGetNumTouchpads(
        gamecontroller: *mut SDL_GameController,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the number of supported simultaneous fingers on a touchpad on a game"]
    #[doc = " controller."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.14."]
    pub fn SDL_GameControllerGetNumTouchpadFingers(
        gamecontroller: *mut SDL_GameController,
        touchpad: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the current state of a finger on a touchpad on a game controller."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.14."]
    pub fn SDL_GameControllerGetTouchpadFinger(
        gamecontroller: *mut SDL_GameController,
        touchpad: libc::c_int,
        finger: libc::c_int,
        state: *mut Uint8,
        x: *mut f32,
        y: *mut f32,
        pressure: *mut f32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Return whether a game controller has a particular sensor."]
    #[doc = ""]
    #[doc = " \\param gamecontroller The controller to query"]
    #[doc = " \\param type The type of sensor to query"]
    #[doc = " \\returns SDL_TRUE if the sensor exists, SDL_FALSE otherwise."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.14."]
    pub fn SDL_GameControllerHasSensor(
        gamecontroller: *mut SDL_GameController,
        type_: SDL_SensorType,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = " Set whether data reporting for a game controller sensor is enabled."]
    #[doc = ""]
    #[doc = " \\param gamecontroller The controller to update"]
    #[doc = " \\param type The type of sensor to enable/disable"]
    #[doc = " \\param enabled Whether data reporting should be enabled"]
    #[doc = " \\returns 0 or -1 if an error occurred."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.14."]
    pub fn SDL_GameControllerSetSensorEnabled(
        gamecontroller: *mut SDL_GameController,
        type_: SDL_SensorType,
        enabled: SDL_bool,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Query whether sensor data reporting is enabled for a game controller."]
    #[doc = ""]
    #[doc = " \\param gamecontroller The controller to query"]
    #[doc = " \\param type The type of sensor to query"]
    #[doc = " \\returns SDL_TRUE if the sensor is enabled, SDL_FALSE otherwise."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.14."]
    pub fn SDL_GameControllerIsSensorEnabled(
        gamecontroller: *mut SDL_GameController,
        type_: SDL_SensorType,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = " Get the data rate (number of events per second) of a game controller"]
    #[doc = " sensor."]
    #[doc = ""]
    #[doc = " \\param gamecontroller The controller to query"]
    #[doc = " \\param type The type of sensor to query"]
    #[doc = " \\return the data rate, or 0.0f if the data rate is not available."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.16."]
    pub fn SDL_GameControllerGetSensorDataRate(
        gamecontroller: *mut SDL_GameController,
        type_: SDL_SensorType,
    ) -> f32;
}
extern "C" {
    #[doc = " Get the current state of a game controller sensor."]
    #[doc = ""]
    #[doc = " The number of values and interpretation of the data is sensor dependent."]
    #[doc = " See SDL_sensor.h for the details for each type of sensor."]
    #[doc = ""]
    #[doc = " \\param gamecontroller The controller to query"]
    #[doc = " \\param type The type of sensor to query"]
    #[doc = " \\param data A pointer filled with the current sensor state"]
    #[doc = " \\param num_values The number of values to write to data"]
    #[doc = " \\return 0 or -1 if an error occurred."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.14."]
    pub fn SDL_GameControllerGetSensorData(
        gamecontroller: *mut SDL_GameController,
        type_: SDL_SensorType,
        data: *mut f32,
        num_values: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Start a rumble effect on a game controller."]
    #[doc = ""]
    #[doc = " Each call to this function cancels any previous rumble effect, and calling"]
    #[doc = " it with 0 intensity stops any rumbling."]
    #[doc = ""]
    #[doc = " \\param gamecontroller The controller to vibrate"]
    #[doc = " \\param low_frequency_rumble The intensity of the low frequency (left)"]
    #[doc = "                             rumble motor, from 0 to 0xFFFF"]
    #[doc = " \\param high_frequency_rumble The intensity of the high frequency (right)"]
    #[doc = "                              rumble motor, from 0 to 0xFFFF"]
    #[doc = " \\param duration_ms The duration of the rumble effect, in milliseconds"]
    #[doc = " \\returns 0, or -1 if rumble isn't supported on this controller"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.9."]
    #[doc = ""]
    #[doc = " \\sa SDL_GameControllerHasRumble"]
    pub fn SDL_GameControllerRumble(
        gamecontroller: *mut SDL_GameController,
        low_frequency_rumble: Uint16,
        high_frequency_rumble: Uint16,
        duration_ms: Uint32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Start a rumble effect in the game controller's triggers."]
    #[doc = ""]
    #[doc = " Each call to this function cancels any previous trigger rumble effect, and"]
    #[doc = " calling it with 0 intensity stops any rumbling."]
    #[doc = ""]
    #[doc = " Note that this is rumbling of the _triggers_ and not the game controller as"]
    #[doc = " a whole. The first controller to offer this feature was the PlayStation 5's"]
    #[doc = " DualShock 5."]
    #[doc = ""]
    #[doc = " \\param gamecontroller The controller to vibrate"]
    #[doc = " \\param left_rumble The intensity of the left trigger rumble motor, from 0"]
    #[doc = "                    to 0xFFFF"]
    #[doc = " \\param right_rumble The intensity of the right trigger rumble motor, from 0"]
    #[doc = "                     to 0xFFFF"]
    #[doc = " \\param duration_ms The duration of the rumble effect, in milliseconds"]
    #[doc = " \\returns 0, or -1 if trigger rumble isn't supported on this controller"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.14."]
    #[doc = ""]
    #[doc = " \\sa SDL_GameControllerHasRumbleTriggers"]
    pub fn SDL_GameControllerRumbleTriggers(
        gamecontroller: *mut SDL_GameController,
        left_rumble: Uint16,
        right_rumble: Uint16,
        duration_ms: Uint32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Query whether a game controller has an LED."]
    #[doc = ""]
    #[doc = " \\param gamecontroller The controller to query"]
    #[doc = " \\returns SDL_TRUE, or SDL_FALSE if this controller does not have a"]
    #[doc = "          modifiable LED"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.14."]
    pub fn SDL_GameControllerHasLED(gamecontroller: *mut SDL_GameController) -> SDL_bool;
}
extern "C" {
    #[doc = " Query whether a game controller has rumble support."]
    #[doc = ""]
    #[doc = " \\param gamecontroller The controller to query"]
    #[doc = " \\returns SDL_TRUE, or SDL_FALSE if this controller does not have rumble"]
    #[doc = "          support"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    #[doc = ""]
    #[doc = " \\sa SDL_GameControllerRumble"]
    pub fn SDL_GameControllerHasRumble(gamecontroller: *mut SDL_GameController) -> SDL_bool;
}
extern "C" {
    #[doc = " Query whether a game controller has rumble support on triggers."]
    #[doc = ""]
    #[doc = " \\param gamecontroller The controller to query"]
    #[doc = " \\returns SDL_TRUE, or SDL_FALSE if this controller does not have trigger"]
    #[doc = "          rumble support"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    #[doc = ""]
    #[doc = " \\sa SDL_GameControllerRumbleTriggers"]
    pub fn SDL_GameControllerHasRumbleTriggers(gamecontroller: *mut SDL_GameController)
        -> SDL_bool;
}
extern "C" {
    #[doc = " Update a game controller's LED color."]
    #[doc = ""]
    #[doc = " \\param gamecontroller The controller to update"]
    #[doc = " \\param red The intensity of the red LED"]
    #[doc = " \\param green The intensity of the green LED"]
    #[doc = " \\param blue The intensity of the blue LED"]
    #[doc = " \\returns 0, or -1 if this controller does not have a modifiable LED"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.14."]
    pub fn SDL_GameControllerSetLED(
        gamecontroller: *mut SDL_GameController,
        red: Uint8,
        green: Uint8,
        blue: Uint8,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Send a controller specific effect packet"]
    #[doc = ""]
    #[doc = " \\param gamecontroller The controller to affect"]
    #[doc = " \\param data The data to send to the controller"]
    #[doc = " \\param size The size of the data to send to the controller"]
    #[doc = " \\returns 0, or -1 if this controller or driver doesn't support effect"]
    #[doc = "          packets"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.16."]
    pub fn SDL_GameControllerSendEffect(
        gamecontroller: *mut SDL_GameController,
        data: *const libc::c_void,
        size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Close a game controller previously opened with SDL_GameControllerOpen()."]
    #[doc = ""]
    #[doc = " \\param gamecontroller a game controller identifier previously returned by"]
    #[doc = "                       SDL_GameControllerOpen()"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GameControllerOpen"]
    pub fn SDL_GameControllerClose(gamecontroller: *mut SDL_GameController);
}
extern "C" {
    #[doc = " Return the sfSymbolsName for a given button on a game controller on Apple"]
    #[doc = " platforms."]
    #[doc = ""]
    #[doc = " \\param gamecontroller the controller to query"]
    #[doc = " \\param button a button on the game controller"]
    #[doc = " \\returns the sfSymbolsName or NULL if the name can't be found"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    #[doc = ""]
    #[doc = " \\sa SDL_GameControllerGetAppleSFSymbolsNameForAxis"]
    pub fn SDL_GameControllerGetAppleSFSymbolsNameForButton(
        gamecontroller: *mut SDL_GameController,
        button: SDL_GameControllerButton,
    ) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Return the sfSymbolsName for a given axis on a game controller on Apple"]
    #[doc = " platforms."]
    #[doc = ""]
    #[doc = " \\param gamecontroller the controller to query"]
    #[doc = " \\param axis an axis on the game controller"]
    #[doc = " \\returns the sfSymbolsName or NULL if the name can't be found"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    #[doc = ""]
    #[doc = " \\sa SDL_GameControllerGetAppleSFSymbolsNameForButton"]
    pub fn SDL_GameControllerGetAppleSFSymbolsNameForAxis(
        gamecontroller: *mut SDL_GameController,
        axis: SDL_GameControllerAxis,
    ) -> *const libc::c_char;
}
pub type SDL_TouchID = Sint64;
pub type SDL_FingerID = Sint64;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_TouchDeviceType {
    SDL_TOUCH_DEVICE_INVALID = -1,
    SDL_TOUCH_DEVICE_DIRECT = 0,
    SDL_TOUCH_DEVICE_INDIRECT_ABSOLUTE = 1,
    SDL_TOUCH_DEVICE_INDIRECT_RELATIVE = 2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Finger {
    pub id: SDL_FingerID,
    pub x: f32,
    pub y: f32,
    pub pressure: f32,
}
#[test]
fn bindgen_test_layout_SDL_Finger() {
    assert_eq!(
        ::core::mem::size_of::<SDL_Finger>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_Finger))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_Finger>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_Finger))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Finger>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Finger),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Finger>())).x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Finger),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Finger>())).y as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Finger),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Finger>())).pressure as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Finger),
            "::",
            stringify!(pressure)
        )
    );
}
extern "C" {
    #[doc = " Get the number of registered touch devices."]
    #[doc = ""]
    #[doc = " On some platforms SDL first sees the touch device if it was actually used."]
    #[doc = " Therefore SDL_GetNumTouchDevices() may return 0 although devices are"]
    #[doc = " available. After using all devices at least once the number will be"]
    #[doc = " correct."]
    #[doc = ""]
    #[doc = " This was fixed for Android in SDL 2.0.1."]
    #[doc = ""]
    #[doc = " \\returns the number of registered touch devices."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetTouchDevice"]
    pub fn SDL_GetNumTouchDevices() -> libc::c_int;
}
extern "C" {
    #[doc = " Get the touch ID with the given index."]
    #[doc = ""]
    #[doc = " \\param index the touch device index"]
    #[doc = " \\returns the touch ID with the given index on success or 0 if the index is"]
    #[doc = "          invalid; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetNumTouchDevices"]
    pub fn SDL_GetTouchDevice(index: libc::c_int) -> SDL_TouchID;
}
extern "C" {
    #[doc = " Get the type of the given touch device."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.10."]
    pub fn SDL_GetTouchDeviceType(touchID: SDL_TouchID) -> SDL_TouchDeviceType;
}
extern "C" {
    #[doc = " Get the number of active fingers for a given touch device."]
    #[doc = ""]
    #[doc = " \\param touchID the ID of a touch device"]
    #[doc = " \\returns the number of active fingers for a given touch device on success"]
    #[doc = "          or 0 on failure; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetTouchFinger"]
    pub fn SDL_GetNumTouchFingers(touchID: SDL_TouchID) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the finger object for specified touch device ID and finger index."]
    #[doc = ""]
    #[doc = " The returned resource is owned by SDL and should not be deallocated."]
    #[doc = ""]
    #[doc = " \\param touchID the ID of the requested touch device"]
    #[doc = " \\param index the index of the requested finger"]
    #[doc = " \\returns a pointer to the SDL_Finger object or NULL if no object at the"]
    #[doc = "          given ID and index could be found."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_RecordGesture"]
    pub fn SDL_GetTouchFinger(touchID: SDL_TouchID, index: libc::c_int) -> *mut SDL_Finger;
}
pub type SDL_GestureID = Sint64;
extern "C" {
    #[doc = " Begin recording a gesture on a specified touch device or all touch devices."]
    #[doc = ""]
    #[doc = " If the parameter `touchId` is -1 (i.e., all devices), this function will"]
    #[doc = " always return 1, regardless of whether there actually are any devices."]
    #[doc = ""]
    #[doc = " \\param touchId the touch device id, or -1 for all touch devices"]
    #[doc = " \\returns 1 on success or 0 if the specified device could not be found."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetTouchDevice"]
    pub fn SDL_RecordGesture(touchId: SDL_TouchID) -> libc::c_int;
}
extern "C" {
    #[doc = " Save all currently loaded Dollar Gesture templates."]
    #[doc = ""]
    #[doc = " \\param dst a SDL_RWops to save to"]
    #[doc = " \\returns the number of saved templates on success or 0 on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_LoadDollarTemplates"]
    #[doc = " \\sa SDL_SaveDollarTemplate"]
    pub fn SDL_SaveAllDollarTemplates(dst: *mut SDL_RWops) -> libc::c_int;
}
extern "C" {
    #[doc = " Save a currently loaded Dollar Gesture template."]
    #[doc = ""]
    #[doc = " \\param gestureId a gesture id"]
    #[doc = " \\param dst a SDL_RWops to save to"]
    #[doc = " \\returns 1 on success or 0 on failure; call SDL_GetError() for more"]
    #[doc = "          information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_LoadDollarTemplates"]
    #[doc = " \\sa SDL_SaveAllDollarTemplates"]
    pub fn SDL_SaveDollarTemplate(gestureId: SDL_GestureID, dst: *mut SDL_RWops) -> libc::c_int;
}
extern "C" {
    #[doc = " Load Dollar Gesture templates from a file."]
    #[doc = ""]
    #[doc = " \\param touchId a touch id"]
    #[doc = " \\param src a SDL_RWops to load from"]
    #[doc = " \\returns the number of loaded templates on success or a negative error code"]
    #[doc = "          (or 0) on failure; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_SaveAllDollarTemplates"]
    #[doc = " \\sa SDL_SaveDollarTemplate"]
    pub fn SDL_LoadDollarTemplates(touchId: SDL_TouchID, src: *mut SDL_RWops) -> libc::c_int;
}
#[repr(u32)]
#[doc = " The types of events that can be delivered."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_EventType {
    #[doc = "< Unused (do not remove)"]
    SDL_FIRSTEVENT = 0,
    #[doc = "< User-requested quit"]
    SDL_QUIT = 256,
    #[doc = "< The application is being terminated by the OS"]
    #[doc = "Called on iOS in applicationWillTerminate()"]
    #[doc = "Called on Android in onDestroy()"]
    SDL_APP_TERMINATING = 257,
    #[doc = "< The application is low on memory, free memory if possible."]
    #[doc = "Called on iOS in applicationDidReceiveMemoryWarning()"]
    #[doc = "Called on Android in onLowMemory()"]
    SDL_APP_LOWMEMORY = 258,
    #[doc = "< The application is about to enter the background"]
    #[doc = "Called on iOS in applicationWillResignActive()"]
    #[doc = "Called on Android in onPause()"]
    SDL_APP_WILLENTERBACKGROUND = 259,
    #[doc = "< The application did enter the background and may not get CPU for some time"]
    #[doc = "Called on iOS in applicationDidEnterBackground()"]
    #[doc = "Called on Android in onPause()"]
    SDL_APP_DIDENTERBACKGROUND = 260,
    #[doc = "< The application is about to enter the foreground"]
    #[doc = "Called on iOS in applicationWillEnterForeground()"]
    #[doc = "Called on Android in onResume()"]
    SDL_APP_WILLENTERFOREGROUND = 261,
    #[doc = "< The application is now interactive"]
    #[doc = "Called on iOS in applicationDidBecomeActive()"]
    #[doc = "Called on Android in onResume()"]
    SDL_APP_DIDENTERFOREGROUND = 262,
    #[doc = "< The user's locale preferences have changed."]
    SDL_LOCALECHANGED = 263,
    #[doc = "< Display state change"]
    SDL_DISPLAYEVENT = 336,
    #[doc = "< Window state change"]
    SDL_WINDOWEVENT = 512,
    #[doc = "< System specific event"]
    SDL_SYSWMEVENT = 513,
    #[doc = "< Key pressed"]
    SDL_KEYDOWN = 768,
    #[doc = "< Key released"]
    SDL_KEYUP = 769,
    #[doc = "< Keyboard text editing (composition)"]
    SDL_TEXTEDITING = 770,
    #[doc = "< Keyboard text input"]
    SDL_TEXTINPUT = 771,
    #[doc = "< Keymap changed due to a system event such as an"]
    #[doc = "input language or keyboard layout change."]
    SDL_KEYMAPCHANGED = 772,
    #[doc = "< Mouse moved"]
    SDL_MOUSEMOTION = 1024,
    #[doc = "< Mouse button pressed"]
    SDL_MOUSEBUTTONDOWN = 1025,
    #[doc = "< Mouse button released"]
    SDL_MOUSEBUTTONUP = 1026,
    #[doc = "< Mouse wheel motion"]
    SDL_MOUSEWHEEL = 1027,
    #[doc = "< Joystick axis motion"]
    SDL_JOYAXISMOTION = 1536,
    #[doc = "< Joystick trackball motion"]
    SDL_JOYBALLMOTION = 1537,
    #[doc = "< Joystick hat position change"]
    SDL_JOYHATMOTION = 1538,
    #[doc = "< Joystick button pressed"]
    SDL_JOYBUTTONDOWN = 1539,
    #[doc = "< Joystick button released"]
    SDL_JOYBUTTONUP = 1540,
    #[doc = "< A new joystick has been inserted into the system"]
    SDL_JOYDEVICEADDED = 1541,
    #[doc = "< An opened joystick has been removed"]
    SDL_JOYDEVICEREMOVED = 1542,
    #[doc = "< Game controller axis motion"]
    SDL_CONTROLLERAXISMOTION = 1616,
    #[doc = "< Game controller button pressed"]
    SDL_CONTROLLERBUTTONDOWN = 1617,
    #[doc = "< Game controller button released"]
    SDL_CONTROLLERBUTTONUP = 1618,
    #[doc = "< A new Game controller has been inserted into the system"]
    SDL_CONTROLLERDEVICEADDED = 1619,
    #[doc = "< An opened Game controller has been removed"]
    SDL_CONTROLLERDEVICEREMOVED = 1620,
    #[doc = "< The controller mapping was updated"]
    SDL_CONTROLLERDEVICEREMAPPED = 1621,
    #[doc = "< Game controller touchpad was touched"]
    SDL_CONTROLLERTOUCHPADDOWN = 1622,
    #[doc = "< Game controller touchpad finger was moved"]
    SDL_CONTROLLERTOUCHPADMOTION = 1623,
    #[doc = "< Game controller touchpad finger was lifted"]
    SDL_CONTROLLERTOUCHPADUP = 1624,
    #[doc = "< Game controller sensor was updated"]
    SDL_CONTROLLERSENSORUPDATE = 1625,
    SDL_FINGERDOWN = 1792,
    SDL_FINGERUP = 1793,
    SDL_FINGERMOTION = 1794,
    SDL_DOLLARGESTURE = 2048,
    SDL_DOLLARRECORD = 2049,
    SDL_MULTIGESTURE = 2050,
    #[doc = "< The clipboard changed"]
    SDL_CLIPBOARDUPDATE = 2304,
    #[doc = "< The system requests a file open"]
    SDL_DROPFILE = 4096,
    #[doc = "< text/plain drag-and-drop event"]
    SDL_DROPTEXT = 4097,
    #[doc = "< A new set of drops is beginning (NULL filename)"]
    SDL_DROPBEGIN = 4098,
    #[doc = "< Current set of drops is now complete (NULL filename)"]
    SDL_DROPCOMPLETE = 4099,
    #[doc = "< A new audio device is available"]
    SDL_AUDIODEVICEADDED = 4352,
    #[doc = "< An audio device has been removed."]
    SDL_AUDIODEVICEREMOVED = 4353,
    #[doc = "< A sensor was updated"]
    SDL_SENSORUPDATE = 4608,
    #[doc = "< The render targets have been reset and their contents need to be updated"]
    SDL_RENDER_TARGETS_RESET = 8192,
    #[doc = "< The device has been reset and all textures need to be recreated"]
    SDL_RENDER_DEVICE_RESET = 8193,
    #[doc = "< Signals the end of an event poll cycle"]
    SDL_POLLSENTINEL = 32512,
    #[doc = " Events ::SDL_USEREVENT through ::SDL_LASTEVENT are for your use,"]
    #[doc = "  and should be allocated with SDL_RegisterEvents()"]
    SDL_USEREVENT = 32768,
    #[doc = "  This last event is only for bounding internal arrays"]
    SDL_LASTEVENT = 65535,
}
#[doc = "  \\brief Fields shared by every event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_CommonEvent {
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_CommonEvent() {
    assert_eq!(
        ::core::mem::size_of::<SDL_CommonEvent>(),
        8usize,
        concat!("Size of: ", stringify!(SDL_CommonEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_CommonEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_CommonEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_CommonEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_CommonEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_CommonEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_CommonEvent),
            "::",
            stringify!(timestamp)
        )
    );
}
#[doc = "  \\brief Display state change event data (event.display.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_DisplayEvent {
    #[doc = "< ::SDL_DISPLAYEVENT"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The associated display index"]
    pub display: Uint32,
    #[doc = "< ::SDL_DisplayEventID"]
    pub event: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    #[doc = "< event dependent data"]
    pub data1: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_DisplayEvent() {
    assert_eq!(
        ::core::mem::size_of::<SDL_DisplayEvent>(),
        20usize,
        concat!("Size of: ", stringify!(SDL_DisplayEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_DisplayEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_DisplayEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).display as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).event as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayEvent),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).padding1 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).padding2 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayEvent),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).padding3 as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayEvent),
            "::",
            stringify!(padding3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_DisplayEvent>())).data1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayEvent),
            "::",
            stringify!(data1)
        )
    );
}
#[doc = "  \\brief Window state change event data (event.window.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_WindowEvent {
    #[doc = "< ::SDL_WINDOWEVENT"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The associated window"]
    pub windowID: Uint32,
    #[doc = "< ::SDL_WindowEventID"]
    pub event: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    #[doc = "< event dependent data"]
    pub data1: Sint32,
    #[doc = "< event dependent data"]
    pub data2: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_WindowEvent() {
    assert_eq!(
        ::core::mem::size_of::<SDL_WindowEvent>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_WindowEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_WindowEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_WindowEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).windowID as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).event as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).padding1 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).padding2 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).padding3 as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(padding3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).data1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(data1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_WindowEvent>())).data2 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(data2)
        )
    );
}
#[doc = "  \\brief Keyboard button event structure (event.key.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_KeyboardEvent {
    #[doc = "< ::SDL_KEYDOWN or ::SDL_KEYUP"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The window with keyboard focus, if any"]
    pub windowID: Uint32,
    #[doc = "< ::SDL_PRESSED or ::SDL_RELEASED"]
    pub state: Uint8,
    #[doc = "< Non-zero if this is a key repeat"]
    pub repeat: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    #[doc = "< The key that was pressed or released"]
    pub keysym: SDL_Keysym,
}
#[test]
fn bindgen_test_layout_SDL_KeyboardEvent() {
    assert_eq!(
        ::core::mem::size_of::<SDL_KeyboardEvent>(),
        32usize,
        concat!("Size of: ", stringify!(SDL_KeyboardEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_KeyboardEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_KeyboardEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).windowID as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).state as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).repeat as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(repeat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).padding2 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).padding3 as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(padding3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_KeyboardEvent>())).keysym as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(keysym)
        )
    );
}
#[doc = "  \\brief Keyboard text editing event structure (event.edit.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_TextEditingEvent {
    #[doc = "< ::SDL_TEXTEDITING"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The window with keyboard focus, if any"]
    pub windowID: Uint32,
    #[doc = "< The editing text"]
    pub text: [libc::c_char; 32usize],
    #[doc = "< The start cursor of selected editing text"]
    pub start: Sint32,
    #[doc = "< The length of selected editing text"]
    pub length: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_TextEditingEvent() {
    assert_eq!(
        ::core::mem::size_of::<SDL_TextEditingEvent>(),
        52usize,
        concat!("Size of: ", stringify!(SDL_TextEditingEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_TextEditingEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_TextEditingEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_TextEditingEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextEditingEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_TextEditingEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextEditingEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_TextEditingEvent>())).windowID as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextEditingEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_TextEditingEvent>())).text as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextEditingEvent),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_TextEditingEvent>())).start as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextEditingEvent),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_TextEditingEvent>())).length as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextEditingEvent),
            "::",
            stringify!(length)
        )
    );
}
#[doc = "  \\brief Keyboard text input event structure (event.text.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_TextInputEvent {
    #[doc = "< ::SDL_TEXTINPUT"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The window with keyboard focus, if any"]
    pub windowID: Uint32,
    #[doc = "< The input text"]
    pub text: [libc::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_SDL_TextInputEvent() {
    assert_eq!(
        ::core::mem::size_of::<SDL_TextInputEvent>(),
        44usize,
        concat!("Size of: ", stringify!(SDL_TextInputEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_TextInputEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_TextInputEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_TextInputEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextInputEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_TextInputEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextInputEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_TextInputEvent>())).windowID as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextInputEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_TextInputEvent>())).text as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextInputEvent),
            "::",
            stringify!(text)
        )
    );
}
#[doc = "  \\brief Mouse motion event structure (event.motion.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_MouseMotionEvent {
    #[doc = "< ::SDL_MOUSEMOTION"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The window with mouse focus, if any"]
    pub windowID: Uint32,
    #[doc = "< The mouse instance id, or SDL_TOUCH_MOUSEID"]
    pub which: Uint32,
    #[doc = "< The current button state"]
    pub state: Uint32,
    #[doc = "< X coordinate, relative to window"]
    pub x: Sint32,
    #[doc = "< Y coordinate, relative to window"]
    pub y: Sint32,
    #[doc = "< The relative motion in the X direction"]
    pub xrel: Sint32,
    #[doc = "< The relative motion in the Y direction"]
    pub yrel: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_MouseMotionEvent() {
    assert_eq!(
        ::core::mem::size_of::<SDL_MouseMotionEvent>(),
        36usize,
        concat!("Size of: ", stringify!(SDL_MouseMotionEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_MouseMotionEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_MouseMotionEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).windowID as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).which as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).x as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).y as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).xrel as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(xrel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MouseMotionEvent>())).yrel as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(yrel)
        )
    );
}
#[doc = "  \\brief Mouse button event structure (event.button.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_MouseButtonEvent {
    #[doc = "< ::SDL_MOUSEBUTTONDOWN or ::SDL_MOUSEBUTTONUP"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The window with mouse focus, if any"]
    pub windowID: Uint32,
    #[doc = "< The mouse instance id, or SDL_TOUCH_MOUSEID"]
    pub which: Uint32,
    #[doc = "< The mouse button index"]
    pub button: Uint8,
    #[doc = "< ::SDL_PRESSED or ::SDL_RELEASED"]
    pub state: Uint8,
    #[doc = "< 1 for single-click, 2 for double-click, etc."]
    pub clicks: Uint8,
    pub padding1: Uint8,
    #[doc = "< X coordinate, relative to window"]
    pub x: Sint32,
    #[doc = "< Y coordinate, relative to window"]
    pub y: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_MouseButtonEvent() {
    assert_eq!(
        ::core::mem::size_of::<SDL_MouseButtonEvent>(),
        28usize,
        concat!("Size of: ", stringify!(SDL_MouseButtonEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_MouseButtonEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_MouseButtonEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).windowID as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).which as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).button as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).state as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).clicks as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(clicks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).padding1 as *const _ as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).x as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MouseButtonEvent>())).y as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(y)
        )
    );
}
#[doc = "  \\brief Mouse wheel event structure (event.wheel.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_MouseWheelEvent {
    #[doc = "< ::SDL_MOUSEWHEEL"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The window with mouse focus, if any"]
    pub windowID: Uint32,
    #[doc = "< The mouse instance id, or SDL_TOUCH_MOUSEID"]
    pub which: Uint32,
    #[doc = "< The amount scrolled horizontally, positive to the right and negative to the left"]
    pub x: Sint32,
    #[doc = "< The amount scrolled vertically, positive away from the user and negative toward the user"]
    pub y: Sint32,
    #[doc = "< Set to one of the SDL_MOUSEWHEEL_* defines. When FLIPPED the values in X and Y will be opposite. Multiply by -1 to change them back"]
    pub direction: Uint32,
    #[doc = "< The amount scrolled horizontally, positive to the right and negative to the left, with float precision (added in 2.0.18)"]
    pub preciseX: f32,
    #[doc = "< The amount scrolled vertically, positive away from the user and negative toward the user, with float precision (added in 2.0.18)"]
    pub preciseY: f32,
}
#[test]
fn bindgen_test_layout_SDL_MouseWheelEvent() {
    assert_eq!(
        ::core::mem::size_of::<SDL_MouseWheelEvent>(),
        36usize,
        concat!("Size of: ", stringify!(SDL_MouseWheelEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_MouseWheelEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_MouseWheelEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MouseWheelEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MouseWheelEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MouseWheelEvent>())).windowID as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MouseWheelEvent>())).which as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MouseWheelEvent>())).x as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MouseWheelEvent>())).y as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MouseWheelEvent>())).direction as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MouseWheelEvent>())).preciseX as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(preciseX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MouseWheelEvent>())).preciseY as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(preciseY)
        )
    );
}
#[doc = "  \\brief Joystick axis motion event structure (event.jaxis.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_JoyAxisEvent {
    #[doc = "< ::SDL_JOYAXISMOTION"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The joystick axis index"]
    pub axis: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    #[doc = "< The axis value (range: -32768 to 32767)"]
    pub value: Sint16,
    pub padding4: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_JoyAxisEvent() {
    assert_eq!(
        ::core::mem::size_of::<SDL_JoyAxisEvent>(),
        20usize,
        concat!("Size of: ", stringify!(SDL_JoyAxisEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_JoyAxisEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_JoyAxisEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).which as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).axis as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(axis)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).padding1 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).padding2 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).padding3 as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(padding3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyAxisEvent>())).padding4 as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(padding4)
        )
    );
}
#[doc = "  \\brief Joystick trackball motion event structure (event.jball.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_JoyBallEvent {
    #[doc = "< ::SDL_JOYBALLMOTION"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The joystick trackball index"]
    pub ball: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    #[doc = "< The relative motion in the X direction"]
    pub xrel: Sint16,
    #[doc = "< The relative motion in the Y direction"]
    pub yrel: Sint16,
}
#[test]
fn bindgen_test_layout_SDL_JoyBallEvent() {
    assert_eq!(
        ::core::mem::size_of::<SDL_JoyBallEvent>(),
        20usize,
        concat!("Size of: ", stringify!(SDL_JoyBallEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_JoyBallEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_JoyBallEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).which as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).ball as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(ball)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).padding1 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).padding2 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).padding3 as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(padding3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).xrel as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(xrel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyBallEvent>())).yrel as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(yrel)
        )
    );
}
#[doc = "  \\brief Joystick hat position change event structure (event.jhat.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_JoyHatEvent {
    #[doc = "< ::SDL_JOYHATMOTION"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The joystick hat index"]
    pub hat: Uint8,
    #[doc = "< The hat position value."]
    #[doc = "   \\sa ::SDL_HAT_LEFTUP ::SDL_HAT_UP ::SDL_HAT_RIGHTUP"]
    #[doc = "   \\sa ::SDL_HAT_LEFT ::SDL_HAT_CENTERED ::SDL_HAT_RIGHT"]
    #[doc = "   \\sa ::SDL_HAT_LEFTDOWN ::SDL_HAT_DOWN ::SDL_HAT_RIGHTDOWN"]
    #[doc = ""]
    #[doc = "   Note that zero means the POV is centered."]
    pub value: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_JoyHatEvent() {
    assert_eq!(
        ::core::mem::size_of::<SDL_JoyHatEvent>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_JoyHatEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_JoyHatEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_JoyHatEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyHatEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyHatEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyHatEvent>())).which as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyHatEvent>())).hat as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(hat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyHatEvent>())).value as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyHatEvent>())).padding1 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyHatEvent>())).padding2 as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(padding2)
        )
    );
}
#[doc = "  \\brief Joystick button event structure (event.jbutton.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_JoyButtonEvent {
    #[doc = "< ::SDL_JOYBUTTONDOWN or ::SDL_JOYBUTTONUP"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The joystick button index"]
    pub button: Uint8,
    #[doc = "< ::SDL_PRESSED or ::SDL_RELEASED"]
    pub state: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_JoyButtonEvent() {
    assert_eq!(
        ::core::mem::size_of::<SDL_JoyButtonEvent>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_JoyButtonEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_JoyButtonEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_JoyButtonEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyButtonEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyButtonEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyButtonEvent>())).which as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyButtonEvent>())).button as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyButtonEvent>())).state as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyButtonEvent>())).padding1 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyButtonEvent>())).padding2 as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(padding2)
        )
    );
}
#[doc = "  \\brief Joystick device event structure (event.jdevice.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_JoyDeviceEvent {
    #[doc = "< ::SDL_JOYDEVICEADDED or ::SDL_JOYDEVICEREMOVED"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The joystick device index for the ADDED event, instance id for the REMOVED event"]
    pub which: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_JoyDeviceEvent() {
    assert_eq!(
        ::core::mem::size_of::<SDL_JoyDeviceEvent>(),
        12usize,
        concat!("Size of: ", stringify!(SDL_JoyDeviceEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_JoyDeviceEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_JoyDeviceEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyDeviceEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyDeviceEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyDeviceEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyDeviceEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_JoyDeviceEvent>())).which as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyDeviceEvent),
            "::",
            stringify!(which)
        )
    );
}
#[doc = "  \\brief Game controller axis motion event structure (event.caxis.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_ControllerAxisEvent {
    #[doc = "< ::SDL_CONTROLLERAXISMOTION"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The controller axis (SDL_GameControllerAxis)"]
    pub axis: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    #[doc = "< The axis value (range: -32768 to 32767)"]
    pub value: Sint16,
    pub padding4: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_ControllerAxisEvent() {
    assert_eq!(
        ::core::mem::size_of::<SDL_ControllerAxisEvent>(),
        20usize,
        concat!("Size of: ", stringify!(SDL_ControllerAxisEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_ControllerAxisEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_ControllerAxisEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerAxisEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).timestamp as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerAxisEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).which as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerAxisEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).axis as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerAxisEvent),
            "::",
            stringify!(axis)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).padding1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerAxisEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).padding2 as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerAxisEvent),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).padding3 as *const _ as usize
        },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerAxisEvent),
            "::",
            stringify!(padding3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerAxisEvent),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_ControllerAxisEvent>())).padding4 as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerAxisEvent),
            "::",
            stringify!(padding4)
        )
    );
}
#[doc = "  \\brief Game controller button event structure (event.cbutton.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_ControllerButtonEvent {
    #[doc = "< ::SDL_CONTROLLERBUTTONDOWN or ::SDL_CONTROLLERBUTTONUP"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The controller button (SDL_GameControllerButton)"]
    pub button: Uint8,
    #[doc = "< ::SDL_PRESSED or ::SDL_RELEASED"]
    pub state: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_ControllerButtonEvent() {
    assert_eq!(
        ::core::mem::size_of::<SDL_ControllerButtonEvent>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_ControllerButtonEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_ControllerButtonEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_ControllerButtonEvent))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_ControllerButtonEvent>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerButtonEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_ControllerButtonEvent>())).timestamp as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerButtonEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_ControllerButtonEvent>())).which as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerButtonEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_ControllerButtonEvent>())).button as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerButtonEvent),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_ControllerButtonEvent>())).state as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerButtonEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_ControllerButtonEvent>())).padding1 as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerButtonEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_ControllerButtonEvent>())).padding2 as *const _ as usize
        },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerButtonEvent),
            "::",
            stringify!(padding2)
        )
    );
}
#[doc = "  \\brief Controller device event structure (event.cdevice.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_ControllerDeviceEvent {
    #[doc = "< ::SDL_CONTROLLERDEVICEADDED, ::SDL_CONTROLLERDEVICEREMOVED, or ::SDL_CONTROLLERDEVICEREMAPPED"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The joystick device index for the ADDED event, instance id for the REMOVED or REMAPPED event"]
    pub which: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_ControllerDeviceEvent() {
    assert_eq!(
        ::core::mem::size_of::<SDL_ControllerDeviceEvent>(),
        12usize,
        concat!("Size of: ", stringify!(SDL_ControllerDeviceEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_ControllerDeviceEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_ControllerDeviceEvent))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_ControllerDeviceEvent>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerDeviceEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_ControllerDeviceEvent>())).timestamp as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerDeviceEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_ControllerDeviceEvent>())).which as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerDeviceEvent),
            "::",
            stringify!(which)
        )
    );
}
#[doc = "  \\brief Game controller touchpad event structure (event.ctouchpad.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_ControllerTouchpadEvent {
    #[doc = "< ::SDL_CONTROLLERTOUCHPADDOWN or ::SDL_CONTROLLERTOUCHPADMOTION or ::SDL_CONTROLLERTOUCHPADUP"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The index of the touchpad"]
    pub touchpad: Sint32,
    #[doc = "< The index of the finger on the touchpad"]
    pub finger: Sint32,
    #[doc = "< Normalized in the range 0...1 with 0 being on the left"]
    pub x: f32,
    #[doc = "< Normalized in the range 0...1 with 0 being at the top"]
    pub y: f32,
    #[doc = "< Normalized in the range 0...1"]
    pub pressure: f32,
}
#[test]
fn bindgen_test_layout_SDL_ControllerTouchpadEvent() {
    assert_eq!(
        ::core::mem::size_of::<SDL_ControllerTouchpadEvent>(),
        32usize,
        concat!("Size of: ", stringify!(SDL_ControllerTouchpadEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_ControllerTouchpadEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_ControllerTouchpadEvent))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_ControllerTouchpadEvent>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerTouchpadEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_ControllerTouchpadEvent>())).timestamp as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerTouchpadEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_ControllerTouchpadEvent>())).which as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerTouchpadEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_ControllerTouchpadEvent>())).touchpad as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerTouchpadEvent),
            "::",
            stringify!(touchpad)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_ControllerTouchpadEvent>())).finger as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerTouchpadEvent),
            "::",
            stringify!(finger)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_ControllerTouchpadEvent>())).x as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerTouchpadEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_ControllerTouchpadEvent>())).y as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerTouchpadEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_ControllerTouchpadEvent>())).pressure as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerTouchpadEvent),
            "::",
            stringify!(pressure)
        )
    );
}
#[doc = "  \\brief Game controller sensor event structure (event.csensor.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_ControllerSensorEvent {
    #[doc = "< ::SDL_CONTROLLERSENSORUPDATE"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The type of the sensor, one of the values of ::SDL_SensorType"]
    pub sensor: Sint32,
    #[doc = "< Up to 3 values from the sensor, as defined in SDL_sensor.h"]
    pub data: [f32; 3usize],
}
#[test]
fn bindgen_test_layout_SDL_ControllerSensorEvent() {
    assert_eq!(
        ::core::mem::size_of::<SDL_ControllerSensorEvent>(),
        28usize,
        concat!("Size of: ", stringify!(SDL_ControllerSensorEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_ControllerSensorEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_ControllerSensorEvent))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_ControllerSensorEvent>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerSensorEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_ControllerSensorEvent>())).timestamp as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerSensorEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_ControllerSensorEvent>())).which as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerSensorEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_ControllerSensorEvent>())).sensor as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerSensorEvent),
            "::",
            stringify!(sensor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_ControllerSensorEvent>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerSensorEvent),
            "::",
            stringify!(data)
        )
    );
}
#[doc = "  \\brief Audio device event structure (event.adevice.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_AudioDeviceEvent {
    #[doc = "< ::SDL_AUDIODEVICEADDED, or ::SDL_AUDIODEVICEREMOVED"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The audio device index for the ADDED event (valid until next SDL_GetNumAudioDevices() call), SDL_AudioDeviceID for the REMOVED event"]
    pub which: Uint32,
    #[doc = "< zero if an output device, non-zero if a capture device."]
    pub iscapture: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_AudioDeviceEvent() {
    assert_eq!(
        ::core::mem::size_of::<SDL_AudioDeviceEvent>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_AudioDeviceEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_AudioDeviceEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_AudioDeviceEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AudioDeviceEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioDeviceEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AudioDeviceEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioDeviceEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AudioDeviceEvent>())).which as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioDeviceEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AudioDeviceEvent>())).iscapture as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioDeviceEvent),
            "::",
            stringify!(iscapture)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AudioDeviceEvent>())).padding1 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioDeviceEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AudioDeviceEvent>())).padding2 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioDeviceEvent),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_AudioDeviceEvent>())).padding3 as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioDeviceEvent),
            "::",
            stringify!(padding3)
        )
    );
}
#[doc = "  \\brief Touch finger event structure (event.tfinger.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_TouchFingerEvent {
    #[doc = "< ::SDL_FINGERMOTION or ::SDL_FINGERDOWN or ::SDL_FINGERUP"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The touch device id"]
    pub touchId: SDL_TouchID,
    pub fingerId: SDL_FingerID,
    #[doc = "< Normalized in the range 0...1"]
    pub x: f32,
    #[doc = "< Normalized in the range 0...1"]
    pub y: f32,
    #[doc = "< Normalized in the range -1...1"]
    pub dx: f32,
    #[doc = "< Normalized in the range -1...1"]
    pub dy: f32,
    #[doc = "< Normalized in the range 0...1"]
    pub pressure: f32,
    #[doc = "< The window underneath the finger, if any"]
    pub windowID: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_TouchFingerEvent() {
    assert_eq!(
        ::core::mem::size_of::<SDL_TouchFingerEvent>(),
        48usize,
        concat!("Size of: ", stringify!(SDL_TouchFingerEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_TouchFingerEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_TouchFingerEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).touchId as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(touchId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).fingerId as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(fingerId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).x as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).y as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).dx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).dy as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(dy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).pressure as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(pressure)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_TouchFingerEvent>())).windowID as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(windowID)
        )
    );
}
#[doc = "  \\brief Multiple Finger Gesture Event (event.mgesture.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_MultiGestureEvent {
    #[doc = "< ::SDL_MULTIGESTURE"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The touch device id"]
    pub touchId: SDL_TouchID,
    pub dTheta: f32,
    pub dDist: f32,
    pub x: f32,
    pub y: f32,
    pub numFingers: Uint16,
    pub padding: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_MultiGestureEvent() {
    assert_eq!(
        ::core::mem::size_of::<SDL_MultiGestureEvent>(),
        40usize,
        concat!("Size of: ", stringify!(SDL_MultiGestureEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_MultiGestureEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_MultiGestureEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MultiGestureEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).timestamp as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MultiGestureEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).touchId as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MultiGestureEvent),
            "::",
            stringify!(touchId)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).dTheta as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MultiGestureEvent),
            "::",
            stringify!(dTheta)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).dDist as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MultiGestureEvent),
            "::",
            stringify!(dDist)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).x as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MultiGestureEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).y as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MultiGestureEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).numFingers as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MultiGestureEvent),
            "::",
            stringify!(numFingers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MultiGestureEvent>())).padding as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MultiGestureEvent),
            "::",
            stringify!(padding)
        )
    );
}
#[doc = " \\brief Dollar Gesture Event (event.dgesture.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_DollarGestureEvent {
    #[doc = "< ::SDL_DOLLARGESTURE or ::SDL_DOLLARRECORD"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The touch device id"]
    pub touchId: SDL_TouchID,
    pub gestureId: SDL_GestureID,
    pub numFingers: Uint32,
    pub error: f32,
    #[doc = "< Normalized center of gesture"]
    pub x: f32,
    #[doc = "< Normalized center of gesture"]
    pub y: f32,
}
#[test]
fn bindgen_test_layout_SDL_DollarGestureEvent() {
    assert_eq!(
        ::core::mem::size_of::<SDL_DollarGestureEvent>(),
        40usize,
        concat!("Size of: ", stringify!(SDL_DollarGestureEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_DollarGestureEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_DollarGestureEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DollarGestureEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).timestamp as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DollarGestureEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).touchId as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DollarGestureEvent),
            "::",
            stringify!(touchId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).gestureId as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DollarGestureEvent),
            "::",
            stringify!(gestureId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).numFingers as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DollarGestureEvent),
            "::",
            stringify!(numFingers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).error as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DollarGestureEvent),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).x as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DollarGestureEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_DollarGestureEvent>())).y as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DollarGestureEvent),
            "::",
            stringify!(y)
        )
    );
}
#[doc = "  \\brief An event used to request a file open by the system (event.drop.*)"]
#[doc = "         This event is enabled by default, you can disable it with SDL_EventState()."]
#[doc = "  \\note If this event is enabled, you must free the filename in the event."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_DropEvent {
    #[doc = "< ::SDL_DROPBEGIN or ::SDL_DROPFILE or ::SDL_DROPTEXT or ::SDL_DROPCOMPLETE"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The file name, which should be freed with SDL_free(), is NULL on begin/complete"]
    pub file: *mut libc::c_char,
    #[doc = "< The window that was dropped on, if any"]
    pub windowID: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_DropEvent() {
    assert_eq!(
        ::core::mem::size_of::<SDL_DropEvent>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_DropEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_DropEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_DropEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_DropEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DropEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_DropEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DropEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_DropEvent>())).file as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DropEvent),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_DropEvent>())).windowID as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DropEvent),
            "::",
            stringify!(windowID)
        )
    );
}
#[doc = "  \\brief Sensor event structure (event.sensor.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_SensorEvent {
    #[doc = "< ::SDL_SENSORUPDATE"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The instance ID of the sensor"]
    pub which: Sint32,
    #[doc = "< Up to 6 values from the sensor - additional values can be queried using SDL_SensorGetData()"]
    pub data: [f32; 6usize],
}
#[test]
fn bindgen_test_layout_SDL_SensorEvent() {
    assert_eq!(
        ::core::mem::size_of::<SDL_SensorEvent>(),
        36usize,
        concat!("Size of: ", stringify!(SDL_SensorEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_SensorEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_SensorEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_SensorEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SensorEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_SensorEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SensorEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_SensorEvent>())).which as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SensorEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_SensorEvent>())).data as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SensorEvent),
            "::",
            stringify!(data)
        )
    );
}
#[doc = "  \\brief The \"quit requested\" event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_QuitEvent {
    #[doc = "< ::SDL_QUIT"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_QuitEvent() {
    assert_eq!(
        ::core::mem::size_of::<SDL_QuitEvent>(),
        8usize,
        concat!("Size of: ", stringify!(SDL_QuitEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_QuitEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_QuitEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_QuitEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_QuitEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_QuitEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_QuitEvent),
            "::",
            stringify!(timestamp)
        )
    );
}
#[doc = "  \\brief OS Specific event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_OSEvent {
    #[doc = "< ::SDL_QUIT"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_OSEvent() {
    assert_eq!(
        ::core::mem::size_of::<SDL_OSEvent>(),
        8usize,
        concat!("Size of: ", stringify!(SDL_OSEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_OSEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_OSEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_OSEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_OSEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_OSEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_OSEvent),
            "::",
            stringify!(timestamp)
        )
    );
}
#[doc = "  \\brief A user-defined event type (event.user.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_UserEvent {
    #[doc = "< ::SDL_USEREVENT through ::SDL_LASTEVENT-1"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The associated window if any"]
    pub windowID: Uint32,
    #[doc = "< User defined event code"]
    pub code: Sint32,
    #[doc = "< User defined data pointer"]
    pub data1: *mut libc::c_void,
    #[doc = "< User defined data pointer"]
    pub data2: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_SDL_UserEvent() {
    assert_eq!(
        ::core::mem::size_of::<SDL_UserEvent>(),
        32usize,
        concat!("Size of: ", stringify!(SDL_UserEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_UserEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_UserEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_UserEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_UserEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_UserEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_UserEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_UserEvent>())).windowID as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_UserEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_UserEvent>())).code as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_UserEvent),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_UserEvent>())).data1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_UserEvent),
            "::",
            stringify!(data1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_UserEvent>())).data2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_UserEvent),
            "::",
            stringify!(data2)
        )
    );
}
#[doc = "  \\brief A video driver dependent system event (event.syswm.*)"]
#[doc = "         This event is disabled by default, you can enable it with SDL_EventState()"]
#[doc = ""]
#[doc = "  \\note If you want to use this event, you should include SDL_syswm.h."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_SysWMEvent {
    #[doc = "< ::SDL_SYSWMEVENT"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< driver dependent data, defined in SDL_syswm.h"]
    pub msg: *mut SDL_SysWMmsg,
}
#[test]
fn bindgen_test_layout_SDL_SysWMEvent() {
    assert_eq!(
        ::core::mem::size_of::<SDL_SysWMEvent>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_SysWMEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_SysWMEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_SysWMEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_SysWMEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_SysWMEvent>())).timestamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_SysWMEvent>())).msg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMEvent),
            "::",
            stringify!(msg)
        )
    );
}
#[doc = "  \\brief General event structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_Event {
    #[doc = "< Event type, shared with all events"]
    pub type_: Uint32,
    #[doc = "< Common event data"]
    pub common: SDL_CommonEvent,
    #[doc = "< Display event data"]
    pub display: SDL_DisplayEvent,
    #[doc = "< Window event data"]
    pub window: SDL_WindowEvent,
    #[doc = "< Keyboard event data"]
    pub key: SDL_KeyboardEvent,
    #[doc = "< Text editing event data"]
    pub edit: SDL_TextEditingEvent,
    #[doc = "< Text input event data"]
    pub text: SDL_TextInputEvent,
    #[doc = "< Mouse motion event data"]
    pub motion: SDL_MouseMotionEvent,
    #[doc = "< Mouse button event data"]
    pub button: SDL_MouseButtonEvent,
    #[doc = "< Mouse wheel event data"]
    pub wheel: SDL_MouseWheelEvent,
    #[doc = "< Joystick axis event data"]
    pub jaxis: SDL_JoyAxisEvent,
    #[doc = "< Joystick ball event data"]
    pub jball: SDL_JoyBallEvent,
    #[doc = "< Joystick hat event data"]
    pub jhat: SDL_JoyHatEvent,
    #[doc = "< Joystick button event data"]
    pub jbutton: SDL_JoyButtonEvent,
    #[doc = "< Joystick device change event data"]
    pub jdevice: SDL_JoyDeviceEvent,
    #[doc = "< Game Controller axis event data"]
    pub caxis: SDL_ControllerAxisEvent,
    #[doc = "< Game Controller button event data"]
    pub cbutton: SDL_ControllerButtonEvent,
    #[doc = "< Game Controller device event data"]
    pub cdevice: SDL_ControllerDeviceEvent,
    #[doc = "< Game Controller touchpad event data"]
    pub ctouchpad: SDL_ControllerTouchpadEvent,
    #[doc = "< Game Controller sensor event data"]
    pub csensor: SDL_ControllerSensorEvent,
    #[doc = "< Audio device event data"]
    pub adevice: SDL_AudioDeviceEvent,
    #[doc = "< Sensor event data"]
    pub sensor: SDL_SensorEvent,
    #[doc = "< Quit request event data"]
    pub quit: SDL_QuitEvent,
    #[doc = "< Custom event data"]
    pub user: SDL_UserEvent,
    #[doc = "< System dependent window event data"]
    pub syswm: SDL_SysWMEvent,
    #[doc = "< Touch finger event data"]
    pub tfinger: SDL_TouchFingerEvent,
    #[doc = "< Gesture event data"]
    pub mgesture: SDL_MultiGestureEvent,
    #[doc = "< Gesture event data"]
    pub dgesture: SDL_DollarGestureEvent,
    #[doc = "< Drag and drop event data"]
    pub drop: SDL_DropEvent,
    pub padding: [Uint8; 56usize],
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_SDL_Event() {
    assert_eq!(
        ::core::mem::size_of::<SDL_Event>(),
        56usize,
        concat!("Size of: ", stringify!(SDL_Event))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_Event>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_Event))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Event>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Event>())).common as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(common)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Event>())).display as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Event>())).window as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Event>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Event>())).edit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(edit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Event>())).text as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Event>())).motion as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(motion)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Event>())).button as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Event>())).wheel as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(wheel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Event>())).jaxis as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(jaxis)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Event>())).jball as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(jball)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Event>())).jhat as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(jhat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Event>())).jbutton as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(jbutton)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Event>())).jdevice as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(jdevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Event>())).caxis as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(caxis)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Event>())).cbutton as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(cbutton)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Event>())).cdevice as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(cdevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Event>())).ctouchpad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(ctouchpad)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Event>())).csensor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(csensor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Event>())).adevice as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(adevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Event>())).sensor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(sensor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Event>())).quit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(quit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Event>())).user as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Event>())).syswm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(syswm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Event>())).tfinger as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(tfinger)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Event>())).mgesture as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(mgesture)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Event>())).dgesture as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(dgesture)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Event>())).drop as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(drop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Event>())).padding as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(padding)
        )
    );
}
pub type SDL_compile_time_assert_SDL_Event = [libc::c_int; 1usize];
extern "C" {
    #[doc = " Pump the event loop, gathering events from the input devices."]
    #[doc = ""]
    #[doc = " This function updates the event queue and internal input device state."]
    #[doc = ""]
    #[doc = " **WARNING**: This should only be run in the thread that initialized the"]
    #[doc = " video subsystem, and for extra safety, you should consider only doing those"]
    #[doc = " things on the main thread in any case."]
    #[doc = ""]
    #[doc = " SDL_PumpEvents() gathers all the pending input information from devices and"]
    #[doc = " places it in the event queue. Without calls to SDL_PumpEvents() no events"]
    #[doc = " would ever be placed on the queue. Often the need for calls to"]
    #[doc = " SDL_PumpEvents() is hidden from the user since SDL_PollEvent() and"]
    #[doc = " SDL_WaitEvent() implicitly call SDL_PumpEvents(). However, if you are not"]
    #[doc = " polling or waiting for events (e.g. you are filtering them), then you must"]
    #[doc = " call SDL_PumpEvents() to force an event queue update."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_PollEvent"]
    #[doc = " \\sa SDL_WaitEvent"]
    pub fn SDL_PumpEvents();
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_eventaction {
    SDL_ADDEVENT = 0,
    SDL_PEEKEVENT = 1,
    SDL_GETEVENT = 2,
}
extern "C" {
    #[doc = " Check the event queue for messages and optionally return them."]
    #[doc = ""]
    #[doc = " `action` may be any of the following:"]
    #[doc = ""]
    #[doc = " - `SDL_ADDEVENT`: up to `numevents` events will be added to the back of the"]
    #[doc = "   event queue."]
    #[doc = " - `SDL_PEEKEVENT`: `numevents` events at the front of the event queue,"]
    #[doc = "   within the specified minimum and maximum type, will be returned to the"]
    #[doc = "   caller and will _not_ be removed from the queue."]
    #[doc = " - `SDL_GETEVENT`: up to `numevents` events at the front of the event queue,"]
    #[doc = "   within the specified minimum and maximum type, will be returned to the"]
    #[doc = "   caller and will be removed from the queue."]
    #[doc = ""]
    #[doc = " You may have to call SDL_PumpEvents() before calling this function."]
    #[doc = " Otherwise, the events may not be ready to be filtered when you call"]
    #[doc = " SDL_PeepEvents()."]
    #[doc = ""]
    #[doc = " This function is thread-safe."]
    #[doc = ""]
    #[doc = " \\param events destination buffer for the retrieved events"]
    #[doc = " \\param numevents if action is SDL_ADDEVENT, the number of events to add"]
    #[doc = "                  back to the event queue; if action is SDL_PEEKEVENT or"]
    #[doc = "                  SDL_GETEVENT, the maximum number of events to retrieve"]
    #[doc = " \\param action action to take; see [[#action|Remarks]] for details"]
    #[doc = " \\param minType minimum value of the event type to be considered;"]
    #[doc = "                SDL_FIRSTEVENT is a safe choice"]
    #[doc = " \\param maxType maximum value of the event type to be considered;"]
    #[doc = "                SDL_LASTEVENT is a safe choice"]
    #[doc = " \\returns the number of events actually stored or a negative error code on"]
    #[doc = "          failure; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_PollEvent"]
    #[doc = " \\sa SDL_PumpEvents"]
    #[doc = " \\sa SDL_PushEvent"]
    pub fn SDL_PeepEvents(
        events: *mut SDL_Event,
        numevents: libc::c_int,
        action: SDL_eventaction,
        minType: Uint32,
        maxType: Uint32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Check for the existence of a certain event type in the event queue."]
    #[doc = ""]
    #[doc = " If you need to check for a range of event types, use SDL_HasEvents()"]
    #[doc = " instead."]
    #[doc = ""]
    #[doc = " \\param type the type of event to be queried; see SDL_EventType for details"]
    #[doc = " \\returns SDL_TRUE if events matching `type` are present, or SDL_FALSE if"]
    #[doc = "          events matching `type` are not present."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HasEvents"]
    pub fn SDL_HasEvent(type_: Uint32) -> SDL_bool;
}
extern "C" {
    #[doc = " Check for the existence of certain event types in the event queue."]
    #[doc = ""]
    #[doc = " If you need to check for a single event type, use SDL_HasEvent() instead."]
    #[doc = ""]
    #[doc = " \\param minType the low end of event type to be queried, inclusive; see"]
    #[doc = "                SDL_EventType for details"]
    #[doc = " \\param maxType the high end of event type to be queried, inclusive; see"]
    #[doc = "                SDL_EventType for details"]
    #[doc = " \\returns SDL_TRUE if events with type >= `minType` and <= `maxType` are"]
    #[doc = "          present, or SDL_FALSE if not."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HasEvents"]
    pub fn SDL_HasEvents(minType: Uint32, maxType: Uint32) -> SDL_bool;
}
extern "C" {
    #[doc = " Clear events of a specific type from the event queue."]
    #[doc = ""]
    #[doc = " This will unconditionally remove any events from the queue that match"]
    #[doc = " `type`. If you need to remove a range of event types, use SDL_FlushEvents()"]
    #[doc = " instead."]
    #[doc = ""]
    #[doc = " It's also normal to just ignore events you don't care about in your event"]
    #[doc = " loop without calling this function."]
    #[doc = ""]
    #[doc = " This function only affects currently queued events. If you want to make"]
    #[doc = " sure that all pending OS events are flushed, you can call SDL_PumpEvents()"]
    #[doc = " on the main thread immediately before the flush call."]
    #[doc = ""]
    #[doc = " \\param type the type of event to be cleared; see SDL_EventType for details"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_FlushEvents"]
    pub fn SDL_FlushEvent(type_: Uint32);
}
extern "C" {
    #[doc = " Clear events of a range of types from the event queue."]
    #[doc = ""]
    #[doc = " This will unconditionally remove any events from the queue that are in the"]
    #[doc = " range of `minType` to `maxType`, inclusive. If you need to remove a single"]
    #[doc = " event type, use SDL_FlushEvent() instead."]
    #[doc = ""]
    #[doc = " It's also normal to just ignore events you don't care about in your event"]
    #[doc = " loop without calling this function."]
    #[doc = ""]
    #[doc = " This function only affects currently queued events. If you want to make"]
    #[doc = " sure that all pending OS events are flushed, you can call SDL_PumpEvents()"]
    #[doc = " on the main thread immediately before the flush call."]
    #[doc = ""]
    #[doc = " \\param minType the low end of event type to be cleared, inclusive; see"]
    #[doc = "                SDL_EventType for details"]
    #[doc = " \\param maxType the high end of event type to be cleared, inclusive; see"]
    #[doc = "                SDL_EventType for details"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_FlushEvent"]
    pub fn SDL_FlushEvents(minType: Uint32, maxType: Uint32);
}
extern "C" {
    #[doc = " Poll for currently pending events."]
    #[doc = ""]
    #[doc = " If `event` is not NULL, the next event is removed from the queue and stored"]
    #[doc = " in the SDL_Event structure pointed to by `event`. The 1 returned refers to"]
    #[doc = " this event, immediately stored in the SDL Event structure -- not an event"]
    #[doc = " to follow."]
    #[doc = ""]
    #[doc = " If `event` is NULL, it simply returns 1 if there is an event in the queue,"]
    #[doc = " but will not remove it from the queue."]
    #[doc = ""]
    #[doc = " As this function may implicitly call SDL_PumpEvents(), you can only call"]
    #[doc = " this function in the thread that set the video mode."]
    #[doc = ""]
    #[doc = " SDL_PollEvent() is the favored way of receiving system events since it can"]
    #[doc = " be done from the main loop and does not suspend the main loop while waiting"]
    #[doc = " on an event to be posted."]
    #[doc = ""]
    #[doc = " The common practice is to fully process the event queue once every frame,"]
    #[doc = " usually as a first step before updating the game's state:"]
    #[doc = ""]
    #[doc = " ```c"]
    #[doc = " while (game_is_still_running) {"]
    #[doc = "     SDL_Event event;"]
    #[doc = "     while (SDL_PollEvent(&event)) {  // poll until all events are handled!"]
    #[doc = "         // decide what to do with this event."]
    #[doc = "     }"]
    #[doc = ""]
    #[doc = "     // update game state, draw the current frame"]
    #[doc = " }"]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " \\param event the SDL_Event structure to be filled with the next event from"]
    #[doc = "              the queue, or NULL"]
    #[doc = " \\returns 1 if there is a pending event or 0 if there are none available."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetEventFilter"]
    #[doc = " \\sa SDL_PeepEvents"]
    #[doc = " \\sa SDL_PushEvent"]
    #[doc = " \\sa SDL_SetEventFilter"]
    #[doc = " \\sa SDL_WaitEvent"]
    #[doc = " \\sa SDL_WaitEventTimeout"]
    pub fn SDL_PollEvent(event: *mut SDL_Event) -> libc::c_int;
}
extern "C" {
    #[doc = " Wait indefinitely for the next available event."]
    #[doc = ""]
    #[doc = " If `event` is not NULL, the next event is removed from the queue and stored"]
    #[doc = " in the SDL_Event structure pointed to by `event`."]
    #[doc = ""]
    #[doc = " As this function may implicitly call SDL_PumpEvents(), you can only call"]
    #[doc = " this function in the thread that initialized the video subsystem."]
    #[doc = ""]
    #[doc = " \\param event the SDL_Event structure to be filled in with the next event"]
    #[doc = "              from the queue, or NULL"]
    #[doc = " \\returns 1 on success or 0 if there was an error while waiting for events;"]
    #[doc = "          call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_PollEvent"]
    #[doc = " \\sa SDL_PumpEvents"]
    #[doc = " \\sa SDL_WaitEventTimeout"]
    pub fn SDL_WaitEvent(event: *mut SDL_Event) -> libc::c_int;
}
extern "C" {
    #[doc = " Wait until the specified timeout (in milliseconds) for the next available"]
    #[doc = " event."]
    #[doc = ""]
    #[doc = " If `event` is not NULL, the next event is removed from the queue and stored"]
    #[doc = " in the SDL_Event structure pointed to by `event`."]
    #[doc = ""]
    #[doc = " As this function may implicitly call SDL_PumpEvents(), you can only call"]
    #[doc = " this function in the thread that initialized the video subsystem."]
    #[doc = ""]
    #[doc = " \\param event the SDL_Event structure to be filled in with the next event"]
    #[doc = "              from the queue, or NULL"]
    #[doc = " \\param timeout the maximum number of milliseconds to wait for the next"]
    #[doc = "                available event"]
    #[doc = " \\returns 1 on success or 0 if there was an error while waiting for events;"]
    #[doc = "          call SDL_GetError() for more information. This also returns 0 if"]
    #[doc = "          the timeout elapsed without an event arriving."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_PollEvent"]
    #[doc = " \\sa SDL_PumpEvents"]
    #[doc = " \\sa SDL_WaitEvent"]
    pub fn SDL_WaitEventTimeout(event: *mut SDL_Event, timeout: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Add an event to the event queue."]
    #[doc = ""]
    #[doc = " The event queue can actually be used as a two way communication channel."]
    #[doc = " Not only can events be read from the queue, but the user can also push"]
    #[doc = " their own events onto it. `event` is a pointer to the event structure you"]
    #[doc = " wish to push onto the queue. The event is copied into the queue, and the"]
    #[doc = " caller may dispose of the memory pointed to after SDL_PushEvent() returns."]
    #[doc = ""]
    #[doc = " Note: Pushing device input events onto the queue doesn't modify the state"]
    #[doc = " of the device within SDL."]
    #[doc = ""]
    #[doc = " This function is thread-safe, and can be called from other threads safely."]
    #[doc = ""]
    #[doc = " Note: Events pushed onto the queue with SDL_PushEvent() get passed through"]
    #[doc = " the event filter but events added with SDL_PeepEvents() do not."]
    #[doc = ""]
    #[doc = " For pushing application-specific events, please use SDL_RegisterEvents() to"]
    #[doc = " get an event type that does not conflict with other code that also wants"]
    #[doc = " its own custom event types."]
    #[doc = ""]
    #[doc = " \\param event the SDL_Event to be added to the queue"]
    #[doc = " \\returns 1 on success, 0 if the event was filtered, or a negative error"]
    #[doc = "          code on failure; call SDL_GetError() for more information. A"]
    #[doc = "          common reason for error is the event queue being full."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_PeepEvents"]
    #[doc = " \\sa SDL_PollEvent"]
    #[doc = " \\sa SDL_RegisterEvents"]
    pub fn SDL_PushEvent(event: *mut SDL_Event) -> libc::c_int;
}
#[doc = " A function pointer used for callbacks that watch the event queue."]
#[doc = ""]
#[doc = " \\param userdata what was passed as `userdata` to SDL_SetEventFilter()"]
#[doc = "        or SDL_AddEventWatch, etc"]
#[doc = " \\param event the event that triggered the callback"]
#[doc = " \\returns 1 to permit event to be added to the queue, and 0 to disallow"]
#[doc = "          it. When used with SDL_AddEventWatch, the return value is ignored."]
#[doc = ""]
#[doc = " \\sa SDL_SetEventFilter"]
#[doc = " \\sa SDL_AddEventWatch"]
pub type SDL_EventFilter = ::core::option::Option<
    unsafe extern "C" fn(userdata: *mut libc::c_void, event: *mut SDL_Event) -> libc::c_int,
>;
extern "C" {
    #[doc = " Set up a filter to process all events before they change internal state and"]
    #[doc = " are posted to the internal event queue."]
    #[doc = ""]
    #[doc = " If the filter function returns 1 when called, then the event will be added"]
    #[doc = " to the internal queue. If it returns 0, then the event will be dropped from"]
    #[doc = " the queue, but the internal state will still be updated. This allows"]
    #[doc = " selective filtering of dynamically arriving events."]
    #[doc = ""]
    #[doc = " **WARNING**: Be very careful of what you do in the event filter function,"]
    #[doc = " as it may run in a different thread!"]
    #[doc = ""]
    #[doc = " On platforms that support it, if the quit event is generated by an"]
    #[doc = " interrupt signal (e.g. pressing Ctrl-C), it will be delivered to the"]
    #[doc = " application at the next event poll."]
    #[doc = ""]
    #[doc = " There is one caveat when dealing with the ::SDL_QuitEvent event type. The"]
    #[doc = " event filter is only called when the window manager desires to close the"]
    #[doc = " application window. If the event filter returns 1, then the window will be"]
    #[doc = " closed, otherwise the window will remain open if possible."]
    #[doc = ""]
    #[doc = " Note: Disabled events never make it to the event filter function; see"]
    #[doc = " SDL_EventState()."]
    #[doc = ""]
    #[doc = " Note: If you just want to inspect events without filtering, you should use"]
    #[doc = " SDL_AddEventWatch() instead."]
    #[doc = ""]
    #[doc = " Note: Events pushed onto the queue with SDL_PushEvent() get passed through"]
    #[doc = " the event filter, but events pushed onto the queue with SDL_PeepEvents() do"]
    #[doc = " not."]
    #[doc = ""]
    #[doc = " \\param filter An SDL_EventFilter function to call when an event happens"]
    #[doc = " \\param userdata a pointer that is passed to `filter`"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_AddEventWatch"]
    #[doc = " \\sa SDL_EventState"]
    #[doc = " \\sa SDL_GetEventFilter"]
    #[doc = " \\sa SDL_PeepEvents"]
    #[doc = " \\sa SDL_PushEvent"]
    pub fn SDL_SetEventFilter(filter: SDL_EventFilter, userdata: *mut libc::c_void);
}
extern "C" {
    #[doc = " Query the current event filter."]
    #[doc = ""]
    #[doc = " This function can be used to \"chain\" filters, by saving the existing filter"]
    #[doc = " before replacing it with a function that will call that saved filter."]
    #[doc = ""]
    #[doc = " \\param filter the current callback function will be stored here"]
    #[doc = " \\param userdata the pointer that is passed to the current event filter will"]
    #[doc = "                 be stored here"]
    #[doc = " \\returns SDL_TRUE on success or SDL_FALSE if there is no event filter set."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_SetEventFilter"]
    pub fn SDL_GetEventFilter(
        filter: *mut SDL_EventFilter,
        userdata: *mut *mut libc::c_void,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = " Add a callback to be triggered when an event is added to the event queue."]
    #[doc = ""]
    #[doc = " `filter` will be called when an event happens, and its return value is"]
    #[doc = " ignored."]
    #[doc = ""]
    #[doc = " **WARNING**: Be very careful of what you do in the event filter function,"]
    #[doc = " as it may run in a different thread!"]
    #[doc = ""]
    #[doc = " If the quit event is generated by a signal (e.g. SIGINT), it will bypass"]
    #[doc = " the internal queue and be delivered to the watch callback immediately, and"]
    #[doc = " arrive at the next event poll."]
    #[doc = ""]
    #[doc = " Note: the callback is called for events posted by the user through"]
    #[doc = " SDL_PushEvent(), but not for disabled events, nor for events by a filter"]
    #[doc = " callback set with SDL_SetEventFilter(), nor for events posted by the user"]
    #[doc = " through SDL_PeepEvents()."]
    #[doc = ""]
    #[doc = " \\param filter an SDL_EventFilter function to call when an event happens."]
    #[doc = " \\param userdata a pointer that is passed to `filter`"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_DelEventWatch"]
    #[doc = " \\sa SDL_SetEventFilter"]
    pub fn SDL_AddEventWatch(filter: SDL_EventFilter, userdata: *mut libc::c_void);
}
extern "C" {
    #[doc = " Remove an event watch callback added with SDL_AddEventWatch()."]
    #[doc = ""]
    #[doc = " This function takes the same input as SDL_AddEventWatch() to identify and"]
    #[doc = " delete the corresponding callback."]
    #[doc = ""]
    #[doc = " \\param filter the function originally passed to SDL_AddEventWatch()"]
    #[doc = " \\param userdata the pointer originally passed to SDL_AddEventWatch()"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_AddEventWatch"]
    pub fn SDL_DelEventWatch(filter: SDL_EventFilter, userdata: *mut libc::c_void);
}
extern "C" {
    #[doc = " Run a specific filter function on the current event queue, removing any"]
    #[doc = " events for which the filter returns 0."]
    #[doc = ""]
    #[doc = " See SDL_SetEventFilter() for more information. Unlike SDL_SetEventFilter(),"]
    #[doc = " this function does not change the filter permanently, it only uses the"]
    #[doc = " supplied filter until this function returns."]
    #[doc = ""]
    #[doc = " \\param filter the SDL_EventFilter function to call when an event happens"]
    #[doc = " \\param userdata a pointer that is passed to `filter`"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetEventFilter"]
    #[doc = " \\sa SDL_SetEventFilter"]
    pub fn SDL_FilterEvents(filter: SDL_EventFilter, userdata: *mut libc::c_void);
}
extern "C" {
    #[doc = " Set the state of processing events by type."]
    #[doc = ""]
    #[doc = " `state` may be any of the following:"]
    #[doc = ""]
    #[doc = " - `SDL_QUERY`: returns the current processing state of the specified event"]
    #[doc = " - `SDL_IGNORE` (aka `SDL_DISABLE`): the event will automatically be dropped"]
    #[doc = "   from the event queue and will not be filtered"]
    #[doc = " - `SDL_ENABLE`: the event will be processed normally"]
    #[doc = ""]
    #[doc = " \\param type the type of event; see SDL_EventType for details"]
    #[doc = " \\param state how to process the event"]
    #[doc = " \\returns `SDL_DISABLE` or `SDL_ENABLE`, representing the processing state"]
    #[doc = "          of the event before this function makes any changes to it."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetEventState"]
    pub fn SDL_EventState(type_: Uint32, state: libc::c_int) -> Uint8;
}
extern "C" {
    #[doc = " Allocate a set of user-defined events, and return the beginning event"]
    #[doc = " number for that set of events."]
    #[doc = ""]
    #[doc = " Calling this function with `numevents` <= 0 is an error and will return"]
    #[doc = " (Uint32)-1."]
    #[doc = ""]
    #[doc = " Note, (Uint32)-1 means the maximum unsigned 32-bit integer value (or"]
    #[doc = " 0xFFFFFFFF), but is clearer to write."]
    #[doc = ""]
    #[doc = " \\param numevents the number of events to be allocated"]
    #[doc = " \\returns the beginning event number, or (Uint32)-1 if there are not enough"]
    #[doc = "          user-defined events left."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_PushEvent"]
    pub fn SDL_RegisterEvents(numevents: libc::c_int) -> Uint32;
}
extern "C" {
    #[doc = " Get the directory where the application was run from."]
    #[doc = ""]
    #[doc = " This is not necessarily a fast call, so you should call this once near"]
    #[doc = " startup and save the string if you need it."]
    #[doc = ""]
    #[doc = " **Mac OS X and iOS Specific Functionality**: If the application is in a"]
    #[doc = " \".app\" bundle, this function returns the Resource directory (e.g."]
    #[doc = " MyApp.app/Contents/Resources/). This behaviour can be overridden by adding"]
    #[doc = " a property to the Info.plist file. Adding a string key with the name"]
    #[doc = " SDL_FILESYSTEM_BASE_DIR_TYPE with a supported value will change the"]
    #[doc = " behaviour."]
    #[doc = ""]
    #[doc = " Supported values for the SDL_FILESYSTEM_BASE_DIR_TYPE property (Given an"]
    #[doc = " application in /Applications/SDLApp/MyApp.app):"]
    #[doc = ""]
    #[doc = " - `resource`: bundle resource directory (the default). For example:"]
    #[doc = "   `/Applications/SDLApp/MyApp.app/Contents/Resources`"]
    #[doc = " - `bundle`: the Bundle directory. For example:"]
    #[doc = "   `/Applications/SDLApp/MyApp.app/`"]
    #[doc = " - `parent`: the containing directory of the bundle. For example:"]
    #[doc = "   `/Applications/SDLApp/`"]
    #[doc = ""]
    #[doc = " The returned path is guaranteed to end with a path separator ('\\' on"]
    #[doc = " Windows, '/' on most other platforms)."]
    #[doc = ""]
    #[doc = " The pointer returned is owned by the caller. Please call SDL_free() on the"]
    #[doc = " pointer when done with it."]
    #[doc = ""]
    #[doc = " \\returns an absolute path in UTF-8 encoding to the application data"]
    #[doc = "          directory. NULL will be returned on error or when the platform"]
    #[doc = "          doesn't implement this functionality, call SDL_GetError() for more"]
    #[doc = "          information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.1."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetPrefPath"]
    pub fn SDL_GetBasePath() -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Get the user-and-app-specific path where files can be written."]
    #[doc = ""]
    #[doc = " Get the \"pref dir\". This is meant to be where users can write personal"]
    #[doc = " files (preferences and save games, etc) that are specific to your"]
    #[doc = " application. This directory is unique per user, per application."]
    #[doc = ""]
    #[doc = " This function will decide the appropriate location in the native"]
    #[doc = " filesystem, create the directory if necessary, and return a string of the"]
    #[doc = " absolute path to the directory in UTF-8 encoding."]
    #[doc = ""]
    #[doc = " On Windows, the string might look like:"]
    #[doc = ""]
    #[doc = " `C:\\\\Users\\\\bob\\\\AppData\\\\Roaming\\\\My Company\\\\My Program Name\\\\`"]
    #[doc = ""]
    #[doc = " On Linux, the string might look like\""]
    #[doc = ""]
    #[doc = " `/home/bob/.local/share/My Program Name/`"]
    #[doc = ""]
    #[doc = " On Mac OS X, the string might look like:"]
    #[doc = ""]
    #[doc = " `/Users/bob/Library/Application Support/My Program Name/`"]
    #[doc = ""]
    #[doc = " You should assume the path returned by this function is the only safe place"]
    #[doc = " to write files (and that SDL_GetBasePath(), while it might be writable, or"]
    #[doc = " even the parent of the returned path, isn't where you should be writing"]
    #[doc = " things)."]
    #[doc = ""]
    #[doc = " Both the org and app strings may become part of a directory name, so please"]
    #[doc = " follow these rules:"]
    #[doc = ""]
    #[doc = " - Try to use the same org string (_including case-sensitivity_) for all"]
    #[doc = "   your applications that use this function."]
    #[doc = " - Always use a unique app string for each one, and make sure it never"]
    #[doc = "   changes for an app once you've decided on it."]
    #[doc = " - Unicode characters are legal, as long as it's UTF-8 encoded, but..."]
    #[doc = " - ...only use letters, numbers, and spaces. Avoid punctuation like \"Game"]
    #[doc = "   Name 2: Bad Guy's Revenge!\" ... \"Game Name 2\" is sufficient."]
    #[doc = ""]
    #[doc = " The returned path is guaranteed to end with a path separator ('\\' on"]
    #[doc = " Windows, '/' on most other platforms)."]
    #[doc = ""]
    #[doc = " The pointer returned is owned by the caller. Please call SDL_free() on the"]
    #[doc = " pointer when done with it."]
    #[doc = ""]
    #[doc = " \\param org the name of your organization"]
    #[doc = " \\param app the name of your application"]
    #[doc = " \\returns a UTF-8 string of the user directory in platform-dependent"]
    #[doc = "          notation. NULL if there's a problem (creating directory failed,"]
    #[doc = "          etc.)."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.1."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetBasePath"]
    pub fn SDL_GetPrefPath(org: *const libc::c_char, app: *const libc::c_char)
        -> *mut libc::c_char;
}
#[doc = "  \\typedef SDL_Haptic"]
#[doc = ""]
#[doc = "  \\brief The haptic structure used to identify an SDL haptic."]
#[doc = ""]
#[doc = "  \\sa SDL_HapticOpen"]
#[doc = "  \\sa SDL_HapticOpenFromJoystick"]
#[doc = "  \\sa SDL_HapticClose"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SDL_Haptic {
    _unused: [u8; 0],
}
pub type SDL_Haptic = _SDL_Haptic;
#[doc = "  \\brief Structure that represents a haptic direction."]
#[doc = ""]
#[doc = "  This is the direction where the force comes from,"]
#[doc = "  instead of the direction in which the force is exerted."]
#[doc = ""]
#[doc = "  Directions can be specified by:"]
#[doc = "   - ::SDL_HAPTIC_POLAR : Specified by polar coordinates."]
#[doc = "   - ::SDL_HAPTIC_CARTESIAN : Specified by cartesian coordinates."]
#[doc = "   - ::SDL_HAPTIC_SPHERICAL : Specified by spherical coordinates."]
#[doc = ""]
#[doc = "  Cardinal directions of the haptic device are relative to the positioning"]
#[doc = "  of the device.  North is considered to be away from the user."]
#[doc = ""]
#[doc = "  The following diagram represents the cardinal directions:"]
#[doc = "  \\verbatim"]
#[doc = ".--."]
#[doc = "|__| .-------."]
#[doc = "|=.| |.-----.|"]
#[doc = "|--| ||     ||"]
#[doc = "|  | |'-----'|"]
#[doc = "|__|~')_____('"]
#[doc = "[ COMPUTER ]"]
#[doc = ""]
#[doc = ""]
#[doc = "North (0,-1)"]
#[doc = "^"]
#[doc = "|"]
#[doc = "|"]
#[doc = "(-1,0)  West <----[ HAPTIC ]----> East (1,0)"]
#[doc = "|"]
#[doc = "|"]
#[doc = "v"]
#[doc = "South (0,1)"]
#[doc = ""]
#[doc = ""]
#[doc = "[ USER ]"]
#[doc = "\\|||/"]
#[doc = "(o o)"]
#[doc = "---ooO-(_)-Ooo---"]
#[doc = "\\endverbatim"]
#[doc = ""]
#[doc = "  If type is ::SDL_HAPTIC_POLAR, direction is encoded by hundredths of a"]
#[doc = "  degree starting north and turning clockwise.  ::SDL_HAPTIC_POLAR only uses"]
#[doc = "  the first \\c dir parameter.  The cardinal directions would be:"]
#[doc = "   - North: 0 (0 degrees)"]
#[doc = "   - East: 9000 (90 degrees)"]
#[doc = "   - South: 18000 (180 degrees)"]
#[doc = "   - West: 27000 (270 degrees)"]
#[doc = ""]
#[doc = "  If type is ::SDL_HAPTIC_CARTESIAN, direction is encoded by three positions"]
#[doc = "  (X axis, Y axis and Z axis (with 3 axes)).  ::SDL_HAPTIC_CARTESIAN uses"]
#[doc = "  the first three \\c dir parameters.  The cardinal directions would be:"]
#[doc = "   - North:  0,-1, 0"]
#[doc = "   - East:   1, 0, 0"]
#[doc = "   - South:  0, 1, 0"]
#[doc = "   - West:  -1, 0, 0"]
#[doc = ""]
#[doc = "  The Z axis represents the height of the effect if supported, otherwise"]
#[doc = "  it's unused.  In cartesian encoding (1, 2) would be the same as (2, 4), you"]
#[doc = "  can use any multiple you want, only the direction matters."]
#[doc = ""]
#[doc = "  If type is ::SDL_HAPTIC_SPHERICAL, direction is encoded by two rotations."]
#[doc = "  The first two \\c dir parameters are used.  The \\c dir parameters are as"]
#[doc = "  follows (all values are in hundredths of degrees):"]
#[doc = "   - Degrees from (1, 0) rotated towards (0, 1)."]
#[doc = "   - Degrees towards (0, 0, 1) (device needs at least 3 axes)."]
#[doc = ""]
#[doc = ""]
#[doc = "  Example of force coming from the south with all encodings (force coming"]
#[doc = "  from the south means the user will have to pull the stick to counteract):"]
#[doc = "  \\code"]
#[doc = "  SDL_HapticDirection direction;"]
#[doc = ""]
#[doc = "  // Cartesian directions"]
#[doc = "  direction.type = SDL_HAPTIC_CARTESIAN; // Using cartesian direction encoding."]
#[doc = "  direction.dir[0] = 0; // X position"]
#[doc = "  direction.dir[1] = 1; // Y position"]
#[doc = "  // Assuming the device has 2 axes, we don't need to specify third parameter."]
#[doc = ""]
#[doc = "  // Polar directions"]
#[doc = "  direction.type = SDL_HAPTIC_POLAR; // We'll be using polar direction encoding."]
#[doc = "  direction.dir[0] = 18000; // Polar only uses first parameter"]
#[doc = ""]
#[doc = "  // Spherical coordinates"]
#[doc = "  direction.type = SDL_HAPTIC_SPHERICAL; // Spherical encoding"]
#[doc = "  direction.dir[0] = 9000; // Since we only have two axes we don't need more parameters."]
#[doc = "  \\endcode"]
#[doc = ""]
#[doc = "  \\sa SDL_HAPTIC_POLAR"]
#[doc = "  \\sa SDL_HAPTIC_CARTESIAN"]
#[doc = "  \\sa SDL_HAPTIC_SPHERICAL"]
#[doc = "  \\sa SDL_HAPTIC_STEERING_AXIS"]
#[doc = "  \\sa SDL_HapticEffect"]
#[doc = "  \\sa SDL_HapticNumAxes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_HapticDirection {
    #[doc = "< The type of encoding."]
    pub type_: Uint8,
    #[doc = "< The encoded direction."]
    pub dir: [Sint32; 3usize],
}
#[test]
fn bindgen_test_layout_SDL_HapticDirection() {
    assert_eq!(
        ::core::mem::size_of::<SDL_HapticDirection>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_HapticDirection))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_HapticDirection>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticDirection))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticDirection>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticDirection),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticDirection>())).dir as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticDirection),
            "::",
            stringify!(dir)
        )
    );
}
#[doc = "  \\brief A structure containing a template for a Constant effect."]
#[doc = ""]
#[doc = "  This struct is exclusively for the ::SDL_HAPTIC_CONSTANT effect."]
#[doc = ""]
#[doc = "  A constant effect applies a constant force in the specified direction"]
#[doc = "  to the joystick."]
#[doc = ""]
#[doc = "  \\sa SDL_HAPTIC_CONSTANT"]
#[doc = "  \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_HapticConstant {
    #[doc = "< ::SDL_HAPTIC_CONSTANT"]
    pub type_: Uint16,
    #[doc = "< Direction of the effect."]
    pub direction: SDL_HapticDirection,
    #[doc = "< Duration of the effect."]
    pub length: Uint32,
    #[doc = "< Delay before starting the effect."]
    pub delay: Uint16,
    #[doc = "< Button that triggers the effect."]
    pub button: Uint16,
    #[doc = "< How soon it can be triggered again after button."]
    pub interval: Uint16,
    #[doc = "< Strength of the constant effect."]
    pub level: Sint16,
    #[doc = "< Duration of the attack."]
    pub attack_length: Uint16,
    #[doc = "< Level at the start of the attack."]
    pub attack_level: Uint16,
    #[doc = "< Duration of the fade."]
    pub fade_length: Uint16,
    #[doc = "< Level at the end of the fade."]
    pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticConstant() {
    assert_eq!(
        ::core::mem::size_of::<SDL_HapticConstant>(),
        40usize,
        concat!("Size of: ", stringify!(SDL_HapticConstant))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_HapticConstant>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticConstant))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).direction as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).length as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).delay as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).button as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).interval as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).level as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_HapticConstant>())).attack_length as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(attack_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_HapticConstant>())).attack_level as *const _ as usize
        },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(attack_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).fade_length as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(fade_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticConstant>())).fade_level as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(fade_level)
        )
    );
}
#[doc = "  \\brief A structure containing a template for a Periodic effect."]
#[doc = ""]
#[doc = "  The struct handles the following effects:"]
#[doc = "   - ::SDL_HAPTIC_SINE"]
#[doc = "   - ::SDL_HAPTIC_LEFTRIGHT"]
#[doc = "   - ::SDL_HAPTIC_TRIANGLE"]
#[doc = "   - ::SDL_HAPTIC_SAWTOOTHUP"]
#[doc = "   - ::SDL_HAPTIC_SAWTOOTHDOWN"]
#[doc = ""]
#[doc = "  A periodic effect consists in a wave-shaped effect that repeats itself"]
#[doc = "  over time.  The type determines the shape of the wave and the parameters"]
#[doc = "  determine the dimensions of the wave."]
#[doc = ""]
#[doc = "  Phase is given by hundredth of a degree meaning that giving the phase a value"]
#[doc = "  of 9000 will displace it 25% of its period.  Here are sample values:"]
#[doc = "   -     0: No phase displacement."]
#[doc = "   -  9000: Displaced 25% of its period."]
#[doc = "   - 18000: Displaced 50% of its period."]
#[doc = "   - 27000: Displaced 75% of its period."]
#[doc = "   - 36000: Displaced 100% of its period, same as 0, but 0 is preferred."]
#[doc = ""]
#[doc = "  Examples:"]
#[doc = "  \\verbatim"]
#[doc = "SDL_HAPTIC_SINE"]
#[doc = "__      __      __      __"]
#[doc = ""]
#[doc = "SDL_HAPTIC_SQUARE"]
#[doc = "__    __    __    __    __"]
#[doc = "|  |  |  |  |  |  |  |  |  |"]
#[doc = "|  |__|  |__|  |__|  |__|  |"]
#[doc = ""]
#[doc = "SDL_HAPTIC_TRIANGLE"]
#[doc = ""]
#[doc = "SDL_HAPTIC_SAWTOOTHUP"]
#[doc = ""]
#[doc = "SDL_HAPTIC_SAWTOOTHDOWN"]
#[doc = "\\  |\\  |\\  |\\  |\\  |\\  |\\  |"]
#[doc = "\\ | \\ | \\ | \\ | \\ | \\ | \\ |"]
#[doc = "\\|  \\|  \\|  \\|  \\|  \\|  \\|"]
#[doc = "\\endverbatim"]
#[doc = ""]
#[doc = "  \\sa SDL_HAPTIC_SINE"]
#[doc = "  \\sa SDL_HAPTIC_LEFTRIGHT"]
#[doc = "  \\sa SDL_HAPTIC_TRIANGLE"]
#[doc = "  \\sa SDL_HAPTIC_SAWTOOTHUP"]
#[doc = "  \\sa SDL_HAPTIC_SAWTOOTHDOWN"]
#[doc = "  \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_HapticPeriodic {
    #[doc = "< ::SDL_HAPTIC_SINE, ::SDL_HAPTIC_LEFTRIGHT,"]
    #[doc = "::SDL_HAPTIC_TRIANGLE, ::SDL_HAPTIC_SAWTOOTHUP or"]
    #[doc = "::SDL_HAPTIC_SAWTOOTHDOWN"]
    pub type_: Uint16,
    #[doc = "< Direction of the effect."]
    pub direction: SDL_HapticDirection,
    #[doc = "< Duration of the effect."]
    pub length: Uint32,
    #[doc = "< Delay before starting the effect."]
    pub delay: Uint16,
    #[doc = "< Button that triggers the effect."]
    pub button: Uint16,
    #[doc = "< How soon it can be triggered again after button."]
    pub interval: Uint16,
    #[doc = "< Period of the wave."]
    pub period: Uint16,
    #[doc = "< Peak value; if negative, equivalent to 180 degrees extra phase shift."]
    pub magnitude: Sint16,
    #[doc = "< Mean value of the wave."]
    pub offset: Sint16,
    #[doc = "< Positive phase shift given by hundredth of a degree."]
    pub phase: Uint16,
    #[doc = "< Duration of the attack."]
    pub attack_length: Uint16,
    #[doc = "< Level at the start of the attack."]
    pub attack_level: Uint16,
    #[doc = "< Duration of the fade."]
    pub fade_length: Uint16,
    #[doc = "< Level at the end of the fade."]
    pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticPeriodic() {
    assert_eq!(
        ::core::mem::size_of::<SDL_HapticPeriodic>(),
        48usize,
        concat!("Size of: ", stringify!(SDL_HapticPeriodic))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_HapticPeriodic>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticPeriodic))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).direction as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).length as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).delay as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).button as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).interval as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).period as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).magnitude as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(magnitude)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).offset as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).phase as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(phase)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_HapticPeriodic>())).attack_length as *const _ as usize
        },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(attack_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_HapticPeriodic>())).attack_level as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(attack_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).fade_length as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(fade_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticPeriodic>())).fade_level as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(fade_level)
        )
    );
}
#[doc = "  \\brief A structure containing a template for a Condition effect."]
#[doc = ""]
#[doc = "  The struct handles the following effects:"]
#[doc = "   - ::SDL_HAPTIC_SPRING: Effect based on axes position."]
#[doc = "   - ::SDL_HAPTIC_DAMPER: Effect based on axes velocity."]
#[doc = "   - ::SDL_HAPTIC_INERTIA: Effect based on axes acceleration."]
#[doc = "   - ::SDL_HAPTIC_FRICTION: Effect based on axes movement."]
#[doc = ""]
#[doc = "  Direction is handled by condition internals instead of a direction member."]
#[doc = "  The condition effect specific members have three parameters.  The first"]
#[doc = "  refers to the X axis, the second refers to the Y axis and the third"]
#[doc = "  refers to the Z axis.  The right terms refer to the positive side of the"]
#[doc = "  axis and the left terms refer to the negative side of the axis.  Please"]
#[doc = "  refer to the ::SDL_HapticDirection diagram for which side is positive and"]
#[doc = "  which is negative."]
#[doc = ""]
#[doc = "  \\sa SDL_HapticDirection"]
#[doc = "  \\sa SDL_HAPTIC_SPRING"]
#[doc = "  \\sa SDL_HAPTIC_DAMPER"]
#[doc = "  \\sa SDL_HAPTIC_INERTIA"]
#[doc = "  \\sa SDL_HAPTIC_FRICTION"]
#[doc = "  \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_HapticCondition {
    #[doc = "< ::SDL_HAPTIC_SPRING, ::SDL_HAPTIC_DAMPER,"]
    #[doc = "::SDL_HAPTIC_INERTIA or ::SDL_HAPTIC_FRICTION"]
    pub type_: Uint16,
    #[doc = "< Direction of the effect - Not used ATM."]
    pub direction: SDL_HapticDirection,
    #[doc = "< Duration of the effect."]
    pub length: Uint32,
    #[doc = "< Delay before starting the effect."]
    pub delay: Uint16,
    #[doc = "< Button that triggers the effect."]
    pub button: Uint16,
    #[doc = "< How soon it can be triggered again after button."]
    pub interval: Uint16,
    #[doc = "< Level when joystick is to the positive side; max 0xFFFF."]
    pub right_sat: [Uint16; 3usize],
    #[doc = "< Level when joystick is to the negative side; max 0xFFFF."]
    pub left_sat: [Uint16; 3usize],
    #[doc = "< How fast to increase the force towards the positive side."]
    pub right_coeff: [Sint16; 3usize],
    #[doc = "< How fast to increase the force towards the negative side."]
    pub left_coeff: [Sint16; 3usize],
    #[doc = "< Size of the dead zone; max 0xFFFF: whole axis-range when 0-centered."]
    pub deadband: [Uint16; 3usize],
    #[doc = "< Position of the dead zone."]
    pub center: [Sint16; 3usize],
}
#[test]
fn bindgen_test_layout_SDL_HapticCondition() {
    assert_eq!(
        ::core::mem::size_of::<SDL_HapticCondition>(),
        68usize,
        concat!("Size of: ", stringify!(SDL_HapticCondition))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_HapticCondition>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticCondition))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).direction as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).length as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).delay as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).button as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).interval as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).right_sat as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(right_sat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).left_sat as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(left_sat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_HapticCondition>())).right_coeff as *const _ as usize
        },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(right_coeff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).left_coeff as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(left_coeff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).deadband as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(deadband)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticCondition>())).center as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(center)
        )
    );
}
#[doc = "  \\brief A structure containing a template for a Ramp effect."]
#[doc = ""]
#[doc = "  This struct is exclusively for the ::SDL_HAPTIC_RAMP effect."]
#[doc = ""]
#[doc = "  The ramp effect starts at start strength and ends at end strength."]
#[doc = "  It augments in linear fashion.  If you use attack and fade with a ramp"]
#[doc = "  the effects get added to the ramp effect making the effect become"]
#[doc = "  quadratic instead of linear."]
#[doc = ""]
#[doc = "  \\sa SDL_HAPTIC_RAMP"]
#[doc = "  \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_HapticRamp {
    #[doc = "< ::SDL_HAPTIC_RAMP"]
    pub type_: Uint16,
    #[doc = "< Direction of the effect."]
    pub direction: SDL_HapticDirection,
    #[doc = "< Duration of the effect."]
    pub length: Uint32,
    #[doc = "< Delay before starting the effect."]
    pub delay: Uint16,
    #[doc = "< Button that triggers the effect."]
    pub button: Uint16,
    #[doc = "< How soon it can be triggered again after button."]
    pub interval: Uint16,
    #[doc = "< Beginning strength level."]
    pub start: Sint16,
    #[doc = "< Ending strength level."]
    pub end: Sint16,
    #[doc = "< Duration of the attack."]
    pub attack_length: Uint16,
    #[doc = "< Level at the start of the attack."]
    pub attack_level: Uint16,
    #[doc = "< Duration of the fade."]
    pub fade_length: Uint16,
    #[doc = "< Level at the end of the fade."]
    pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticRamp() {
    assert_eq!(
        ::core::mem::size_of::<SDL_HapticRamp>(),
        44usize,
        concat!("Size of: ", stringify!(SDL_HapticRamp))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_HapticRamp>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticRamp))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).direction as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).length as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).delay as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).button as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).interval as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).start as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).end as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).attack_length as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(attack_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).attack_level as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(attack_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).fade_length as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(fade_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticRamp>())).fade_level as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(fade_level)
        )
    );
}
#[doc = " \\brief A structure containing a template for a Left/Right effect."]
#[doc = ""]
#[doc = " This struct is exclusively for the ::SDL_HAPTIC_LEFTRIGHT effect."]
#[doc = ""]
#[doc = " The Left/Right effect is used to explicitly control the large and small"]
#[doc = " motors, commonly found in modern game controllers. The small (right) motor"]
#[doc = " is high frequency, and the large (left) motor is low frequency."]
#[doc = ""]
#[doc = " \\sa SDL_HAPTIC_LEFTRIGHT"]
#[doc = " \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_HapticLeftRight {
    #[doc = "< ::SDL_HAPTIC_LEFTRIGHT"]
    pub type_: Uint16,
    #[doc = "< Duration of the effect in milliseconds."]
    pub length: Uint32,
    #[doc = "< Control of the large controller motor."]
    pub large_magnitude: Uint16,
    #[doc = "< Control of the small controller motor."]
    pub small_magnitude: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticLeftRight() {
    assert_eq!(
        ::core::mem::size_of::<SDL_HapticLeftRight>(),
        12usize,
        concat!("Size of: ", stringify!(SDL_HapticLeftRight))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_HapticLeftRight>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticLeftRight))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticLeftRight>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticLeftRight),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticLeftRight>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticLeftRight),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_HapticLeftRight>())).large_magnitude as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticLeftRight),
            "::",
            stringify!(large_magnitude)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_HapticLeftRight>())).small_magnitude as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticLeftRight),
            "::",
            stringify!(small_magnitude)
        )
    );
}
#[doc = "  \\brief A structure containing a template for the ::SDL_HAPTIC_CUSTOM effect."]
#[doc = ""]
#[doc = "  This struct is exclusively for the ::SDL_HAPTIC_CUSTOM effect."]
#[doc = ""]
#[doc = "  A custom force feedback effect is much like a periodic effect, where the"]
#[doc = "  application can define its exact shape.  You will have to allocate the"]
#[doc = "  data yourself.  Data should consist of channels * samples Uint16 samples."]
#[doc = ""]
#[doc = "  If channels is one, the effect is rotated using the defined direction."]
#[doc = "  Otherwise it uses the samples in data for the different axes."]
#[doc = ""]
#[doc = "  \\sa SDL_HAPTIC_CUSTOM"]
#[doc = "  \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_HapticCustom {
    #[doc = "< ::SDL_HAPTIC_CUSTOM"]
    pub type_: Uint16,
    #[doc = "< Direction of the effect."]
    pub direction: SDL_HapticDirection,
    #[doc = "< Duration of the effect."]
    pub length: Uint32,
    #[doc = "< Delay before starting the effect."]
    pub delay: Uint16,
    #[doc = "< Button that triggers the effect."]
    pub button: Uint16,
    #[doc = "< How soon it can be triggered again after button."]
    pub interval: Uint16,
    #[doc = "< Axes to use, minimum of one."]
    pub channels: Uint8,
    #[doc = "< Sample periods."]
    pub period: Uint16,
    #[doc = "< Amount of samples."]
    pub samples: Uint16,
    #[doc = "< Should contain channels*samples items."]
    pub data: *mut Uint16,
    #[doc = "< Duration of the attack."]
    pub attack_length: Uint16,
    #[doc = "< Level at the start of the attack."]
    pub attack_level: Uint16,
    #[doc = "< Duration of the fade."]
    pub fade_length: Uint16,
    #[doc = "< Level at the end of the fade."]
    pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticCustom() {
    assert_eq!(
        ::core::mem::size_of::<SDL_HapticCustom>(),
        56usize,
        concat!("Size of: ", stringify!(SDL_HapticCustom))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_HapticCustom>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_HapticCustom))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).direction as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).length as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).delay as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).button as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).interval as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).channels as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).period as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).samples as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).data as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).attack_length as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(attack_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).attack_level as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(attack_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).fade_length as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(fade_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticCustom>())).fade_level as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(fade_level)
        )
    );
}
#[doc = "  \\brief The generic template for any haptic effect."]
#[doc = ""]
#[doc = "  All values max at 32767 (0x7FFF).  Signed values also can be negative."]
#[doc = "  Time values unless specified otherwise are in milliseconds."]
#[doc = ""]
#[doc = "  You can also pass ::SDL_HAPTIC_INFINITY to length instead of a 0-32767"]
#[doc = "  value.  Neither delay, interval, attack_length nor fade_length support"]
#[doc = "  ::SDL_HAPTIC_INFINITY.  Fade will also not be used since effect never ends."]
#[doc = ""]
#[doc = "  Additionally, the ::SDL_HAPTIC_RAMP effect does not support a duration of"]
#[doc = "  ::SDL_HAPTIC_INFINITY."]
#[doc = ""]
#[doc = "  Button triggers may not be supported on all devices, it is advised to not"]
#[doc = "  use them if possible.  Buttons start at index 1 instead of index 0 like"]
#[doc = "  the joystick."]
#[doc = ""]
#[doc = "  If both attack_length and fade_level are 0, the envelope is not used,"]
#[doc = "  otherwise both values are used."]
#[doc = ""]
#[doc = "  Common parts:"]
#[doc = "  \\code"]
#[doc = "  // Replay - All effects have this"]
#[doc = "  Uint32 length;        // Duration of effect (ms)."]
#[doc = "  Uint16 delay;         // Delay before starting effect."]
#[doc = ""]
#[doc = "  // Trigger - All effects have this"]
#[doc = "  Uint16 button;        // Button that triggers effect."]
#[doc = "  Uint16 interval;      // How soon before effect can be triggered again."]
#[doc = ""]
#[doc = "  // Envelope - All effects except condition effects have this"]
#[doc = "  Uint16 attack_length; // Duration of the attack (ms)."]
#[doc = "  Uint16 attack_level;  // Level at the start of the attack."]
#[doc = "  Uint16 fade_length;   // Duration of the fade out (ms)."]
#[doc = "  Uint16 fade_level;    // Level at the end of the fade."]
#[doc = "  \\endcode"]
#[doc = ""]
#[doc = ""]
#[doc = "  Here we have an example of a constant effect evolution in time:"]
#[doc = "  \\verbatim"]
#[doc = "Strength"]
#[doc = "^"]
#[doc = "|"]
#[doc = "|    effect level -->  _________________"]
#[doc = "|                     /                 \\"]
#[doc = "|                    /                   \\"]
#[doc = "|                   /                     \\"]
#[doc = "|                  /                       \\"]
#[doc = "| attack_level --> |                        \\"]
#[doc = "|                  |                        |  <---  fade_level"]
#[doc = "|"]
#[doc = "+--------------------------------------------------> Time"]
#[doc = "[--]                 [---]"]
#[doc = "attack_length        fade_length"]
#[doc = ""]
#[doc = "[------------------][-----------------------]"]
#[doc = "delay               length"]
#[doc = "\\endverbatim"]
#[doc = ""]
#[doc = "  Note either the attack_level or the fade_level may be above the actual"]
#[doc = "  effect level."]
#[doc = ""]
#[doc = "  \\sa SDL_HapticConstant"]
#[doc = "  \\sa SDL_HapticPeriodic"]
#[doc = "  \\sa SDL_HapticCondition"]
#[doc = "  \\sa SDL_HapticRamp"]
#[doc = "  \\sa SDL_HapticLeftRight"]
#[doc = "  \\sa SDL_HapticCustom"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_HapticEffect {
    #[doc = "< Effect type."]
    pub type_: Uint16,
    #[doc = "< Constant effect."]
    pub constant: SDL_HapticConstant,
    #[doc = "< Periodic effect."]
    pub periodic: SDL_HapticPeriodic,
    #[doc = "< Condition effect."]
    pub condition: SDL_HapticCondition,
    #[doc = "< Ramp effect."]
    pub ramp: SDL_HapticRamp,
    #[doc = "< Left/Right effect."]
    pub leftright: SDL_HapticLeftRight,
    #[doc = "< Custom effect."]
    pub custom: SDL_HapticCustom,
    _bindgen_union_align: [u64; 9usize],
}
#[test]
fn bindgen_test_layout_SDL_HapticEffect() {
    assert_eq!(
        ::core::mem::size_of::<SDL_HapticEffect>(),
        72usize,
        concat!("Size of: ", stringify!(SDL_HapticEffect))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_HapticEffect>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_HapticEffect))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticEffect>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticEffect),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticEffect>())).constant as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticEffect),
            "::",
            stringify!(constant)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticEffect>())).periodic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticEffect),
            "::",
            stringify!(periodic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticEffect>())).condition as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticEffect),
            "::",
            stringify!(condition)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticEffect>())).ramp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticEffect),
            "::",
            stringify!(ramp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticEffect>())).leftright as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticEffect),
            "::",
            stringify!(leftright)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_HapticEffect>())).custom as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticEffect),
            "::",
            stringify!(custom)
        )
    );
}
extern "C" {
    #[doc = " Count the number of haptic devices attached to the system."]
    #[doc = ""]
    #[doc = " \\returns the number of haptic devices detected on the system or a negative"]
    #[doc = "          error code on failure; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HapticName"]
    pub fn SDL_NumHaptics() -> libc::c_int;
}
extern "C" {
    #[doc = " Get the implementation dependent name of a haptic device."]
    #[doc = ""]
    #[doc = " This can be called before any joysticks are opened. If no name can be"]
    #[doc = " found, this function returns NULL."]
    #[doc = ""]
    #[doc = " \\param device_index index of the device to query."]
    #[doc = " \\returns the name of the device or NULL on failure; call SDL_GetError() for"]
    #[doc = "          more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_NumHaptics"]
    pub fn SDL_HapticName(device_index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Open a haptic device for use."]
    #[doc = ""]
    #[doc = " The index passed as an argument refers to the N'th haptic device on this"]
    #[doc = " system."]
    #[doc = ""]
    #[doc = " When opening a haptic device, its gain will be set to maximum and"]
    #[doc = " autocenter will be disabled. To modify these values use SDL_HapticSetGain()"]
    #[doc = " and SDL_HapticSetAutocenter()."]
    #[doc = ""]
    #[doc = " \\param device_index index of the device to open"]
    #[doc = " \\returns the device identifier or NULL on failure; call SDL_GetError() for"]
    #[doc = "          more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HapticClose"]
    #[doc = " \\sa SDL_HapticIndex"]
    #[doc = " \\sa SDL_HapticOpenFromJoystick"]
    #[doc = " \\sa SDL_HapticOpenFromMouse"]
    #[doc = " \\sa SDL_HapticPause"]
    #[doc = " \\sa SDL_HapticSetAutocenter"]
    #[doc = " \\sa SDL_HapticSetGain"]
    #[doc = " \\sa SDL_HapticStopAll"]
    pub fn SDL_HapticOpen(device_index: libc::c_int) -> *mut SDL_Haptic;
}
extern "C" {
    #[doc = " Check if the haptic device at the designated index has been opened."]
    #[doc = ""]
    #[doc = " \\param device_index the index of the device to query"]
    #[doc = " \\returns 1 if it has been opened, 0 if it hasn't or on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HapticIndex"]
    #[doc = " \\sa SDL_HapticOpen"]
    pub fn SDL_HapticOpened(device_index: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the index of a haptic device."]
    #[doc = ""]
    #[doc = " \\param haptic the SDL_Haptic device to query"]
    #[doc = " \\returns the index of the specified haptic device or a negative error code"]
    #[doc = "          on failure; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HapticOpen"]
    #[doc = " \\sa SDL_HapticOpened"]
    pub fn SDL_HapticIndex(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
    #[doc = " Query whether or not the current mouse has haptic capabilities."]
    #[doc = ""]
    #[doc = " \\returns SDL_TRUE if the mouse is haptic or SDL_FALSE if it isn't."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HapticOpenFromMouse"]
    pub fn SDL_MouseIsHaptic() -> libc::c_int;
}
extern "C" {
    #[doc = " Try to open a haptic device from the current mouse."]
    #[doc = ""]
    #[doc = " \\returns the haptic device identifier or NULL on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HapticOpen"]
    #[doc = " \\sa SDL_MouseIsHaptic"]
    pub fn SDL_HapticOpenFromMouse() -> *mut SDL_Haptic;
}
extern "C" {
    #[doc = " Query if a joystick has haptic features."]
    #[doc = ""]
    #[doc = " \\param joystick the SDL_Joystick to test for haptic capabilities"]
    #[doc = " \\returns SDL_TRUE if the joystick is haptic, SDL_FALSE if it isn't, or a"]
    #[doc = "          negative error code on failure; call SDL_GetError() for more"]
    #[doc = "          information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HapticOpenFromJoystick"]
    pub fn SDL_JoystickIsHaptic(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
    #[doc = " Open a haptic device for use from a joystick device."]
    #[doc = ""]
    #[doc = " You must still close the haptic device separately. It will not be closed"]
    #[doc = " with the joystick."]
    #[doc = ""]
    #[doc = " When opened from a joystick you should first close the haptic device before"]
    #[doc = " closing the joystick device. If not, on some implementations the haptic"]
    #[doc = " device will also get unallocated and you'll be unable to use force feedback"]
    #[doc = " on that device."]
    #[doc = ""]
    #[doc = " \\param joystick the SDL_Joystick to create a haptic device from"]
    #[doc = " \\returns a valid haptic device identifier on success or NULL on failure;"]
    #[doc = "          call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HapticClose"]
    #[doc = " \\sa SDL_HapticOpen"]
    #[doc = " \\sa SDL_JoystickIsHaptic"]
    pub fn SDL_HapticOpenFromJoystick(joystick: *mut SDL_Joystick) -> *mut SDL_Haptic;
}
extern "C" {
    #[doc = " Close a haptic device previously opened with SDL_HapticOpen()."]
    #[doc = ""]
    #[doc = " \\param haptic the SDL_Haptic device to close"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HapticOpen"]
    pub fn SDL_HapticClose(haptic: *mut SDL_Haptic);
}
extern "C" {
    #[doc = " Get the number of effects a haptic device can store."]
    #[doc = ""]
    #[doc = " On some platforms this isn't fully supported, and therefore is an"]
    #[doc = " approximation. Always check to see if your created effect was actually"]
    #[doc = " created and do not rely solely on SDL_HapticNumEffects()."]
    #[doc = ""]
    #[doc = " \\param haptic the SDL_Haptic device to query"]
    #[doc = " \\returns the number of effects the haptic device can store or a negative"]
    #[doc = "          error code on failure; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HapticNumEffectsPlaying"]
    #[doc = " \\sa SDL_HapticQuery"]
    pub fn SDL_HapticNumEffects(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the number of effects a haptic device can play at the same time."]
    #[doc = ""]
    #[doc = " This is not supported on all platforms, but will always return a value."]
    #[doc = ""]
    #[doc = " \\param haptic the SDL_Haptic device to query maximum playing effects"]
    #[doc = " \\returns the number of effects the haptic device can play at the same time"]
    #[doc = "          or a negative error code on failure; call SDL_GetError() for more"]
    #[doc = "          information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HapticNumEffects"]
    #[doc = " \\sa SDL_HapticQuery"]
    pub fn SDL_HapticNumEffectsPlaying(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the haptic device's supported features in bitwise manner."]
    #[doc = ""]
    #[doc = " \\param haptic the SDL_Haptic device to query"]
    #[doc = " \\returns a list of supported haptic features in bitwise manner (OR'd), or 0"]
    #[doc = "          on failure; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HapticEffectSupported"]
    #[doc = " \\sa SDL_HapticNumEffects"]
    pub fn SDL_HapticQuery(haptic: *mut SDL_Haptic) -> libc::c_uint;
}
extern "C" {
    #[doc = " Get the number of haptic axes the device has."]
    #[doc = ""]
    #[doc = " The number of haptic axes might be useful if working with the"]
    #[doc = " SDL_HapticDirection effect."]
    #[doc = ""]
    #[doc = " \\param haptic the SDL_Haptic device to query"]
    #[doc = " \\returns the number of axes on success or a negative error code on failure;"]
    #[doc = "          call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_HapticNumAxes(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
    #[doc = " Check to see if an effect is supported by a haptic device."]
    #[doc = ""]
    #[doc = " \\param haptic the SDL_Haptic device to query"]
    #[doc = " \\param effect the desired effect to query"]
    #[doc = " \\returns SDL_TRUE if effect is supported, SDL_FALSE if it isn't, or a"]
    #[doc = "          negative error code on failure; call SDL_GetError() for more"]
    #[doc = "          information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HapticNewEffect"]
    #[doc = " \\sa SDL_HapticQuery"]
    pub fn SDL_HapticEffectSupported(
        haptic: *mut SDL_Haptic,
        effect: *mut SDL_HapticEffect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Create a new haptic effect on a specified device."]
    #[doc = ""]
    #[doc = " \\param haptic an SDL_Haptic device to create the effect on"]
    #[doc = " \\param effect an SDL_HapticEffect structure containing the properties of"]
    #[doc = "               the effect to create"]
    #[doc = " \\returns the ID of the effect on success or a negative error code on"]
    #[doc = "          failure; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HapticDestroyEffect"]
    #[doc = " \\sa SDL_HapticRunEffect"]
    #[doc = " \\sa SDL_HapticUpdateEffect"]
    pub fn SDL_HapticNewEffect(
        haptic: *mut SDL_Haptic,
        effect: *mut SDL_HapticEffect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Update the properties of an effect."]
    #[doc = ""]
    #[doc = " Can be used dynamically, although behavior when dynamically changing"]
    #[doc = " direction may be strange. Specifically the effect may re-upload itself and"]
    #[doc = " start playing from the start. You also cannot change the type either when"]
    #[doc = " running SDL_HapticUpdateEffect()."]
    #[doc = ""]
    #[doc = " \\param haptic the SDL_Haptic device that has the effect"]
    #[doc = " \\param effect the identifier of the effect to update"]
    #[doc = " \\param data an SDL_HapticEffect structure containing the new effect"]
    #[doc = "             properties to use"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HapticDestroyEffect"]
    #[doc = " \\sa SDL_HapticNewEffect"]
    #[doc = " \\sa SDL_HapticRunEffect"]
    pub fn SDL_HapticUpdateEffect(
        haptic: *mut SDL_Haptic,
        effect: libc::c_int,
        data: *mut SDL_HapticEffect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Run the haptic effect on its associated haptic device."]
    #[doc = ""]
    #[doc = " To repeat the effect over and over indefinitely, set `iterations` to"]
    #[doc = " `SDL_HAPTIC_INFINITY`. (Repeats the envelope - attack and fade.) To make"]
    #[doc = " one instance of the effect last indefinitely (so the effect does not fade),"]
    #[doc = " set the effect's `length` in its structure/union to `SDL_HAPTIC_INFINITY`"]
    #[doc = " instead."]
    #[doc = ""]
    #[doc = " \\param haptic the SDL_Haptic device to run the effect on"]
    #[doc = " \\param effect the ID of the haptic effect to run"]
    #[doc = " \\param iterations the number of iterations to run the effect; use"]
    #[doc = "                   `SDL_HAPTIC_INFINITY` to repeat forever"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HapticDestroyEffect"]
    #[doc = " \\sa SDL_HapticGetEffectStatus"]
    #[doc = " \\sa SDL_HapticStopEffect"]
    pub fn SDL_HapticRunEffect(
        haptic: *mut SDL_Haptic,
        effect: libc::c_int,
        iterations: Uint32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Stop the haptic effect on its associated haptic device."]
    #[doc = ""]
    #[doc = " *"]
    #[doc = ""]
    #[doc = " \\param haptic the SDL_Haptic device to stop the effect on"]
    #[doc = " \\param effect the ID of the haptic effect to stop"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HapticDestroyEffect"]
    #[doc = " \\sa SDL_HapticRunEffect"]
    pub fn SDL_HapticStopEffect(haptic: *mut SDL_Haptic, effect: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Destroy a haptic effect on the device."]
    #[doc = ""]
    #[doc = " This will stop the effect if it's running. Effects are automatically"]
    #[doc = " destroyed when the device is closed."]
    #[doc = ""]
    #[doc = " \\param haptic the SDL_Haptic device to destroy the effect on"]
    #[doc = " \\param effect the ID of the haptic effect to destroy"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HapticNewEffect"]
    pub fn SDL_HapticDestroyEffect(haptic: *mut SDL_Haptic, effect: libc::c_int);
}
extern "C" {
    #[doc = " Get the status of the current effect on the specified haptic device."]
    #[doc = ""]
    #[doc = " Device must support the SDL_HAPTIC_STATUS feature."]
    #[doc = ""]
    #[doc = " \\param haptic the SDL_Haptic device to query for the effect status on"]
    #[doc = " \\param effect the ID of the haptic effect to query its status"]
    #[doc = " \\returns 0 if it isn't playing, 1 if it is playing, or a negative error"]
    #[doc = "          code on failure; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HapticRunEffect"]
    #[doc = " \\sa SDL_HapticStopEffect"]
    pub fn SDL_HapticGetEffectStatus(haptic: *mut SDL_Haptic, effect: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the global gain of the specified haptic device."]
    #[doc = ""]
    #[doc = " Device must support the SDL_HAPTIC_GAIN feature."]
    #[doc = ""]
    #[doc = " The user may specify the maximum gain by setting the environment variable"]
    #[doc = " `SDL_HAPTIC_GAIN_MAX` which should be between 0 and 100. All calls to"]
    #[doc = " SDL_HapticSetGain() will scale linearly using `SDL_HAPTIC_GAIN_MAX` as the"]
    #[doc = " maximum."]
    #[doc = ""]
    #[doc = " \\param haptic the SDL_Haptic device to set the gain on"]
    #[doc = " \\param gain value to set the gain to, should be between 0 and 100 (0 - 100)"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HapticQuery"]
    pub fn SDL_HapticSetGain(haptic: *mut SDL_Haptic, gain: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the global autocenter of the device."]
    #[doc = ""]
    #[doc = " Autocenter should be between 0 and 100. Setting it to 0 will disable"]
    #[doc = " autocentering."]
    #[doc = ""]
    #[doc = " Device must support the SDL_HAPTIC_AUTOCENTER feature."]
    #[doc = ""]
    #[doc = " \\param haptic the SDL_Haptic device to set autocentering on"]
    #[doc = " \\param autocenter value to set autocenter to (0-100)"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HapticQuery"]
    pub fn SDL_HapticSetAutocenter(haptic: *mut SDL_Haptic, autocenter: libc::c_int)
        -> libc::c_int;
}
extern "C" {
    #[doc = " Pause a haptic device."]
    #[doc = ""]
    #[doc = " Device must support the `SDL_HAPTIC_PAUSE` feature. Call"]
    #[doc = " SDL_HapticUnpause() to resume playback."]
    #[doc = ""]
    #[doc = " Do not modify the effects nor add new ones while the device is paused. That"]
    #[doc = " can cause all sorts of weird errors."]
    #[doc = ""]
    #[doc = " \\param haptic the SDL_Haptic device to pause"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HapticUnpause"]
    pub fn SDL_HapticPause(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
    #[doc = " Unpause a haptic device."]
    #[doc = ""]
    #[doc = " Call to unpause after SDL_HapticPause()."]
    #[doc = ""]
    #[doc = " \\param haptic the SDL_Haptic device to unpause"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HapticPause"]
    pub fn SDL_HapticUnpause(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
    #[doc = " Stop all the currently playing effects on a haptic device."]
    #[doc = ""]
    #[doc = " \\param haptic the SDL_Haptic device to stop"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_HapticStopAll(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
    #[doc = " Check whether rumble is supported on a haptic device."]
    #[doc = ""]
    #[doc = " \\param haptic haptic device to check for rumble support"]
    #[doc = " \\returns SDL_TRUE if effect is supported, SDL_FALSE if it isn't, or a"]
    #[doc = "          negative error code on failure; call SDL_GetError() for more"]
    #[doc = "          information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HapticRumbleInit"]
    #[doc = " \\sa SDL_HapticRumblePlay"]
    #[doc = " \\sa SDL_HapticRumbleStop"]
    pub fn SDL_HapticRumbleSupported(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
    #[doc = " Initialize a haptic device for simple rumble playback."]
    #[doc = ""]
    #[doc = " \\param haptic the haptic device to initialize for simple rumble playback"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HapticOpen"]
    #[doc = " \\sa SDL_HapticRumblePlay"]
    #[doc = " \\sa SDL_HapticRumbleStop"]
    #[doc = " \\sa SDL_HapticRumbleSupported"]
    pub fn SDL_HapticRumbleInit(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
    #[doc = " Run a simple rumble effect on a haptic device."]
    #[doc = ""]
    #[doc = " \\param haptic the haptic device to play the rumble effect on"]
    #[doc = " \\param strength strength of the rumble to play as a 0-1 float value"]
    #[doc = " \\param length length of the rumble to play in milliseconds"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HapticRumbleInit"]
    #[doc = " \\sa SDL_HapticRumbleStop"]
    #[doc = " \\sa SDL_HapticRumbleSupported"]
    pub fn SDL_HapticRumblePlay(
        haptic: *mut SDL_Haptic,
        strength: f32,
        length: Uint32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Stop the simple rumble on a haptic device."]
    #[doc = ""]
    #[doc = " \\param haptic the haptic device to stop the rumble effect on"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_HapticRumbleInit"]
    #[doc = " \\sa SDL_HapticRumblePlay"]
    #[doc = " \\sa SDL_HapticRumbleSupported"]
    pub fn SDL_HapticRumbleStop(haptic: *mut SDL_Haptic) -> libc::c_int;
}
#[doc = "  \\brief  A handle representing an open HID device"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_hid_device_ {
    _unused: [u8; 0],
}
pub type SDL_hid_device = SDL_hid_device_;
#[doc = " hidapi info structure */"]
#[doc = "  \\brief  Information about a connected HID device"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_hid_device_info {
    #[doc = " Platform-specific device path"]
    pub path: *mut libc::c_char,
    #[doc = " Device Vendor ID"]
    pub vendor_id: libc::c_ushort,
    #[doc = " Device Product ID"]
    pub product_id: libc::c_ushort,
    #[doc = " Serial Number"]
    pub serial_number: *mut wchar_t,
    #[doc = " Device Release Number in binary-coded decimal,"]
    #[doc = "also known as Device Version Number"]
    pub release_number: libc::c_ushort,
    #[doc = " Manufacturer String"]
    pub manufacturer_string: *mut wchar_t,
    #[doc = " Product string"]
    pub product_string: *mut wchar_t,
    #[doc = " Usage Page for this Device/Interface"]
    #[doc = "(Windows/Mac only)."]
    pub usage_page: libc::c_ushort,
    #[doc = " Usage for this Device/Interface"]
    #[doc = "(Windows/Mac only)."]
    pub usage: libc::c_ushort,
    #[doc = " The USB interface which this logical device"]
    #[doc = "represents."]
    #[doc = ""]
    #[doc = " Valid on both Linux implementations in all cases."]
    #[doc = " Valid on the Windows implementation only if the device"]
    #[doc = "contains more than one interface."]
    pub interface_number: libc::c_int,
    #[doc = " Additional information about the USB interface."]
    #[doc = "Valid on libusb and Android implementations."]
    pub interface_class: libc::c_int,
    pub interface_subclass: libc::c_int,
    pub interface_protocol: libc::c_int,
    #[doc = " Pointer to the next device"]
    pub next: *mut SDL_hid_device_info,
}
#[test]
fn bindgen_test_layout_SDL_hid_device_info() {
    assert_eq!(
        ::core::mem::size_of::<SDL_hid_device_info>(),
        80usize,
        concat!("Size of: ", stringify!(SDL_hid_device_info))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_hid_device_info>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_hid_device_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_hid_device_info>())).path as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_hid_device_info),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_hid_device_info>())).vendor_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_hid_device_info),
            "::",
            stringify!(vendor_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_hid_device_info>())).product_id as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_hid_device_info),
            "::",
            stringify!(product_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_hid_device_info>())).serial_number as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_hid_device_info),
            "::",
            stringify!(serial_number)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_hid_device_info>())).release_number as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_hid_device_info),
            "::",
            stringify!(release_number)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_hid_device_info>())).manufacturer_string as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_hid_device_info),
            "::",
            stringify!(manufacturer_string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_hid_device_info>())).product_string as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_hid_device_info),
            "::",
            stringify!(product_string)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_hid_device_info>())).usage_page as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_hid_device_info),
            "::",
            stringify!(usage_page)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_hid_device_info>())).usage as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_hid_device_info),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_hid_device_info>())).interface_number as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_hid_device_info),
            "::",
            stringify!(interface_number)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_hid_device_info>())).interface_class as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_hid_device_info),
            "::",
            stringify!(interface_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_hid_device_info>())).interface_subclass as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_hid_device_info),
            "::",
            stringify!(interface_subclass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_hid_device_info>())).interface_protocol as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_hid_device_info),
            "::",
            stringify!(interface_protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_hid_device_info>())).next as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_hid_device_info),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    #[doc = " Initialize the HIDAPI library."]
    #[doc = ""]
    #[doc = " This function initializes the HIDAPI library. Calling it is not strictly"]
    #[doc = " necessary, as it will be called automatically by SDL_hid_enumerate() and"]
    #[doc = " any of the SDL_hid_open_*() functions if it is needed. This function should"]
    #[doc = " be called at the beginning of execution however, if there is a chance of"]
    #[doc = " HIDAPI handles being opened by different threads simultaneously."]
    #[doc = ""]
    #[doc = " Each call to this function should have a matching call to SDL_hid_exit()"]
    #[doc = ""]
    #[doc = " \\returns 0 on success and -1 on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    #[doc = ""]
    #[doc = " \\sa SDL_hid_exit"]
    pub fn SDL_hid_init() -> libc::c_int;
}
extern "C" {
    #[doc = " Finalize the HIDAPI library."]
    #[doc = ""]
    #[doc = " This function frees all of the static data associated with HIDAPI. It"]
    #[doc = " should be called at the end of execution to avoid memory leaks."]
    #[doc = ""]
    #[doc = " \\returns 0 on success and -1 on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    #[doc = ""]
    #[doc = " \\sa SDL_hid_init"]
    pub fn SDL_hid_exit() -> libc::c_int;
}
extern "C" {
    #[doc = " Check to see if devices may have been added or removed."]
    #[doc = ""]
    #[doc = " Enumerating the HID devices is an expensive operation, so you can call this"]
    #[doc = " to see if there have been any system device changes since the last call to"]
    #[doc = " this function. A change in the counter returned doesn't necessarily mean"]
    #[doc = " that anything has changed, but you can call SDL_hid_enumerate() to get an"]
    #[doc = " updated device list."]
    #[doc = ""]
    #[doc = " Calling this function for the first time may cause a thread or other system"]
    #[doc = " resource to be allocated to track device change notifications."]
    #[doc = ""]
    #[doc = " \\returns a change counter that is incremented with each potential device"]
    #[doc = "          change, or 0 if device change detection isn't available."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    #[doc = ""]
    #[doc = " \\sa SDL_hid_enumerate"]
    pub fn SDL_hid_device_change_count() -> Uint32;
}
extern "C" {
    #[doc = " Enumerate the HID Devices."]
    #[doc = ""]
    #[doc = " This function returns a linked list of all the HID devices attached to the"]
    #[doc = " system which match vendor_id and product_id. If `vendor_id` is set to 0"]
    #[doc = " then any vendor matches. If `product_id` is set to 0 then any product"]
    #[doc = " matches. If `vendor_id` and `product_id` are both set to 0, then all HID"]
    #[doc = " devices will be returned."]
    #[doc = ""]
    #[doc = " \\param vendor_id The Vendor ID (VID) of the types of device to open."]
    #[doc = " \\param product_id The Product ID (PID) of the types of device to open."]
    #[doc = " \\returns a pointer to a linked list of type SDL_hid_device_info, containing"]
    #[doc = "          information about the HID devices attached to the system, or NULL"]
    #[doc = "          in the case of failure. Free this linked list by calling"]
    #[doc = "          SDL_hid_free_enumeration()."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    #[doc = ""]
    #[doc = " \\sa SDL_hid_device_change_count"]
    pub fn SDL_hid_enumerate(
        vendor_id: libc::c_ushort,
        product_id: libc::c_ushort,
    ) -> *mut SDL_hid_device_info;
}
extern "C" {
    #[doc = " Free an enumeration Linked List"]
    #[doc = ""]
    #[doc = " This function frees a linked list created by SDL_hid_enumerate()."]
    #[doc = ""]
    #[doc = " \\param devs Pointer to a list of struct_device returned from"]
    #[doc = "             SDL_hid_enumerate()."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    pub fn SDL_hid_free_enumeration(devs: *mut SDL_hid_device_info);
}
extern "C" {
    #[doc = " Open a HID device using a Vendor ID (VID), Product ID (PID) and optionally"]
    #[doc = " a serial number."]
    #[doc = ""]
    #[doc = " If `serial_number` is NULL, the first device with the specified VID and PID"]
    #[doc = " is opened."]
    #[doc = ""]
    #[doc = " \\param vendor_id The Vendor ID (VID) of the device to open."]
    #[doc = " \\param product_id The Product ID (PID) of the device to open."]
    #[doc = " \\param serial_number The Serial Number of the device to open (Optionally"]
    #[doc = "                      NULL)."]
    #[doc = " \\returns a pointer to a SDL_hid_device object on success or NULL on"]
    #[doc = "          failure."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    pub fn SDL_hid_open(
        vendor_id: libc::c_ushort,
        product_id: libc::c_ushort,
        serial_number: *const wchar_t,
    ) -> *mut SDL_hid_device;
}
extern "C" {
    #[doc = " Open a HID device by its path name."]
    #[doc = ""]
    #[doc = " The path name be determined by calling SDL_hid_enumerate(), or a"]
    #[doc = " platform-specific path name can be used (eg: /dev/hidraw0 on Linux)."]
    #[doc = ""]
    #[doc = " \\param path The path name of the device to open"]
    #[doc = " \\returns a pointer to a SDL_hid_device object on success or NULL on"]
    #[doc = "          failure."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    pub fn SDL_hid_open_path(
        path: *const libc::c_char,
        bExclusive: libc::c_int,
    ) -> *mut SDL_hid_device;
}
extern "C" {
    #[doc = " Write an Output report to a HID device."]
    #[doc = ""]
    #[doc = " The first byte of `data` must contain the Report ID. For devices which only"]
    #[doc = " support a single report, this must be set to 0x0. The remaining bytes"]
    #[doc = " contain the report data. Since the Report ID is mandatory, calls to"]
    #[doc = " SDL_hid_write() will always contain one more byte than the report contains."]
    #[doc = " For example, if a hid report is 16 bytes long, 17 bytes must be passed to"]
    #[doc = " SDL_hid_write(), the Report ID (or 0x0, for devices with a single report),"]
    #[doc = " followed by the report data (16 bytes). In this example, the length passed"]
    #[doc = " in would be 17."]
    #[doc = ""]
    #[doc = " SDL_hid_write() will send the data on the first OUT endpoint, if one"]
    #[doc = " exists. If it does not, it will send the data through the Control Endpoint"]
    #[doc = " (Endpoint 0)."]
    #[doc = ""]
    #[doc = " \\param dev A device handle returned from SDL_hid_open()."]
    #[doc = " \\param data The data to send, including the report number as the first"]
    #[doc = "             byte."]
    #[doc = " \\param length The length in bytes of the data to send."]
    #[doc = " \\returns the actual number of bytes written and -1 on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    pub fn SDL_hid_write(
        dev: *mut SDL_hid_device,
        data: *const libc::c_uchar,
        length: size_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Read an Input report from a HID device with timeout."]
    #[doc = ""]
    #[doc = " Input reports are returned to the host through the INTERRUPT IN endpoint."]
    #[doc = " The first byte will contain the Report number if the device uses numbered"]
    #[doc = " reports."]
    #[doc = ""]
    #[doc = " \\param dev A device handle returned from SDL_hid_open()."]
    #[doc = " \\param data A buffer to put the read data into."]
    #[doc = " \\param length The number of bytes to read. For devices with multiple"]
    #[doc = "               reports, make sure to read an extra byte for the report"]
    #[doc = "               number."]
    #[doc = " \\param milliseconds timeout in milliseconds or -1 for blocking wait."]
    #[doc = " \\returns the actual number of bytes read and -1 on error. If no packet was"]
    #[doc = "          available to be read within the timeout period, this function"]
    #[doc = "          returns 0."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    pub fn SDL_hid_read_timeout(
        dev: *mut SDL_hid_device,
        data: *mut libc::c_uchar,
        length: size_t,
        milliseconds: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Read an Input report from a HID device."]
    #[doc = ""]
    #[doc = " Input reports are returned to the host through the INTERRUPT IN endpoint."]
    #[doc = " The first byte will contain the Report number if the device uses numbered"]
    #[doc = " reports."]
    #[doc = ""]
    #[doc = " \\param dev A device handle returned from SDL_hid_open()."]
    #[doc = " \\param data A buffer to put the read data into."]
    #[doc = " \\param length The number of bytes to read. For devices with multiple"]
    #[doc = "               reports, make sure to read an extra byte for the report"]
    #[doc = "               number."]
    #[doc = " \\returns the actual number of bytes read and -1 on error. If no packet was"]
    #[doc = "          available to be read and the handle is in non-blocking mode, this"]
    #[doc = "          function returns 0."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    pub fn SDL_hid_read(
        dev: *mut SDL_hid_device,
        data: *mut libc::c_uchar,
        length: size_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the device handle to be non-blocking."]
    #[doc = ""]
    #[doc = " In non-blocking mode calls to SDL_hid_read() will return immediately with a"]
    #[doc = " value of 0 if there is no data to be read. In blocking mode, SDL_hid_read()"]
    #[doc = " will wait (block) until there is data to read before returning."]
    #[doc = ""]
    #[doc = " Nonblocking can be turned on and off at any time."]
    #[doc = ""]
    #[doc = " \\param dev A device handle returned from SDL_hid_open()."]
    #[doc = " \\param nonblock enable or not the nonblocking reads - 1 to enable"]
    #[doc = "                 nonblocking - 0 to disable nonblocking."]
    #[doc = " \\returns 0 on success and -1 on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    pub fn SDL_hid_set_nonblocking(dev: *mut SDL_hid_device, nonblock: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Send a Feature report to the device."]
    #[doc = ""]
    #[doc = " Feature reports are sent over the Control endpoint as a Set_Report"]
    #[doc = " transfer. The first byte of `data` must contain the Report ID. For devices"]
    #[doc = " which only support a single report, this must be set to 0x0. The remaining"]
    #[doc = " bytes contain the report data. Since the Report ID is mandatory, calls to"]
    #[doc = " SDL_hid_send_feature_report() will always contain one more byte than the"]
    #[doc = " report contains. For example, if a hid report is 16 bytes long, 17 bytes"]
    #[doc = " must be passed to SDL_hid_send_feature_report(): the Report ID (or 0x0, for"]
    #[doc = " devices which do not use numbered reports), followed by the report data (16"]
    #[doc = " bytes). In this example, the length passed in would be 17."]
    #[doc = ""]
    #[doc = " \\param dev A device handle returned from SDL_hid_open()."]
    #[doc = " \\param data The data to send, including the report number as the first"]
    #[doc = "             byte."]
    #[doc = " \\param length The length in bytes of the data to send, including the report"]
    #[doc = "               number."]
    #[doc = " \\returns the actual number of bytes written and -1 on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    pub fn SDL_hid_send_feature_report(
        dev: *mut SDL_hid_device,
        data: *const libc::c_uchar,
        length: size_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get a feature report from a HID device."]
    #[doc = ""]
    #[doc = " Set the first byte of `data` to the Report ID of the report to be read."]
    #[doc = " Make sure to allow space for this extra byte in `data`. Upon return, the"]
    #[doc = " first byte will still contain the Report ID, and the report data will start"]
    #[doc = " in data[1]."]
    #[doc = ""]
    #[doc = " \\param dev A device handle returned from SDL_hid_open()."]
    #[doc = " \\param data A buffer to put the read data into, including the Report ID."]
    #[doc = "             Set the first byte of `data` to the Report ID of the report to"]
    #[doc = "             be read, or set it to zero if your device does not use numbered"]
    #[doc = "             reports."]
    #[doc = " \\param length The number of bytes to read, including an extra byte for the"]
    #[doc = "               report ID. The buffer can be longer than the actual report."]
    #[doc = " \\returns the number of bytes read plus one for the report ID (which is"]
    #[doc = "          still in the first byte), or -1 on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    pub fn SDL_hid_get_feature_report(
        dev: *mut SDL_hid_device,
        data: *mut libc::c_uchar,
        length: size_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Close a HID device."]
    #[doc = ""]
    #[doc = " \\param dev A device handle returned from SDL_hid_open()."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    pub fn SDL_hid_close(dev: *mut SDL_hid_device);
}
extern "C" {
    #[doc = " Get The Manufacturer String from a HID device."]
    #[doc = ""]
    #[doc = " \\param dev A device handle returned from SDL_hid_open()."]
    #[doc = " \\param string A wide string buffer to put the data into."]
    #[doc = " \\param maxlen The length of the buffer in multiples of wchar_t."]
    #[doc = " \\returns 0 on success and -1 on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    pub fn SDL_hid_get_manufacturer_string(
        dev: *mut SDL_hid_device,
        string: *mut wchar_t,
        maxlen: size_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get The Product String from a HID device."]
    #[doc = ""]
    #[doc = " \\param dev A device handle returned from SDL_hid_open()."]
    #[doc = " \\param string A wide string buffer to put the data into."]
    #[doc = " \\param maxlen The length of the buffer in multiples of wchar_t."]
    #[doc = " \\returns 0 on success and -1 on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    pub fn SDL_hid_get_product_string(
        dev: *mut SDL_hid_device,
        string: *mut wchar_t,
        maxlen: size_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get The Serial Number String from a HID device."]
    #[doc = ""]
    #[doc = " \\param dev A device handle returned from SDL_hid_open()."]
    #[doc = " \\param string A wide string buffer to put the data into."]
    #[doc = " \\param maxlen The length of the buffer in multiples of wchar_t."]
    #[doc = " \\returns 0 on success and -1 on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    pub fn SDL_hid_get_serial_number_string(
        dev: *mut SDL_hid_device,
        string: *mut wchar_t,
        maxlen: size_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get a string from a HID device, based on its string index."]
    #[doc = ""]
    #[doc = " \\param dev A device handle returned from SDL_hid_open()."]
    #[doc = " \\param string_index The index of the string to get."]
    #[doc = " \\param string A wide string buffer to put the data into."]
    #[doc = " \\param maxlen The length of the buffer in multiples of wchar_t."]
    #[doc = " \\returns 0 on success and -1 on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    pub fn SDL_hid_get_indexed_string(
        dev: *mut SDL_hid_device,
        string_index: libc::c_int,
        string: *mut wchar_t,
        maxlen: size_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Start or stop a BLE scan on iOS and tvOS to pair Steam Controllers"]
    #[doc = ""]
    #[doc = " \\param active SDL_TRUE to start the scan, SDL_FALSE to stop the scan"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    pub fn SDL_hid_ble_scan(active: SDL_bool);
}
#[repr(u32)]
#[doc = "  \\brief  An enumeration of hint priorities"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_HintPriority {
    SDL_HINT_DEFAULT = 0,
    SDL_HINT_NORMAL = 1,
    SDL_HINT_OVERRIDE = 2,
}
extern "C" {
    #[doc = " Set a hint with a specific priority."]
    #[doc = ""]
    #[doc = " The priority controls the behavior when setting a hint that already has a"]
    #[doc = " value. Hints will replace existing hints of their priority and lower."]
    #[doc = " Environment variables are considered to have override priority."]
    #[doc = ""]
    #[doc = " \\param name the hint to set"]
    #[doc = " \\param value the value of the hint variable"]
    #[doc = " \\param priority the SDL_HintPriority level for the hint"]
    #[doc = " \\returns SDL_TRUE if the hint was set, SDL_FALSE otherwise."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetHint"]
    #[doc = " \\sa SDL_SetHint"]
    pub fn SDL_SetHintWithPriority(
        name: *const libc::c_char,
        value: *const libc::c_char,
        priority: SDL_HintPriority,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = " Set a hint with normal priority."]
    #[doc = ""]
    #[doc = " Hints will not be set if there is an existing override hint or environment"]
    #[doc = " variable that takes precedence. You can use SDL_SetHintWithPriority() to"]
    #[doc = " set the hint with override priority instead."]
    #[doc = ""]
    #[doc = " \\param name the hint to set"]
    #[doc = " \\param value the value of the hint variable"]
    #[doc = " \\returns SDL_TRUE if the hint was set, SDL_FALSE otherwise."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetHint"]
    #[doc = " \\sa SDL_SetHintWithPriority"]
    pub fn SDL_SetHint(name: *const libc::c_char, value: *const libc::c_char) -> SDL_bool;
}
extern "C" {
    #[doc = " Get the value of a hint."]
    #[doc = ""]
    #[doc = " \\param name the hint to query"]
    #[doc = " \\returns the string value of a hint or NULL if the hint isn't set."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_SetHint"]
    #[doc = " \\sa SDL_SetHintWithPriority"]
    pub fn SDL_GetHint(name: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the boolean value of a hint variable."]
    #[doc = ""]
    #[doc = " \\param name the name of the hint to get the boolean value from"]
    #[doc = " \\param default_value the value to return if the hint does not exist"]
    #[doc = " \\returns the boolean value of a hint or the provided default value if the"]
    #[doc = "          hint does not exist."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.5."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetHint"]
    #[doc = " \\sa SDL_SetHint"]
    pub fn SDL_GetHintBoolean(name: *const libc::c_char, default_value: SDL_bool) -> SDL_bool;
}
#[doc = " Type definition of the hint callback function."]
#[doc = ""]
#[doc = " \\param userdata what was passed as `userdata` to SDL_AddHintCallback()"]
#[doc = " \\param name what was passed as `name` to SDL_AddHintCallback()"]
#[doc = " \\param oldValue the previous hint value"]
#[doc = " \\param newValue the new value hint is to be set to"]
pub type SDL_HintCallback = ::core::option::Option<
    unsafe extern "C" fn(
        userdata: *mut libc::c_void,
        name: *const libc::c_char,
        oldValue: *const libc::c_char,
        newValue: *const libc::c_char,
    ),
>;
extern "C" {
    #[doc = " Add a function to watch a particular hint."]
    #[doc = ""]
    #[doc = " \\param name the hint to watch"]
    #[doc = " \\param callback An SDL_HintCallback function that will be called when the"]
    #[doc = "                 hint value changes"]
    #[doc = " \\param userdata a pointer to pass to the callback function"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_DelHintCallback"]
    pub fn SDL_AddHintCallback(
        name: *const libc::c_char,
        callback: SDL_HintCallback,
        userdata: *mut libc::c_void,
    );
}
extern "C" {
    #[doc = " Remove a function watching a particular hint."]
    #[doc = ""]
    #[doc = " \\param name the hint being watched"]
    #[doc = " \\param callback An SDL_HintCallback function that will be called when the"]
    #[doc = "                 hint value changes"]
    #[doc = " \\param userdata a pointer being passed to the callback function"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_AddHintCallback"]
    pub fn SDL_DelHintCallback(
        name: *const libc::c_char,
        callback: SDL_HintCallback,
        userdata: *mut libc::c_void,
    );
}
extern "C" {
    #[doc = " Clear all hints."]
    #[doc = ""]
    #[doc = " This function is automatically called during SDL_Quit()."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_ClearHints();
}
extern "C" {
    #[doc = " Dynamically load a shared object."]
    #[doc = ""]
    #[doc = " \\param sofile a system-dependent name of the object file"]
    #[doc = " \\returns an opaque pointer to the object handle or NULL if there was an"]
    #[doc = "          error; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_LoadFunction"]
    #[doc = " \\sa SDL_UnloadObject"]
    pub fn SDL_LoadObject(sofile: *const libc::c_char) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Look up the address of the named function in a shared object."]
    #[doc = ""]
    #[doc = " This function pointer is no longer valid after calling SDL_UnloadObject()."]
    #[doc = ""]
    #[doc = " This function can only look up C function names. Other languages may have"]
    #[doc = " name mangling and intrinsic language support that varies from compiler to"]
    #[doc = " compiler."]
    #[doc = ""]
    #[doc = " Make sure you declare your function pointers with the same calling"]
    #[doc = " convention as the actual library function. Your code will crash"]
    #[doc = " mysteriously if you do not do this."]
    #[doc = ""]
    #[doc = " If the requested function doesn't exist, NULL is returned."]
    #[doc = ""]
    #[doc = " \\param handle a valid shared object handle returned by SDL_LoadObject()"]
    #[doc = " \\param name the name of the function to look up"]
    #[doc = " \\returns a pointer to the function or NULL if there was an error; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_LoadObject"]
    #[doc = " \\sa SDL_UnloadObject"]
    pub fn SDL_LoadFunction(
        handle: *mut libc::c_void,
        name: *const libc::c_char,
    ) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Unload a shared object from memory."]
    #[doc = ""]
    #[doc = " \\param handle a valid shared object handle returned by SDL_LoadObject()"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_LoadFunction"]
    #[doc = " \\sa SDL_LoadObject"]
    pub fn SDL_UnloadObject(handle: *mut libc::c_void);
}
#[repr(u32)]
#[doc = "  \\brief The predefined log categories"]
#[doc = ""]
#[doc = "  By default the application category is enabled at the INFO level,"]
#[doc = "  the assert category is enabled at the WARN level, test is enabled"]
#[doc = "  at the VERBOSE level and all other categories are enabled at the"]
#[doc = "  CRITICAL level."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_LogCategory {
    SDL_LOG_CATEGORY_APPLICATION = 0,
    SDL_LOG_CATEGORY_ERROR = 1,
    SDL_LOG_CATEGORY_ASSERT = 2,
    SDL_LOG_CATEGORY_SYSTEM = 3,
    SDL_LOG_CATEGORY_AUDIO = 4,
    SDL_LOG_CATEGORY_VIDEO = 5,
    SDL_LOG_CATEGORY_RENDER = 6,
    SDL_LOG_CATEGORY_INPUT = 7,
    SDL_LOG_CATEGORY_TEST = 8,
    SDL_LOG_CATEGORY_RESERVED1 = 9,
    SDL_LOG_CATEGORY_RESERVED2 = 10,
    SDL_LOG_CATEGORY_RESERVED3 = 11,
    SDL_LOG_CATEGORY_RESERVED4 = 12,
    SDL_LOG_CATEGORY_RESERVED5 = 13,
    SDL_LOG_CATEGORY_RESERVED6 = 14,
    SDL_LOG_CATEGORY_RESERVED7 = 15,
    SDL_LOG_CATEGORY_RESERVED8 = 16,
    SDL_LOG_CATEGORY_RESERVED9 = 17,
    SDL_LOG_CATEGORY_RESERVED10 = 18,
    SDL_LOG_CATEGORY_CUSTOM = 19,
}
#[repr(u32)]
#[doc = "  \\brief The predefined log priorities"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_LogPriority {
    SDL_LOG_PRIORITY_VERBOSE = 1,
    SDL_LOG_PRIORITY_DEBUG = 2,
    SDL_LOG_PRIORITY_INFO = 3,
    SDL_LOG_PRIORITY_WARN = 4,
    SDL_LOG_PRIORITY_ERROR = 5,
    SDL_LOG_PRIORITY_CRITICAL = 6,
    SDL_NUM_LOG_PRIORITIES = 7,
}
extern "C" {
    #[doc = " Set the priority of all log categories."]
    #[doc = ""]
    #[doc = " \\param priority the SDL_LogPriority to assign"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_LogSetPriority"]
    pub fn SDL_LogSetAllPriority(priority: SDL_LogPriority);
}
extern "C" {
    #[doc = " Set the priority of a particular log category."]
    #[doc = ""]
    #[doc = " \\param category the category to assign a priority to"]
    #[doc = " \\param priority the SDL_LogPriority to assign"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_LogGetPriority"]
    #[doc = " \\sa SDL_LogSetAllPriority"]
    pub fn SDL_LogSetPriority(category: libc::c_int, priority: SDL_LogPriority);
}
extern "C" {
    #[doc = " Get the priority of a particular log category."]
    #[doc = ""]
    #[doc = " \\param category the category to query"]
    #[doc = " \\returns the SDL_LogPriority for the requested category"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_LogSetPriority"]
    pub fn SDL_LogGetPriority(category: libc::c_int) -> SDL_LogPriority;
}
extern "C" {
    #[doc = " Reset all priorities to default."]
    #[doc = ""]
    #[doc = " This is called by SDL_Quit()."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_LogSetAllPriority"]
    #[doc = " \\sa SDL_LogSetPriority"]
    pub fn SDL_LogResetPriorities();
}
extern "C" {
    #[doc = " Log a message with SDL_LOG_CATEGORY_APPLICATION and SDL_LOG_PRIORITY_INFO."]
    #[doc = ""]
    #[doc = " = * \\param fmt a printf() style message format string"]
    #[doc = ""]
    #[doc = " \\param ... additional parameters matching % tokens in the `fmt` string, if"]
    #[doc = "            any"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_LogCritical"]
    #[doc = " \\sa SDL_LogDebug"]
    #[doc = " \\sa SDL_LogError"]
    #[doc = " \\sa SDL_LogInfo"]
    #[doc = " \\sa SDL_LogMessage"]
    #[doc = " \\sa SDL_LogMessageV"]
    #[doc = " \\sa SDL_LogVerbose"]
    #[doc = " \\sa SDL_LogWarn"]
    pub fn SDL_Log(fmt: *const libc::c_char, ...);
}
extern "C" {
    #[doc = " Log a message with SDL_LOG_PRIORITY_VERBOSE."]
    #[doc = ""]
    #[doc = " \\param category the category of the message"]
    #[doc = " \\param fmt a printf() style message format string"]
    #[doc = " \\param ... additional parameters matching % tokens in the **fmt** string,"]
    #[doc = "            if any"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_Log"]
    #[doc = " \\sa SDL_LogCritical"]
    #[doc = " \\sa SDL_LogDebug"]
    #[doc = " \\sa SDL_LogError"]
    #[doc = " \\sa SDL_LogInfo"]
    #[doc = " \\sa SDL_LogMessage"]
    #[doc = " \\sa SDL_LogMessageV"]
    #[doc = " \\sa SDL_LogWarn"]
    pub fn SDL_LogVerbose(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
    #[doc = " Log a message with SDL_LOG_PRIORITY_DEBUG."]
    #[doc = ""]
    #[doc = " \\param category the category of the message"]
    #[doc = " \\param fmt a printf() style message format string"]
    #[doc = " \\param ... additional parameters matching % tokens in the **fmt** string,"]
    #[doc = "            if any"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_Log"]
    #[doc = " \\sa SDL_LogCritical"]
    #[doc = " \\sa SDL_LogError"]
    #[doc = " \\sa SDL_LogInfo"]
    #[doc = " \\sa SDL_LogMessage"]
    #[doc = " \\sa SDL_LogMessageV"]
    #[doc = " \\sa SDL_LogVerbose"]
    #[doc = " \\sa SDL_LogWarn"]
    pub fn SDL_LogDebug(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
    #[doc = " Log a message with SDL_LOG_PRIORITY_INFO."]
    #[doc = ""]
    #[doc = " \\param category the category of the message"]
    #[doc = " \\param fmt a printf() style message format string"]
    #[doc = " \\param ... additional parameters matching % tokens in the **fmt** string,"]
    #[doc = "            if any"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_Log"]
    #[doc = " \\sa SDL_LogCritical"]
    #[doc = " \\sa SDL_LogDebug"]
    #[doc = " \\sa SDL_LogError"]
    #[doc = " \\sa SDL_LogMessage"]
    #[doc = " \\sa SDL_LogMessageV"]
    #[doc = " \\sa SDL_LogVerbose"]
    #[doc = " \\sa SDL_LogWarn"]
    pub fn SDL_LogInfo(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
    #[doc = " Log a message with SDL_LOG_PRIORITY_WARN."]
    #[doc = ""]
    #[doc = " \\param category the category of the message"]
    #[doc = " \\param fmt a printf() style message format string"]
    #[doc = " \\param ... additional parameters matching % tokens in the **fmt** string,"]
    #[doc = "            if any"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_Log"]
    #[doc = " \\sa SDL_LogCritical"]
    #[doc = " \\sa SDL_LogDebug"]
    #[doc = " \\sa SDL_LogError"]
    #[doc = " \\sa SDL_LogInfo"]
    #[doc = " \\sa SDL_LogMessage"]
    #[doc = " \\sa SDL_LogMessageV"]
    #[doc = " \\sa SDL_LogVerbose"]
    pub fn SDL_LogWarn(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
    #[doc = " Log a message with SDL_LOG_PRIORITY_ERROR."]
    #[doc = ""]
    #[doc = " \\param category the category of the message"]
    #[doc = " \\param fmt a printf() style message format string"]
    #[doc = " \\param ... additional parameters matching % tokens in the **fmt** string,"]
    #[doc = "            if any"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_Log"]
    #[doc = " \\sa SDL_LogCritical"]
    #[doc = " \\sa SDL_LogDebug"]
    #[doc = " \\sa SDL_LogInfo"]
    #[doc = " \\sa SDL_LogMessage"]
    #[doc = " \\sa SDL_LogMessageV"]
    #[doc = " \\sa SDL_LogVerbose"]
    #[doc = " \\sa SDL_LogWarn"]
    pub fn SDL_LogError(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
    #[doc = " Log a message with SDL_LOG_PRIORITY_CRITICAL."]
    #[doc = ""]
    #[doc = " \\param category the category of the message"]
    #[doc = " \\param fmt a printf() style message format string"]
    #[doc = " \\param ... additional parameters matching % tokens in the **fmt** string,"]
    #[doc = "            if any"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_Log"]
    #[doc = " \\sa SDL_LogDebug"]
    #[doc = " \\sa SDL_LogError"]
    #[doc = " \\sa SDL_LogInfo"]
    #[doc = " \\sa SDL_LogMessage"]
    #[doc = " \\sa SDL_LogMessageV"]
    #[doc = " \\sa SDL_LogVerbose"]
    #[doc = " \\sa SDL_LogWarn"]
    pub fn SDL_LogCritical(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
    #[doc = " Log a message with the specified category and priority."]
    #[doc = ""]
    #[doc = " \\param category the category of the message"]
    #[doc = " \\param priority the priority of the message"]
    #[doc = " \\param fmt a printf() style message format string"]
    #[doc = " \\param ... additional parameters matching % tokens in the **fmt** string,"]
    #[doc = "            if any"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_Log"]
    #[doc = " \\sa SDL_LogCritical"]
    #[doc = " \\sa SDL_LogDebug"]
    #[doc = " \\sa SDL_LogError"]
    #[doc = " \\sa SDL_LogInfo"]
    #[doc = " \\sa SDL_LogMessageV"]
    #[doc = " \\sa SDL_LogVerbose"]
    #[doc = " \\sa SDL_LogWarn"]
    pub fn SDL_LogMessage(
        category: libc::c_int,
        priority: SDL_LogPriority,
        fmt: *const libc::c_char,
        ...
    );
}
extern "C" {
    #[doc = " Log a message with the specified category and priority."]
    #[doc = ""]
    #[doc = " \\param category the category of the message"]
    #[doc = " \\param priority the priority of the message"]
    #[doc = " \\param fmt a printf() style message format string"]
    #[doc = " \\param ap a variable argument list"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_Log"]
    #[doc = " \\sa SDL_LogCritical"]
    #[doc = " \\sa SDL_LogDebug"]
    #[doc = " \\sa SDL_LogError"]
    #[doc = " \\sa SDL_LogInfo"]
    #[doc = " \\sa SDL_LogMessage"]
    #[doc = " \\sa SDL_LogVerbose"]
    #[doc = " \\sa SDL_LogWarn"]
    pub fn SDL_LogMessageV(
        category: libc::c_int,
        priority: SDL_LogPriority,
        fmt: *const libc::c_char,
        ap: *mut __va_list_tag,
    );
}
#[doc = " The prototype for the log output callback function."]
#[doc = ""]
#[doc = " This function is called by SDL when there is new text to be logged."]
#[doc = ""]
#[doc = " \\param userdata what was passed as `userdata` to SDL_LogSetOutputFunction()"]
#[doc = " \\param category the category of the message"]
#[doc = " \\param priority the priority of the message"]
#[doc = " \\param message the message being output"]
pub type SDL_LogOutputFunction = ::core::option::Option<
    unsafe extern "C" fn(
        userdata: *mut libc::c_void,
        category: libc::c_int,
        priority: SDL_LogPriority,
        message: *const libc::c_char,
    ),
>;
extern "C" {
    #[doc = " Get the current log output function."]
    #[doc = ""]
    #[doc = " \\param callback an SDL_LogOutputFunction filled in with the current log"]
    #[doc = "                 callback"]
    #[doc = " \\param userdata a pointer filled in with the pointer that is passed to"]
    #[doc = "                 `callback`"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_LogSetOutputFunction"]
    pub fn SDL_LogGetOutputFunction(
        callback: *mut SDL_LogOutputFunction,
        userdata: *mut *mut libc::c_void,
    );
}
extern "C" {
    #[doc = " Replace the default log output function with one of your own."]
    #[doc = ""]
    #[doc = " \\param callback an SDL_LogOutputFunction to call instead of the default"]
    #[doc = " \\param userdata a pointer that is passed to `callback`"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_LogGetOutputFunction"]
    pub fn SDL_LogSetOutputFunction(callback: SDL_LogOutputFunction, userdata: *mut libc::c_void);
}
#[repr(u32)]
#[doc = " SDL_MessageBox flags. If supported will display warning icon, etc."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_MessageBoxFlags {
    #[doc = "< error dialog"]
    SDL_MESSAGEBOX_ERROR = 16,
    #[doc = "< warning dialog"]
    SDL_MESSAGEBOX_WARNING = 32,
    #[doc = "< informational dialog"]
    SDL_MESSAGEBOX_INFORMATION = 64,
    #[doc = "< buttons placed left to right"]
    SDL_MESSAGEBOX_BUTTONS_LEFT_TO_RIGHT = 128,
    #[doc = "< buttons placed right to left"]
    SDL_MESSAGEBOX_BUTTONS_RIGHT_TO_LEFT = 256,
}
#[repr(u32)]
#[doc = " Flags for SDL_MessageBoxButtonData."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_MessageBoxButtonFlags {
    #[doc = "< Marks the default button when return is hit"]
    SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT = 1,
    #[doc = "< Marks the default button when escape is hit"]
    SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT = 2,
}
#[doc = " Individual button data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_MessageBoxButtonData {
    #[doc = "< ::SDL_MessageBoxButtonFlags"]
    pub flags: Uint32,
    #[doc = "< User defined button id (value returned via SDL_ShowMessageBox)"]
    pub buttonid: libc::c_int,
    #[doc = "< The UTF-8 button text"]
    pub text: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxButtonData() {
    assert_eq!(
        ::core::mem::size_of::<SDL_MessageBoxButtonData>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_MessageBoxButtonData))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_MessageBoxButtonData>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_MessageBoxButtonData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MessageBoxButtonData>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxButtonData),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_MessageBoxButtonData>())).buttonid as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxButtonData),
            "::",
            stringify!(buttonid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MessageBoxButtonData>())).text as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxButtonData),
            "::",
            stringify!(text)
        )
    );
}
#[doc = " RGB value used in a message box color scheme"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_MessageBoxColor {
    pub r: Uint8,
    pub g: Uint8,
    pub b: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxColor() {
    assert_eq!(
        ::core::mem::size_of::<SDL_MessageBoxColor>(),
        3usize,
        concat!("Size of: ", stringify!(SDL_MessageBoxColor))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_MessageBoxColor>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_MessageBoxColor))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MessageBoxColor>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxColor),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MessageBoxColor>())).g as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxColor),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MessageBoxColor>())).b as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxColor),
            "::",
            stringify!(b)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_MessageBoxColorType {
    SDL_MESSAGEBOX_COLOR_BACKGROUND = 0,
    SDL_MESSAGEBOX_COLOR_TEXT = 1,
    SDL_MESSAGEBOX_COLOR_BUTTON_BORDER = 2,
    SDL_MESSAGEBOX_COLOR_BUTTON_BACKGROUND = 3,
    SDL_MESSAGEBOX_COLOR_BUTTON_SELECTED = 4,
    SDL_MESSAGEBOX_COLOR_MAX = 5,
}
#[doc = " A set of colors to use for message box dialogs"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_MessageBoxColorScheme {
    pub colors: [SDL_MessageBoxColor; 5usize],
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxColorScheme() {
    assert_eq!(
        ::core::mem::size_of::<SDL_MessageBoxColorScheme>(),
        15usize,
        concat!("Size of: ", stringify!(SDL_MessageBoxColorScheme))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_MessageBoxColorScheme>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_MessageBoxColorScheme))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_MessageBoxColorScheme>())).colors as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxColorScheme),
            "::",
            stringify!(colors)
        )
    );
}
#[doc = " MessageBox structure containing title, text, window, etc."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_MessageBoxData {
    #[doc = "< ::SDL_MessageBoxFlags"]
    pub flags: Uint32,
    #[doc = "< Parent window, can be NULL"]
    pub window: *mut SDL_Window,
    #[doc = "< UTF-8 title"]
    pub title: *const libc::c_char,
    #[doc = "< UTF-8 message text"]
    pub message: *const libc::c_char,
    pub numbuttons: libc::c_int,
    pub buttons: *const SDL_MessageBoxButtonData,
    #[doc = "< ::SDL_MessageBoxColorScheme, can be NULL to use system settings"]
    pub colorScheme: *const SDL_MessageBoxColorScheme,
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxData() {
    assert_eq!(
        ::core::mem::size_of::<SDL_MessageBoxData>(),
        56usize,
        concat!("Size of: ", stringify!(SDL_MessageBoxData))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_MessageBoxData>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_MessageBoxData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MessageBoxData>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxData),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MessageBoxData>())).window as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxData),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MessageBoxData>())).title as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxData),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MessageBoxData>())).message as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxData),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MessageBoxData>())).numbuttons as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxData),
            "::",
            stringify!(numbuttons)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MessageBoxData>())).buttons as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxData),
            "::",
            stringify!(buttons)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_MessageBoxData>())).colorScheme as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxData),
            "::",
            stringify!(colorScheme)
        )
    );
}
extern "C" {
    #[doc = " Create a modal message box."]
    #[doc = ""]
    #[doc = " If your needs aren't complex, it might be easier to use"]
    #[doc = " SDL_ShowSimpleMessageBox."]
    #[doc = ""]
    #[doc = " This function should be called on the thread that created the parent"]
    #[doc = " window, or on the main thread if the messagebox has no parent. It will"]
    #[doc = " block execution of that thread until the user clicks a button or closes the"]
    #[doc = " messagebox."]
    #[doc = ""]
    #[doc = " This function may be called at any time, even before SDL_Init(). This makes"]
    #[doc = " it useful for reporting errors like a failure to create a renderer or"]
    #[doc = " OpenGL context."]
    #[doc = ""]
    #[doc = " On X11, SDL rolls its own dialog box with X11 primitives instead of a"]
    #[doc = " formal toolkit like GTK+ or Qt."]
    #[doc = ""]
    #[doc = " Note that if SDL_Init() would fail because there isn't any available video"]
    #[doc = " target, this function is likely to fail for the same reasons. If this is a"]
    #[doc = " concern, check the return value from this function and fall back to writing"]
    #[doc = " to stderr if you can."]
    #[doc = ""]
    #[doc = " \\param messageboxdata the SDL_MessageBoxData structure with title, text and"]
    #[doc = "                       other options"]
    #[doc = " \\param buttonid the pointer to which user id of hit button should be copied"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_ShowSimpleMessageBox"]
    pub fn SDL_ShowMessageBox(
        messageboxdata: *const SDL_MessageBoxData,
        buttonid: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Display a simple modal message box."]
    #[doc = ""]
    #[doc = " If your needs aren't complex, this function is preferred over"]
    #[doc = " SDL_ShowMessageBox."]
    #[doc = ""]
    #[doc = " `flags` may be any of the following:"]
    #[doc = ""]
    #[doc = " - `SDL_MESSAGEBOX_ERROR`: error dialog"]
    #[doc = " - `SDL_MESSAGEBOX_WARNING`: warning dialog"]
    #[doc = " - `SDL_MESSAGEBOX_INFORMATION`: informational dialog"]
    #[doc = ""]
    #[doc = " This function should be called on the thread that created the parent"]
    #[doc = " window, or on the main thread if the messagebox has no parent. It will"]
    #[doc = " block execution of that thread until the user clicks a button or closes the"]
    #[doc = " messagebox."]
    #[doc = ""]
    #[doc = " This function may be called at any time, even before SDL_Init(). This makes"]
    #[doc = " it useful for reporting errors like a failure to create a renderer or"]
    #[doc = " OpenGL context."]
    #[doc = ""]
    #[doc = " On X11, SDL rolls its own dialog box with X11 primitives instead of a"]
    #[doc = " formal toolkit like GTK+ or Qt."]
    #[doc = ""]
    #[doc = " Note that if SDL_Init() would fail because there isn't any available video"]
    #[doc = " target, this function is likely to fail for the same reasons. If this is a"]
    #[doc = " concern, check the return value from this function and fall back to writing"]
    #[doc = " to stderr if you can."]
    #[doc = ""]
    #[doc = " \\param flags an SDL_MessageBoxFlags value"]
    #[doc = " \\param title UTF-8 title text"]
    #[doc = " \\param message UTF-8 message text"]
    #[doc = " \\param window the parent window, or NULL for no parent"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_ShowMessageBox"]
    pub fn SDL_ShowSimpleMessageBox(
        flags: Uint32,
        title: *const libc::c_char,
        message: *const libc::c_char,
        window: *mut SDL_Window,
    ) -> libc::c_int;
}
#[doc = "  \\brief A handle to a CAMetalLayer-backed NSView (macOS) or UIView (iOS/tvOS)."]
#[doc = ""]
#[doc = "  \\note This can be cast directly to an NSView or UIView."]
pub type SDL_MetalView = *mut libc::c_void;
extern "C" {
    #[doc = " Create a CAMetalLayer-backed NSView/UIView and attach it to the specified"]
    #[doc = " window."]
    #[doc = ""]
    #[doc = " On macOS, this does *not* associate a MTLDevice with the CAMetalLayer on"]
    #[doc = " its own. It is up to user code to do that."]
    #[doc = ""]
    #[doc = " The returned handle can be casted directly to a NSView or UIView. To access"]
    #[doc = " the backing CAMetalLayer, call SDL_Metal_GetLayer()."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.12."]
    #[doc = ""]
    #[doc = " \\sa SDL_Metal_DestroyView"]
    #[doc = " \\sa SDL_Metal_GetLayer"]
    pub fn SDL_Metal_CreateView(window: *mut SDL_Window) -> SDL_MetalView;
}
extern "C" {
    #[doc = " Destroy an existing SDL_MetalView object."]
    #[doc = ""]
    #[doc = " This should be called before SDL_DestroyWindow, if SDL_Metal_CreateView was"]
    #[doc = " called after SDL_CreateWindow."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.12."]
    #[doc = ""]
    #[doc = " \\sa SDL_Metal_CreateView"]
    pub fn SDL_Metal_DestroyView(view: SDL_MetalView);
}
extern "C" {
    #[doc = " Get a pointer to the backing CAMetalLayer for the given view."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.14."]
    #[doc = ""]
    #[doc = " \\sa SDL_MetalCreateView"]
    pub fn SDL_Metal_GetLayer(view: SDL_MetalView) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Get the size of a window's underlying drawable in pixels (for use with"]
    #[doc = " setting viewport, scissor & etc)."]
    #[doc = ""]
    #[doc = " \\param window SDL_Window from which the drawable size should be queried"]
    #[doc = " \\param w Pointer to variable for storing the width in pixels, may be NULL"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.14."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetWindowSize"]
    #[doc = " \\sa SDL_CreateWindow"]
    pub fn SDL_Metal_GetDrawableSize(
        window: *mut SDL_Window,
        w: *mut libc::c_int,
        h: *mut libc::c_int,
    );
}
#[repr(u32)]
#[doc = "  The basic state for the system's power supply."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_PowerState {
    #[doc = "< cannot determine power status"]
    SDL_POWERSTATE_UNKNOWN = 0,
    #[doc = "< Not plugged in, running on the battery"]
    SDL_POWERSTATE_ON_BATTERY = 1,
    #[doc = "< Plugged in, no battery available"]
    SDL_POWERSTATE_NO_BATTERY = 2,
    #[doc = "< Plugged in, charging battery"]
    SDL_POWERSTATE_CHARGING = 3,
    #[doc = "< Plugged in, battery charged"]
    SDL_POWERSTATE_CHARGED = 4,
}
extern "C" {
    #[doc = " Get the current power supply details."]
    #[doc = ""]
    #[doc = " You should never take a battery status as absolute truth. Batteries"]
    #[doc = " (especially failing batteries) are delicate hardware, and the values"]
    #[doc = " reported here are best estimates based on what that hardware reports. It's"]
    #[doc = " not uncommon for older batteries to lose stored power much faster than it"]
    #[doc = " reports, or completely drain when reporting it has 20 percent left, etc."]
    #[doc = ""]
    #[doc = " Battery status can change at any time; if you are concerned with power"]
    #[doc = " state, you should call this function frequently, and perhaps ignore changes"]
    #[doc = " until they seem to be stable for a few seconds."]
    #[doc = ""]
    #[doc = " It's possible a platform can only report battery percentage or time left"]
    #[doc = " but not both."]
    #[doc = ""]
    #[doc = " \\param secs seconds of battery life left, you can pass a NULL here if you"]
    #[doc = "             don't care, will return -1 if we can't determine a value, or"]
    #[doc = "             we're not running on a battery"]
    #[doc = " \\param pct percentage of battery life left, between 0 and 100, you can pass"]
    #[doc = "            a NULL here if you don't care, will return -1 if we can't"]
    #[doc = "            determine a value, or we're not running on a battery"]
    #[doc = " \\returns an SDL_PowerState enum representing the current battery state."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_GetPowerInfo(secs: *mut libc::c_int, pct: *mut libc::c_int) -> SDL_PowerState;
}
#[repr(u32)]
#[doc = " Flags used when creating a rendering context"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_RendererFlags {
    #[doc = "< The renderer is a software fallback"]
    SDL_RENDERER_SOFTWARE = 1,
    #[doc = "< The renderer uses hardware"]
    #[doc = "acceleration"]
    SDL_RENDERER_ACCELERATED = 2,
    #[doc = "< Present is synchronized"]
    #[doc = "with the refresh rate"]
    SDL_RENDERER_PRESENTVSYNC = 4,
    #[doc = "< The renderer supports"]
    #[doc = "rendering to texture"]
    SDL_RENDERER_TARGETTEXTURE = 8,
}
#[doc = " Information on the capabilities of a render driver or context."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_RendererInfo {
    #[doc = "< The name of the renderer"]
    pub name: *const libc::c_char,
    #[doc = "< Supported ::SDL_RendererFlags"]
    pub flags: Uint32,
    #[doc = "< The number of available texture formats"]
    pub num_texture_formats: Uint32,
    #[doc = "< The available texture formats"]
    pub texture_formats: [Uint32; 16usize],
    #[doc = "< The maximum texture width"]
    pub max_texture_width: libc::c_int,
    #[doc = "< The maximum texture height"]
    pub max_texture_height: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_RendererInfo() {
    assert_eq!(
        ::core::mem::size_of::<SDL_RendererInfo>(),
        88usize,
        concat!("Size of: ", stringify!(SDL_RendererInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_RendererInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_RendererInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_RendererInfo>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RendererInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_RendererInfo>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RendererInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_RendererInfo>())).num_texture_formats as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RendererInfo),
            "::",
            stringify!(num_texture_formats)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_RendererInfo>())).texture_formats as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RendererInfo),
            "::",
            stringify!(texture_formats)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_RendererInfo>())).max_texture_width as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RendererInfo),
            "::",
            stringify!(max_texture_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_RendererInfo>())).max_texture_height as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RendererInfo),
            "::",
            stringify!(max_texture_height)
        )
    );
}
#[doc = "  Vertex structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Vertex {
    #[doc = "< Vertex position, in SDL_Renderer coordinates"]
    pub position: SDL_FPoint,
    #[doc = "< Vertex color"]
    pub color: SDL_Color,
    #[doc = "< Normalized texture coordinates, if needed"]
    pub tex_coord: SDL_FPoint,
}
#[test]
fn bindgen_test_layout_SDL_Vertex() {
    assert_eq!(
        ::core::mem::size_of::<SDL_Vertex>(),
        20usize,
        concat!("Size of: ", stringify!(SDL_Vertex))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_Vertex>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_Vertex))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Vertex>())).position as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Vertex),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Vertex>())).color as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Vertex),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Vertex>())).tex_coord as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Vertex),
            "::",
            stringify!(tex_coord)
        )
    );
}
#[repr(u32)]
#[doc = " The scaling mode for a texture."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_ScaleMode {
    #[doc = "< nearest pixel sampling"]
    SDL_ScaleModeNearest = 0,
    #[doc = "< linear filtering"]
    SDL_ScaleModeLinear = 1,
    #[doc = "< anisotropic filtering"]
    SDL_ScaleModeBest = 2,
}
#[repr(u32)]
#[doc = " The access pattern allowed for a texture."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_TextureAccess {
    #[doc = "< Changes rarely, not lockable"]
    SDL_TEXTUREACCESS_STATIC = 0,
    #[doc = "< Changes frequently, lockable"]
    SDL_TEXTUREACCESS_STREAMING = 1,
    #[doc = "< Texture can be used as a render target"]
    SDL_TEXTUREACCESS_TARGET = 2,
}
#[repr(u32)]
#[doc = " The texture channel modulation used in SDL_RenderCopy()."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_TextureModulate {
    #[doc = "< No modulation"]
    SDL_TEXTUREMODULATE_NONE = 0,
    #[doc = "< srcC = srcC * color"]
    SDL_TEXTUREMODULATE_COLOR = 1,
    #[doc = "< srcA = srcA * alpha"]
    SDL_TEXTUREMODULATE_ALPHA = 2,
}
#[repr(u32)]
#[doc = " Flip constants for SDL_RenderCopyEx"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_RendererFlip {
    #[doc = "< Do not flip"]
    SDL_FLIP_NONE = 0,
    #[doc = "< flip horizontally"]
    SDL_FLIP_HORIZONTAL = 1,
    #[doc = "< flip vertically"]
    SDL_FLIP_VERTICAL = 2,
}
#[doc = " A structure representing rendering state"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Renderer {
    _unused: [u8; 0],
}
#[doc = " An efficient driver-specific representation of pixel data"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Texture {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get the number of 2D rendering drivers available for the current display."]
    #[doc = ""]
    #[doc = " A render driver is a set of code that handles rendering and texture"]
    #[doc = " management on a particular display. Normally there is only one, but some"]
    #[doc = " drivers may have several available with different capabilities."]
    #[doc = ""]
    #[doc = " There may be none if SDL was compiled without render support."]
    #[doc = ""]
    #[doc = " \\returns a number >= 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateRenderer"]
    #[doc = " \\sa SDL_GetRenderDriverInfo"]
    pub fn SDL_GetNumRenderDrivers() -> libc::c_int;
}
extern "C" {
    #[doc = " Get info about a specific 2D rendering driver for the current display."]
    #[doc = ""]
    #[doc = " \\param index the index of the driver to query information about"]
    #[doc = " \\param info an SDL_RendererInfo structure to be filled with information on"]
    #[doc = "             the rendering driver"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateRenderer"]
    #[doc = " \\sa SDL_GetNumRenderDrivers"]
    pub fn SDL_GetRenderDriverInfo(index: libc::c_int, info: *mut SDL_RendererInfo) -> libc::c_int;
}
extern "C" {
    #[doc = " Create a window and default renderer."]
    #[doc = ""]
    #[doc = " \\param width the width of the window"]
    #[doc = " \\param height the height of the window"]
    #[doc = " \\param window_flags the flags used to create the window (see"]
    #[doc = "                     SDL_CreateWindow())"]
    #[doc = " \\param window a pointer filled with the window, or NULL on error"]
    #[doc = " \\param renderer a pointer filled with the renderer, or NULL on error"]
    #[doc = " \\returns 0 on success, or -1 on error; call SDL_GetError() for more"]
    #[doc = "          information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateRenderer"]
    #[doc = " \\sa SDL_CreateWindow"]
    pub fn SDL_CreateWindowAndRenderer(
        width: libc::c_int,
        height: libc::c_int,
        window_flags: Uint32,
        window: *mut *mut SDL_Window,
        renderer: *mut *mut SDL_Renderer,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Create a 2D rendering context for a window."]
    #[doc = ""]
    #[doc = " \\param window the window where rendering is displayed"]
    #[doc = " \\param index the index of the rendering driver to initialize, or -1 to"]
    #[doc = "              initialize the first one supporting the requested flags"]
    #[doc = " \\param flags 0, or one or more SDL_RendererFlags OR'd together"]
    #[doc = " \\returns a valid rendering context or NULL if there was an error; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateSoftwareRenderer"]
    #[doc = " \\sa SDL_DestroyRenderer"]
    #[doc = " \\sa SDL_GetNumRenderDrivers"]
    #[doc = " \\sa SDL_GetRendererInfo"]
    pub fn SDL_CreateRenderer(
        window: *mut SDL_Window,
        index: libc::c_int,
        flags: Uint32,
    ) -> *mut SDL_Renderer;
}
extern "C" {
    #[doc = " Create a 2D software rendering context for a surface."]
    #[doc = ""]
    #[doc = " Two other API which can be used to create SDL_Renderer:"]
    #[doc = " SDL_CreateRenderer() and SDL_CreateWindowAndRenderer(). These can _also_"]
    #[doc = " create a software renderer, but they are intended to be used with an"]
    #[doc = " SDL_Window as the final destination and not an SDL_Surface."]
    #[doc = ""]
    #[doc = " \\param surface the SDL_Surface structure representing the surface where"]
    #[doc = "                rendering is done"]
    #[doc = " \\returns a valid rendering context or NULL if there was an error; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateRenderer"]
    #[doc = " \\sa SDL_CreateWindowRenderer"]
    #[doc = " \\sa SDL_DestroyRenderer"]
    pub fn SDL_CreateSoftwareRenderer(surface: *mut SDL_Surface) -> *mut SDL_Renderer;
}
extern "C" {
    #[doc = " Get the renderer associated with a window."]
    #[doc = ""]
    #[doc = " \\param window the window to query"]
    #[doc = " \\returns the rendering context on success or NULL on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateRenderer"]
    pub fn SDL_GetRenderer(window: *mut SDL_Window) -> *mut SDL_Renderer;
}
extern "C" {
    #[doc = " Get information about a rendering context."]
    #[doc = ""]
    #[doc = " \\param renderer the rendering context"]
    #[doc = " \\param info an SDL_RendererInfo structure filled with information about the"]
    #[doc = "             current renderer"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateRenderer"]
    pub fn SDL_GetRendererInfo(
        renderer: *mut SDL_Renderer,
        info: *mut SDL_RendererInfo,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the output size in pixels of a rendering context."]
    #[doc = ""]
    #[doc = " Due to high-dpi displays, you might end up with a rendering context that"]
    #[doc = " has more pixels than the window that contains it, so use this instead of"]
    #[doc = " SDL_GetWindowSize() to decide how much drawing area you have."]
    #[doc = ""]
    #[doc = " \\param renderer the rendering context"]
    #[doc = " \\param w an int filled with the width"]
    #[doc = " \\param h an int filled with the height"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetRenderer"]
    pub fn SDL_GetRendererOutputSize(
        renderer: *mut SDL_Renderer,
        w: *mut libc::c_int,
        h: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Create a texture for a rendering context."]
    #[doc = ""]
    #[doc = " You can set the texture scaling method by setting"]
    #[doc = " `SDL_HINT_RENDER_SCALE_QUALITY` before creating the texture."]
    #[doc = ""]
    #[doc = " \\param renderer the rendering context"]
    #[doc = " \\param format one of the enumerated values in SDL_PixelFormatEnum"]
    #[doc = " \\param access one of the enumerated values in SDL_TextureAccess"]
    #[doc = " \\param w the width of the texture in pixels"]
    #[doc = " \\param h the height of the texture in pixels"]
    #[doc = " \\returns a pointer to the created texture or NULL if no rendering context"]
    #[doc = "          was active, the format was unsupported, or the width or height"]
    #[doc = "          were out of range; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateTextureFromSurface"]
    #[doc = " \\sa SDL_DestroyTexture"]
    #[doc = " \\sa SDL_QueryTexture"]
    #[doc = " \\sa SDL_UpdateTexture"]
    pub fn SDL_CreateTexture(
        renderer: *mut SDL_Renderer,
        format: Uint32,
        access: libc::c_int,
        w: libc::c_int,
        h: libc::c_int,
    ) -> *mut SDL_Texture;
}
extern "C" {
    #[doc = " Create a texture from an existing surface."]
    #[doc = ""]
    #[doc = " The surface is not modified or freed by this function."]
    #[doc = ""]
    #[doc = " The SDL_TextureAccess hint for the created texture is"]
    #[doc = " `SDL_TEXTUREACCESS_STATIC`."]
    #[doc = ""]
    #[doc = " The pixel format of the created texture may be different from the pixel"]
    #[doc = " format of the surface. Use SDL_QueryTexture() to query the pixel format of"]
    #[doc = " the texture."]
    #[doc = ""]
    #[doc = " \\param renderer the rendering context"]
    #[doc = " \\param surface the SDL_Surface structure containing pixel data used to fill"]
    #[doc = "                the texture"]
    #[doc = " \\returns the created texture or NULL on failure; call SDL_GetError() for"]
    #[doc = "          more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateTexture"]
    #[doc = " \\sa SDL_DestroyTexture"]
    #[doc = " \\sa SDL_QueryTexture"]
    pub fn SDL_CreateTextureFromSurface(
        renderer: *mut SDL_Renderer,
        surface: *mut SDL_Surface,
    ) -> *mut SDL_Texture;
}
extern "C" {
    #[doc = " Query the attributes of a texture."]
    #[doc = ""]
    #[doc = " \\param texture the texture to query"]
    #[doc = " \\param format a pointer filled in with the raw format of the texture; the"]
    #[doc = "               actual format may differ, but pixel transfers will use this"]
    #[doc = "               format (one of the SDL_PixelFormatEnum values)"]
    #[doc = " \\param access a pointer filled in with the actual access to the texture"]
    #[doc = "               (one of the SDL_TextureAccess values)"]
    #[doc = " \\param w a pointer filled in with the width of the texture in pixels"]
    #[doc = " \\param h a pointer filled in with the height of the texture in pixels"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateTexture"]
    pub fn SDL_QueryTexture(
        texture: *mut SDL_Texture,
        format: *mut Uint32,
        access: *mut libc::c_int,
        w: *mut libc::c_int,
        h: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set an additional color value multiplied into render copy operations."]
    #[doc = ""]
    #[doc = " When this texture is rendered, during the copy operation each source color"]
    #[doc = " channel is modulated by the appropriate color value according to the"]
    #[doc = " following formula:"]
    #[doc = ""]
    #[doc = " `srcC = srcC * (color / 255)`"]
    #[doc = ""]
    #[doc = " Color modulation is not always supported by the renderer; it will return -1"]
    #[doc = " if color modulation is not supported."]
    #[doc = ""]
    #[doc = " \\param texture the texture to update"]
    #[doc = " \\param r the red color value multiplied into copy operations"]
    #[doc = " \\param g the green color value multiplied into copy operations"]
    #[doc = " \\param b the blue color value multiplied into copy operations"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetTextureColorMod"]
    #[doc = " \\sa SDL_SetTextureAlphaMod"]
    pub fn SDL_SetTextureColorMod(
        texture: *mut SDL_Texture,
        r: Uint8,
        g: Uint8,
        b: Uint8,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the additional color value multiplied into render copy operations."]
    #[doc = ""]
    #[doc = " \\param texture the texture to query"]
    #[doc = " \\param r a pointer filled in with the current red color value"]
    #[doc = " \\param g a pointer filled in with the current green color value"]
    #[doc = " \\param b a pointer filled in with the current blue color value"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetTextureAlphaMod"]
    #[doc = " \\sa SDL_SetTextureColorMod"]
    pub fn SDL_GetTextureColorMod(
        texture: *mut SDL_Texture,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set an additional alpha value multiplied into render copy operations."]
    #[doc = ""]
    #[doc = " When this texture is rendered, during the copy operation the source alpha"]
    #[doc = " value is modulated by this alpha value according to the following formula:"]
    #[doc = ""]
    #[doc = " `srcA = srcA * (alpha / 255)`"]
    #[doc = ""]
    #[doc = " Alpha modulation is not always supported by the renderer; it will return -1"]
    #[doc = " if alpha modulation is not supported."]
    #[doc = ""]
    #[doc = " \\param texture the texture to update"]
    #[doc = " \\param alpha the source alpha value multiplied into copy operations"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetTextureAlphaMod"]
    #[doc = " \\sa SDL_SetTextureColorMod"]
    pub fn SDL_SetTextureAlphaMod(texture: *mut SDL_Texture, alpha: Uint8) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the additional alpha value multiplied into render copy operations."]
    #[doc = ""]
    #[doc = " \\param texture the texture to query"]
    #[doc = " \\param alpha a pointer filled in with the current alpha value"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetTextureColorMod"]
    #[doc = " \\sa SDL_SetTextureAlphaMod"]
    pub fn SDL_GetTextureAlphaMod(texture: *mut SDL_Texture, alpha: *mut Uint8) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the blend mode for a texture, used by SDL_RenderCopy()."]
    #[doc = ""]
    #[doc = " If the blend mode is not supported, the closest supported mode is chosen"]
    #[doc = " and this function returns -1."]
    #[doc = ""]
    #[doc = " \\param texture the texture to update"]
    #[doc = " \\param blendMode the SDL_BlendMode to use for texture blending"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetTextureBlendMode"]
    #[doc = " \\sa SDL_RenderCopy"]
    pub fn SDL_SetTextureBlendMode(
        texture: *mut SDL_Texture,
        blendMode: SDL_BlendMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the blend mode used for texture copy operations."]
    #[doc = ""]
    #[doc = " \\param texture the texture to query"]
    #[doc = " \\param blendMode a pointer filled in with the current SDL_BlendMode"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_SetTextureBlendMode"]
    pub fn SDL_GetTextureBlendMode(
        texture: *mut SDL_Texture,
        blendMode: *mut SDL_BlendMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the scale mode used for texture scale operations."]
    #[doc = ""]
    #[doc = " If the scale mode is not supported, the closest supported mode is chosen."]
    #[doc = ""]
    #[doc = " \\param texture The texture to update."]
    #[doc = " \\param scaleMode the SDL_ScaleMode to use for texture scaling."]
    #[doc = " \\returns 0 on success, or -1 if the texture is not valid."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.12."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetTextureScaleMode"]
    pub fn SDL_SetTextureScaleMode(
        texture: *mut SDL_Texture,
        scaleMode: SDL_ScaleMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the scale mode used for texture scale operations."]
    #[doc = ""]
    #[doc = " \\param texture the texture to query."]
    #[doc = " \\param scaleMode a pointer filled in with the current scale mode."]
    #[doc = " \\return 0 on success, or -1 if the texture is not valid."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.12."]
    #[doc = ""]
    #[doc = " \\sa SDL_SetTextureScaleMode"]
    pub fn SDL_GetTextureScaleMode(
        texture: *mut SDL_Texture,
        scaleMode: *mut SDL_ScaleMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Associate a user-specified pointer with a texture."]
    #[doc = ""]
    #[doc = " \\param texture the texture to update."]
    #[doc = " \\param userdata the pointer to associate with the texture."]
    #[doc = " \\returns 0 on success, or -1 if the texture is not valid."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetTextureUserData"]
    pub fn SDL_SetTextureUserData(
        texture: *mut SDL_Texture,
        userdata: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the user-specified pointer associated with a texture"]
    #[doc = ""]
    #[doc = " \\param texture the texture to query."]
    #[doc = " \\return the pointer associated with the texture, or NULL if the texture is"]
    #[doc = "         not valid."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    #[doc = ""]
    #[doc = " \\sa SDL_SetTextureUserData"]
    pub fn SDL_GetTextureUserData(texture: *mut SDL_Texture) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Update the given texture rectangle with new pixel data."]
    #[doc = ""]
    #[doc = " The pixel data must be in the pixel format of the texture. Use"]
    #[doc = " SDL_QueryTexture() to query the pixel format of the texture."]
    #[doc = ""]
    #[doc = " This is a fairly slow function, intended for use with static textures that"]
    #[doc = " do not change often."]
    #[doc = ""]
    #[doc = " If the texture is intended to be updated often, it is preferred to create"]
    #[doc = " the texture as streaming and use the locking functions referenced below."]
    #[doc = " While this function will work with streaming textures, for optimization"]
    #[doc = " reasons you may not get the pixels back if you lock the texture afterward."]
    #[doc = ""]
    #[doc = " \\param texture the texture to update"]
    #[doc = " \\param rect an SDL_Rect structure representing the area to update, or NULL"]
    #[doc = "             to update the entire texture"]
    #[doc = " \\param pixels the raw pixel data in the format of the texture"]
    #[doc = " \\param pitch the number of bytes in a row of pixel data, including padding"]
    #[doc = "              between lines"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateTexture"]
    #[doc = " \\sa SDL_LockTexture"]
    #[doc = " \\sa SDL_UnlockTexture"]
    pub fn SDL_UpdateTexture(
        texture: *mut SDL_Texture,
        rect: *const SDL_Rect,
        pixels: *const libc::c_void,
        pitch: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Update a rectangle within a planar YV12 or IYUV texture with new pixel"]
    #[doc = " data."]
    #[doc = ""]
    #[doc = " You can use SDL_UpdateTexture() as long as your pixel data is a contiguous"]
    #[doc = " block of Y and U/V planes in the proper order, but this function is"]
    #[doc = " available if your pixel data is not contiguous."]
    #[doc = ""]
    #[doc = " \\param texture the texture to update"]
    #[doc = " \\param rect a pointer to the rectangle of pixels to update, or NULL to"]
    #[doc = "             update the entire texture"]
    #[doc = " \\param Yplane the raw pixel data for the Y plane"]
    #[doc = " \\param Ypitch the number of bytes between rows of pixel data for the Y"]
    #[doc = "               plane"]
    #[doc = " \\param Uplane the raw pixel data for the U plane"]
    #[doc = " \\param Upitch the number of bytes between rows of pixel data for the U"]
    #[doc = "               plane"]
    #[doc = " \\param Vplane the raw pixel data for the V plane"]
    #[doc = " \\param Vpitch the number of bytes between rows of pixel data for the V"]
    #[doc = "               plane"]
    #[doc = " \\returns 0 on success or -1 if the texture is not valid; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.1."]
    #[doc = ""]
    #[doc = " \\sa SDL_UpdateTexture"]
    pub fn SDL_UpdateYUVTexture(
        texture: *mut SDL_Texture,
        rect: *const SDL_Rect,
        Yplane: *const Uint8,
        Ypitch: libc::c_int,
        Uplane: *const Uint8,
        Upitch: libc::c_int,
        Vplane: *const Uint8,
        Vpitch: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Update a rectangle within a planar NV12 or NV21 texture with new pixels."]
    #[doc = ""]
    #[doc = " You can use SDL_UpdateTexture() as long as your pixel data is a contiguous"]
    #[doc = " block of NV12/21 planes in the proper order, but this function is available"]
    #[doc = " if your pixel data is not contiguous."]
    #[doc = ""]
    #[doc = " \\param texture the texture to update"]
    #[doc = " \\param rect a pointer to the rectangle of pixels to update, or NULL to"]
    #[doc = "             update the entire texture."]
    #[doc = " \\param Yplane the raw pixel data for the Y plane."]
    #[doc = " \\param Ypitch the number of bytes between rows of pixel data for the Y"]
    #[doc = "               plane."]
    #[doc = " \\param UVplane the raw pixel data for the UV plane."]
    #[doc = " \\param UVpitch the number of bytes between rows of pixel data for the UV"]
    #[doc = "                plane."]
    #[doc = " \\return 0 on success, or -1 if the texture is not valid."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.16."]
    pub fn SDL_UpdateNVTexture(
        texture: *mut SDL_Texture,
        rect: *const SDL_Rect,
        Yplane: *const Uint8,
        Ypitch: libc::c_int,
        UVplane: *const Uint8,
        UVpitch: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Lock a portion of the texture for **write-only** pixel access."]
    #[doc = ""]
    #[doc = " As an optimization, the pixels made available for editing don't necessarily"]
    #[doc = " contain the old texture data. This is a write-only operation, and if you"]
    #[doc = " need to keep a copy of the texture data you should do that at the"]
    #[doc = " application level."]
    #[doc = ""]
    #[doc = " You must use SDL_UnlockTexture() to unlock the pixels and apply any"]
    #[doc = " changes."]
    #[doc = ""]
    #[doc = " \\param texture the texture to lock for access, which was created with"]
    #[doc = "                `SDL_TEXTUREACCESS_STREAMING`"]
    #[doc = " \\param rect an SDL_Rect structure representing the area to lock for access;"]
    #[doc = "             NULL to lock the entire texture"]
    #[doc = " \\param pixels this is filled in with a pointer to the locked pixels,"]
    #[doc = "               appropriately offset by the locked area"]
    #[doc = " \\param pitch this is filled in with the pitch of the locked pixels; the"]
    #[doc = "              pitch is the length of one row in bytes"]
    #[doc = " \\returns 0 on success or a negative error code if the texture is not valid"]
    #[doc = "          or was not created with `SDL_TEXTUREACCESS_STREAMING`; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_UnlockTexture"]
    pub fn SDL_LockTexture(
        texture: *mut SDL_Texture,
        rect: *const SDL_Rect,
        pixels: *mut *mut libc::c_void,
        pitch: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Lock a portion of the texture for **write-only** pixel access, and expose"]
    #[doc = " it as a SDL surface."]
    #[doc = ""]
    #[doc = " Besides providing an SDL_Surface instead of raw pixel data, this function"]
    #[doc = " operates like SDL_LockTexture."]
    #[doc = ""]
    #[doc = " As an optimization, the pixels made available for editing don't necessarily"]
    #[doc = " contain the old texture data. This is a write-only operation, and if you"]
    #[doc = " need to keep a copy of the texture data you should do that at the"]
    #[doc = " application level."]
    #[doc = ""]
    #[doc = " You must use SDL_UnlockTexture() to unlock the pixels and apply any"]
    #[doc = " changes."]
    #[doc = ""]
    #[doc = " The returned surface is freed internally after calling SDL_UnlockTexture()"]
    #[doc = " or SDL_DestroyTexture(). The caller should not free it."]
    #[doc = ""]
    #[doc = " \\param texture the texture to lock for access, which was created with"]
    #[doc = "                `SDL_TEXTUREACCESS_STREAMING`"]
    #[doc = " \\param rect a pointer to the rectangle to lock for access. If the rect is"]
    #[doc = "             NULL, the entire texture will be locked"]
    #[doc = " \\param surface this is filled in with an SDL surface representing the"]
    #[doc = "                locked area"]
    #[doc = " \\returns 0 on success, or -1 if the texture is not valid or was not created"]
    #[doc = "          with `SDL_TEXTUREACCESS_STREAMING`"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.12."]
    #[doc = ""]
    #[doc = " \\sa SDL_LockTexture"]
    #[doc = " \\sa SDL_UnlockTexture"]
    pub fn SDL_LockTextureToSurface(
        texture: *mut SDL_Texture,
        rect: *const SDL_Rect,
        surface: *mut *mut SDL_Surface,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Unlock a texture, uploading the changes to video memory, if needed."]
    #[doc = ""]
    #[doc = " **Warning**: Please note that SDL_LockTexture() is intended to be"]
    #[doc = " write-only; it will not guarantee the previous contents of the texture will"]
    #[doc = " be provided. You must fully initialize any area of a texture that you lock"]
    #[doc = " before unlocking it, as the pixels might otherwise be uninitialized memory."]
    #[doc = ""]
    #[doc = " Which is to say: locking and immediately unlocking a texture can result in"]
    #[doc = " corrupted textures, depending on the renderer in use."]
    #[doc = ""]
    #[doc = " \\param texture a texture locked by SDL_LockTexture()"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_LockTexture"]
    pub fn SDL_UnlockTexture(texture: *mut SDL_Texture);
}
extern "C" {
    #[doc = " Determine whether a renderer supports the use of render targets."]
    #[doc = ""]
    #[doc = " \\param renderer the renderer that will be checked"]
    #[doc = " \\returns SDL_TRUE if supported or SDL_FALSE if not."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_SetRenderTarget"]
    pub fn SDL_RenderTargetSupported(renderer: *mut SDL_Renderer) -> SDL_bool;
}
extern "C" {
    #[doc = " Set a texture as the current rendering target."]
    #[doc = ""]
    #[doc = " Before using this function, you should check the"]
    #[doc = " `SDL_RENDERER_TARGETTEXTURE` bit in the flags of SDL_RendererInfo to see if"]
    #[doc = " render targets are supported."]
    #[doc = ""]
    #[doc = " The default render target is the window for which the renderer was created."]
    #[doc = " To stop rendering to a texture and render to the window again, call this"]
    #[doc = " function with a NULL `texture`."]
    #[doc = ""]
    #[doc = " \\param renderer the rendering context"]
    #[doc = " \\param texture the targeted texture, which must be created with the"]
    #[doc = "                `SDL_TEXTUREACCESS_TARGET` flag, or NULL to render to the"]
    #[doc = "                window instead of a texture."]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetRenderTarget"]
    pub fn SDL_SetRenderTarget(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the current render target."]
    #[doc = ""]
    #[doc = " The default render target is the window for which the renderer was created,"]
    #[doc = " and is reported a NULL here."]
    #[doc = ""]
    #[doc = " \\param renderer the rendering context"]
    #[doc = " \\returns the current render target or NULL for the default render target."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_SetRenderTarget"]
    pub fn SDL_GetRenderTarget(renderer: *mut SDL_Renderer) -> *mut SDL_Texture;
}
extern "C" {
    #[doc = " Set a device independent resolution for rendering."]
    #[doc = ""]
    #[doc = " This function uses the viewport and scaling functionality to allow a fixed"]
    #[doc = " logical resolution for rendering, regardless of the actual output"]
    #[doc = " resolution. If the actual output resolution doesn't have the same aspect"]
    #[doc = " ratio the output rendering will be centered within the output display."]
    #[doc = ""]
    #[doc = " If the output display is a window, mouse and touch events in the window"]
    #[doc = " will be filtered and scaled so they seem to arrive within the logical"]
    #[doc = " resolution. The SDL_HINT_MOUSE_RELATIVE_SCALING hint controls whether"]
    #[doc = " relative motion events are also scaled."]
    #[doc = ""]
    #[doc = " If this function results in scaling or subpixel drawing by the rendering"]
    #[doc = " backend, it will be handled using the appropriate quality hints."]
    #[doc = ""]
    #[doc = " \\param renderer the renderer for which resolution should be set"]
    #[doc = " \\param w the width of the logical resolution"]
    #[doc = " \\param h the height of the logical resolution"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_RenderGetLogicalSize"]
    pub fn SDL_RenderSetLogicalSize(
        renderer: *mut SDL_Renderer,
        w: libc::c_int,
        h: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get device independent resolution for rendering."]
    #[doc = ""]
    #[doc = " This may return 0 for `w` and `h` if the SDL_Renderer has never had its"]
    #[doc = " logical size set by SDL_RenderSetLogicalSize() and never had a render"]
    #[doc = " target set."]
    #[doc = ""]
    #[doc = " \\param renderer a rendering context"]
    #[doc = " \\param w an int to be filled with the width"]
    #[doc = " \\param h an int to be filled with the height"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_RenderSetLogicalSize"]
    pub fn SDL_RenderGetLogicalSize(
        renderer: *mut SDL_Renderer,
        w: *mut libc::c_int,
        h: *mut libc::c_int,
    );
}
extern "C" {
    #[doc = " Set whether to force integer scales for resolution-independent rendering."]
    #[doc = ""]
    #[doc = " This function restricts the logical viewport to integer values - that is,"]
    #[doc = " when a resolution is between two multiples of a logical size, the viewport"]
    #[doc = " size is rounded down to the lower multiple."]
    #[doc = ""]
    #[doc = " \\param renderer the renderer for which integer scaling should be set"]
    #[doc = " \\param enable enable or disable the integer scaling for rendering"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.5."]
    #[doc = ""]
    #[doc = " \\sa SDL_RenderGetIntegerScale"]
    #[doc = " \\sa SDL_RenderSetLogicalSize"]
    pub fn SDL_RenderSetIntegerScale(renderer: *mut SDL_Renderer, enable: SDL_bool) -> libc::c_int;
}
extern "C" {
    #[doc = " Get whether integer scales are forced for resolution-independent rendering."]
    #[doc = ""]
    #[doc = " \\param renderer the renderer from which integer scaling should be queried"]
    #[doc = " \\returns SDL_TRUE if integer scales are forced or SDL_FALSE if not and on"]
    #[doc = "          failure; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.5."]
    #[doc = ""]
    #[doc = " \\sa SDL_RenderSetIntegerScale"]
    pub fn SDL_RenderGetIntegerScale(renderer: *mut SDL_Renderer) -> SDL_bool;
}
extern "C" {
    #[doc = " Set the drawing area for rendering on the current target."]
    #[doc = ""]
    #[doc = " When the window is resized, the viewport is reset to fill the entire new"]
    #[doc = " window size."]
    #[doc = ""]
    #[doc = " \\param renderer the rendering context"]
    #[doc = " \\param rect the SDL_Rect structure representing the drawing area, or NULL"]
    #[doc = "             to set the viewport to the entire target"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_RenderGetViewport"]
    pub fn SDL_RenderSetViewport(renderer: *mut SDL_Renderer, rect: *const SDL_Rect)
        -> libc::c_int;
}
extern "C" {
    #[doc = " Get the drawing area for the current target."]
    #[doc = ""]
    #[doc = " \\param renderer the rendering context"]
    #[doc = " \\param rect an SDL_Rect structure filled in with the current drawing area"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_RenderSetViewport"]
    pub fn SDL_RenderGetViewport(renderer: *mut SDL_Renderer, rect: *mut SDL_Rect);
}
extern "C" {
    #[doc = " Set the clip rectangle for rendering on the specified target."]
    #[doc = ""]
    #[doc = " \\param renderer the rendering context for which clip rectangle should be"]
    #[doc = "                 set"]
    #[doc = " \\param rect an SDL_Rect structure representing the clip area, relative to"]
    #[doc = "             the viewport, or NULL to disable clipping"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_RenderGetClipRect"]
    #[doc = " \\sa SDL_RenderIsClipEnabled"]
    pub fn SDL_RenderSetClipRect(renderer: *mut SDL_Renderer, rect: *const SDL_Rect)
        -> libc::c_int;
}
extern "C" {
    #[doc = " Get the clip rectangle for the current target."]
    #[doc = ""]
    #[doc = " \\param renderer the rendering context from which clip rectangle should be"]
    #[doc = "                 queried"]
    #[doc = " \\param rect an SDL_Rect structure filled in with the current clipping area"]
    #[doc = "             or an empty rectangle if clipping is disabled"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_RenderIsClipEnabled"]
    #[doc = " \\sa SDL_RenderSetClipRect"]
    pub fn SDL_RenderGetClipRect(renderer: *mut SDL_Renderer, rect: *mut SDL_Rect);
}
extern "C" {
    #[doc = " Get whether clipping is enabled on the given renderer."]
    #[doc = ""]
    #[doc = " \\param renderer the renderer from which clip state should be queried"]
    #[doc = " \\returns SDL_TRUE if clipping is enabled or SDL_FALSE if not; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.4."]
    #[doc = ""]
    #[doc = " \\sa SDL_RenderGetClipRect"]
    #[doc = " \\sa SDL_RenderSetClipRect"]
    pub fn SDL_RenderIsClipEnabled(renderer: *mut SDL_Renderer) -> SDL_bool;
}
extern "C" {
    #[doc = " Set the drawing scale for rendering on the current target."]
    #[doc = ""]
    #[doc = " The drawing coordinates are scaled by the x/y scaling factors before they"]
    #[doc = " are used by the renderer. This allows resolution independent drawing with a"]
    #[doc = " single coordinate system."]
    #[doc = ""]
    #[doc = " If this results in scaling or subpixel drawing by the rendering backend, it"]
    #[doc = " will be handled using the appropriate quality hints. For best results use"]
    #[doc = " integer scaling factors."]
    #[doc = ""]
    #[doc = " \\param renderer a rendering context"]
    #[doc = " \\param scaleX the horizontal scaling factor"]
    #[doc = " \\param scaleY the vertical scaling factor"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_RenderGetScale"]
    #[doc = " \\sa SDL_RenderSetLogicalSize"]
    pub fn SDL_RenderSetScale(renderer: *mut SDL_Renderer, scaleX: f32, scaleY: f32)
        -> libc::c_int;
}
extern "C" {
    #[doc = " Get the drawing scale for the current target."]
    #[doc = ""]
    #[doc = " \\param renderer the renderer from which drawing scale should be queried"]
    #[doc = " \\param scaleX a pointer filled in with the horizontal scaling factor"]
    #[doc = " \\param scaleY a pointer filled in with the vertical scaling factor"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_RenderSetScale"]
    pub fn SDL_RenderGetScale(renderer: *mut SDL_Renderer, scaleX: *mut f32, scaleY: *mut f32);
}
extern "C" {
    #[doc = " Get logical coordinates of point in renderer when given real coordinates of"]
    #[doc = " point in window."]
    #[doc = ""]
    #[doc = " Logical coordinates will differ from real coordinates when render is scaled"]
    #[doc = " and logical renderer size set"]
    #[doc = ""]
    #[doc = " \\param renderer the renderer from which the logical coordinates should be"]
    #[doc = "                 calcualted"]
    #[doc = " \\param windowX the real X coordinate in the window"]
    #[doc = " \\param windowY the real Y coordinate in the window"]
    #[doc = " \\param logicalX the pointer filled with the logical x coordinate"]
    #[doc = " \\param logicalY the pointer filled with the logical y coordinate"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    #[doc = ""]
    #[doc = " \\sa SDL_RenderGetScale"]
    #[doc = " \\sa SDL_RenderSetScale"]
    #[doc = " \\sa SDL_RenderGetLogicalSize"]
    #[doc = " \\sa SDL_RenderSetLogicalSize"]
    pub fn SDL_RenderWindowToLogical(
        renderer: *mut SDL_Renderer,
        windowX: libc::c_int,
        windowY: libc::c_int,
        logicalX: *mut f32,
        logicalY: *mut f32,
    );
}
extern "C" {
    #[doc = " Get real coordinates of point in window when given logical coordinates of point in renderer."]
    #[doc = " Logical coordinates will differ from real coordinates when render is scaled and logical renderer size set"]
    #[doc = ""]
    #[doc = " \\param renderer the renderer from which the window coordinates should be calculated"]
    #[doc = " \\param logicalX the logical x coordinate"]
    #[doc = " \\param logicalY the logical y coordinate"]
    #[doc = " \\param windowX the pointer filled with the real X coordinate in the window"]
    #[doc = " \\param windowY the pointer filled with the real Y coordinate in the window"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    #[doc = ""]
    #[doc = " \\sa SDL_RenderGetScale"]
    #[doc = " \\sa SDL_RenderSetScale"]
    #[doc = " \\sa SDL_RenderGetLogicalSize"]
    #[doc = " \\sa SDL_RenderSetLogicalSize"]
    pub fn SDL_RenderLogicalToWindow(
        renderer: *mut SDL_Renderer,
        logicalX: f32,
        logicalY: f32,
        windowX: *mut libc::c_int,
        windowY: *mut libc::c_int,
    );
}
extern "C" {
    #[doc = " Set the color used for drawing operations (Rect, Line and Clear)."]
    #[doc = ""]
    #[doc = " Set the color for drawing or filling rectangles, lines, and points, and for"]
    #[doc = " SDL_RenderClear()."]
    #[doc = ""]
    #[doc = " \\param renderer the rendering context"]
    #[doc = " \\param r the red value used to draw on the rendering target"]
    #[doc = " \\param g the green value used to draw on the rendering target"]
    #[doc = " \\param b the blue value used to draw on the rendering target"]
    #[doc = " \\param a the alpha value used to draw on the rendering target; usually"]
    #[doc = "          `SDL_ALPHA_OPAQUE` (255). Use SDL_SetRenderDrawBlendMode to"]
    #[doc = "          specify how the alpha channel is used"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetRenderDrawColor"]
    #[doc = " \\sa SDL_RenderClear"]
    #[doc = " \\sa SDL_RenderDrawLine"]
    #[doc = " \\sa SDL_RenderDrawLines"]
    #[doc = " \\sa SDL_RenderDrawPoint"]
    #[doc = " \\sa SDL_RenderDrawPoints"]
    #[doc = " \\sa SDL_RenderDrawRect"]
    #[doc = " \\sa SDL_RenderDrawRects"]
    #[doc = " \\sa SDL_RenderFillRect"]
    #[doc = " \\sa SDL_RenderFillRects"]
    pub fn SDL_SetRenderDrawColor(
        renderer: *mut SDL_Renderer,
        r: Uint8,
        g: Uint8,
        b: Uint8,
        a: Uint8,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the color used for drawing operations (Rect, Line and Clear)."]
    #[doc = ""]
    #[doc = " \\param renderer the rendering context"]
    #[doc = " \\param r a pointer filled in with the red value used to draw on the"]
    #[doc = "          rendering target"]
    #[doc = " \\param g a pointer filled in with the green value used to draw on the"]
    #[doc = "          rendering target"]
    #[doc = " \\param b a pointer filled in with the blue value used to draw on the"]
    #[doc = "          rendering target"]
    #[doc = " \\param a a pointer filled in with the alpha value used to draw on the"]
    #[doc = "          rendering target; usually `SDL_ALPHA_OPAQUE` (255)"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_SetRenderDrawColor"]
    pub fn SDL_GetRenderDrawColor(
        renderer: *mut SDL_Renderer,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
        a: *mut Uint8,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the blend mode used for drawing operations (Fill and Line)."]
    #[doc = ""]
    #[doc = " If the blend mode is not supported, the closest supported mode is chosen."]
    #[doc = ""]
    #[doc = " \\param renderer the rendering context"]
    #[doc = " \\param blendMode the SDL_BlendMode to use for blending"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetRenderDrawBlendMode"]
    #[doc = " \\sa SDL_RenderDrawLine"]
    #[doc = " \\sa SDL_RenderDrawLines"]
    #[doc = " \\sa SDL_RenderDrawPoint"]
    #[doc = " \\sa SDL_RenderDrawPoints"]
    #[doc = " \\sa SDL_RenderDrawRect"]
    #[doc = " \\sa SDL_RenderDrawRects"]
    #[doc = " \\sa SDL_RenderFillRect"]
    #[doc = " \\sa SDL_RenderFillRects"]
    pub fn SDL_SetRenderDrawBlendMode(
        renderer: *mut SDL_Renderer,
        blendMode: SDL_BlendMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the blend mode used for drawing operations."]
    #[doc = ""]
    #[doc = " \\param renderer the rendering context"]
    #[doc = " \\param blendMode a pointer filled in with the current SDL_BlendMode"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_SetRenderDrawBlendMode"]
    pub fn SDL_GetRenderDrawBlendMode(
        renderer: *mut SDL_Renderer,
        blendMode: *mut SDL_BlendMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Clear the current rendering target with the drawing color."]
    #[doc = ""]
    #[doc = " This function clears the entire rendering target, ignoring the viewport and"]
    #[doc = " the clip rectangle."]
    #[doc = ""]
    #[doc = " \\param renderer the rendering context"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_SetRenderDrawColor"]
    pub fn SDL_RenderClear(renderer: *mut SDL_Renderer) -> libc::c_int;
}
extern "C" {
    #[doc = " Draw a point on the current rendering target."]
    #[doc = ""]
    #[doc = " SDL_RenderDrawPoint() draws a single point. If you want to draw multiple,"]
    #[doc = " use SDL_RenderDrawPoints() instead."]
    #[doc = ""]
    #[doc = " \\param renderer the rendering context"]
    #[doc = " \\param x the x coordinate of the point"]
    #[doc = " \\param y the y coordinate of the point"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_RenderDrawLine"]
    #[doc = " \\sa SDL_RenderDrawLines"]
    #[doc = " \\sa SDL_RenderDrawPoints"]
    #[doc = " \\sa SDL_RenderDrawRect"]
    #[doc = " \\sa SDL_RenderDrawRects"]
    #[doc = " \\sa SDL_RenderFillRect"]
    #[doc = " \\sa SDL_RenderFillRects"]
    #[doc = " \\sa SDL_RenderPresent"]
    #[doc = " \\sa SDL_SetRenderDrawBlendMode"]
    #[doc = " \\sa SDL_SetRenderDrawColor"]
    pub fn SDL_RenderDrawPoint(
        renderer: *mut SDL_Renderer,
        x: libc::c_int,
        y: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Draw multiple points on the current rendering target."]
    #[doc = ""]
    #[doc = " \\param renderer the rendering context"]
    #[doc = " \\param points an array of SDL_Point structures that represent the points to"]
    #[doc = "               draw"]
    #[doc = " \\param count the number of points to draw"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_RenderDrawLine"]
    #[doc = " \\sa SDL_RenderDrawLines"]
    #[doc = " \\sa SDL_RenderDrawPoint"]
    #[doc = " \\sa SDL_RenderDrawRect"]
    #[doc = " \\sa SDL_RenderDrawRects"]
    #[doc = " \\sa SDL_RenderFillRect"]
    #[doc = " \\sa SDL_RenderFillRects"]
    #[doc = " \\sa SDL_RenderPresent"]
    #[doc = " \\sa SDL_SetRenderDrawBlendMode"]
    #[doc = " \\sa SDL_SetRenderDrawColor"]
    pub fn SDL_RenderDrawPoints(
        renderer: *mut SDL_Renderer,
        points: *const SDL_Point,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Draw a line on the current rendering target."]
    #[doc = ""]
    #[doc = " SDL_RenderDrawLine() draws the line to include both end points. If you want"]
    #[doc = " to draw multiple, connecting lines use SDL_RenderDrawLines() instead."]
    #[doc = ""]
    #[doc = " \\param renderer the rendering context"]
    #[doc = " \\param x1 the x coordinate of the start point"]
    #[doc = " \\param y1 the y coordinate of the start point"]
    #[doc = " \\param x2 the x coordinate of the end point"]
    #[doc = " \\param y2 the y coordinate of the end point"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_RenderDrawLines"]
    #[doc = " \\sa SDL_RenderDrawPoint"]
    #[doc = " \\sa SDL_RenderDrawPoints"]
    #[doc = " \\sa SDL_RenderDrawRect"]
    #[doc = " \\sa SDL_RenderDrawRects"]
    #[doc = " \\sa SDL_RenderFillRect"]
    #[doc = " \\sa SDL_RenderFillRects"]
    #[doc = " \\sa SDL_RenderPresent"]
    #[doc = " \\sa SDL_SetRenderDrawBlendMode"]
    #[doc = " \\sa SDL_SetRenderDrawColor"]
    pub fn SDL_RenderDrawLine(
        renderer: *mut SDL_Renderer,
        x1: libc::c_int,
        y1: libc::c_int,
        x2: libc::c_int,
        y2: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Draw a series of connected lines on the current rendering target."]
    #[doc = ""]
    #[doc = " \\param renderer the rendering context"]
    #[doc = " \\param points an array of SDL_Point structures representing points along"]
    #[doc = "               the lines"]
    #[doc = " \\param count the number of points, drawing count-1 lines"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_RenderDrawLine"]
    #[doc = " \\sa SDL_RenderDrawPoint"]
    #[doc = " \\sa SDL_RenderDrawPoints"]
    #[doc = " \\sa SDL_RenderDrawRect"]
    #[doc = " \\sa SDL_RenderDrawRects"]
    #[doc = " \\sa SDL_RenderFillRect"]
    #[doc = " \\sa SDL_RenderFillRects"]
    #[doc = " \\sa SDL_RenderPresent"]
    #[doc = " \\sa SDL_SetRenderDrawBlendMode"]
    #[doc = " \\sa SDL_SetRenderDrawColor"]
    pub fn SDL_RenderDrawLines(
        renderer: *mut SDL_Renderer,
        points: *const SDL_Point,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Draw a rectangle on the current rendering target."]
    #[doc = ""]
    #[doc = " \\param renderer the rendering context"]
    #[doc = " \\param rect an SDL_Rect structure representing the rectangle to draw, or"]
    #[doc = "             NULL to outline the entire rendering target"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_RenderDrawLine"]
    #[doc = " \\sa SDL_RenderDrawLines"]
    #[doc = " \\sa SDL_RenderDrawPoint"]
    #[doc = " \\sa SDL_RenderDrawPoints"]
    #[doc = " \\sa SDL_RenderDrawRects"]
    #[doc = " \\sa SDL_RenderFillRect"]
    #[doc = " \\sa SDL_RenderFillRects"]
    #[doc = " \\sa SDL_RenderPresent"]
    #[doc = " \\sa SDL_SetRenderDrawBlendMode"]
    #[doc = " \\sa SDL_SetRenderDrawColor"]
    pub fn SDL_RenderDrawRect(renderer: *mut SDL_Renderer, rect: *const SDL_Rect) -> libc::c_int;
}
extern "C" {
    #[doc = " Draw some number of rectangles on the current rendering target."]
    #[doc = ""]
    #[doc = " \\param renderer the rendering context"]
    #[doc = " \\param rects an array of SDL_Rect structures representing the rectangles to"]
    #[doc = "              be drawn"]
    #[doc = " \\param count the number of rectangles"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_RenderDrawLine"]
    #[doc = " \\sa SDL_RenderDrawLines"]
    #[doc = " \\sa SDL_RenderDrawPoint"]
    #[doc = " \\sa SDL_RenderDrawPoints"]
    #[doc = " \\sa SDL_RenderDrawRect"]
    #[doc = " \\sa SDL_RenderFillRect"]
    #[doc = " \\sa SDL_RenderFillRects"]
    #[doc = " \\sa SDL_RenderPresent"]
    #[doc = " \\sa SDL_SetRenderDrawBlendMode"]
    #[doc = " \\sa SDL_SetRenderDrawColor"]
    pub fn SDL_RenderDrawRects(
        renderer: *mut SDL_Renderer,
        rects: *const SDL_Rect,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Fill a rectangle on the current rendering target with the drawing color."]
    #[doc = ""]
    #[doc = " The current drawing color is set by SDL_SetRenderDrawColor(), and the"]
    #[doc = " color's alpha value is ignored unless blending is enabled with the"]
    #[doc = " appropriate call to SDL_SetRenderDrawBlendMode()."]
    #[doc = ""]
    #[doc = " \\param renderer the rendering context"]
    #[doc = " \\param rect the SDL_Rect structure representing the rectangle to fill, or"]
    #[doc = "             NULL for the entire rendering target"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_RenderDrawLine"]
    #[doc = " \\sa SDL_RenderDrawLines"]
    #[doc = " \\sa SDL_RenderDrawPoint"]
    #[doc = " \\sa SDL_RenderDrawPoints"]
    #[doc = " \\sa SDL_RenderDrawRect"]
    #[doc = " \\sa SDL_RenderDrawRects"]
    #[doc = " \\sa SDL_RenderFillRects"]
    #[doc = " \\sa SDL_RenderPresent"]
    #[doc = " \\sa SDL_SetRenderDrawBlendMode"]
    #[doc = " \\sa SDL_SetRenderDrawColor"]
    pub fn SDL_RenderFillRect(renderer: *mut SDL_Renderer, rect: *const SDL_Rect) -> libc::c_int;
}
extern "C" {
    #[doc = " Fill some number of rectangles on the current rendering target with the"]
    #[doc = " drawing color."]
    #[doc = ""]
    #[doc = " \\param renderer the rendering context"]
    #[doc = " \\param rects an array of SDL_Rect structures representing the rectangles to"]
    #[doc = "              be filled"]
    #[doc = " \\param count the number of rectangles"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_RenderDrawLine"]
    #[doc = " \\sa SDL_RenderDrawLines"]
    #[doc = " \\sa SDL_RenderDrawPoint"]
    #[doc = " \\sa SDL_RenderDrawPoints"]
    #[doc = " \\sa SDL_RenderDrawRect"]
    #[doc = " \\sa SDL_RenderDrawRects"]
    #[doc = " \\sa SDL_RenderFillRect"]
    #[doc = " \\sa SDL_RenderPresent"]
    pub fn SDL_RenderFillRects(
        renderer: *mut SDL_Renderer,
        rects: *const SDL_Rect,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Copy a portion of the texture to the current rendering target."]
    #[doc = ""]
    #[doc = " The texture is blended with the destination based on its blend mode set"]
    #[doc = " with SDL_SetTextureBlendMode()."]
    #[doc = ""]
    #[doc = " The texture color is affected based on its color modulation set by"]
    #[doc = " SDL_SetTextureColorMod()."]
    #[doc = ""]
    #[doc = " The texture alpha is affected based on its alpha modulation set by"]
    #[doc = " SDL_SetTextureAlphaMod()."]
    #[doc = ""]
    #[doc = " \\param renderer the rendering context"]
    #[doc = " \\param texture the source texture"]
    #[doc = " \\param srcrect the source SDL_Rect structure or NULL for the entire texture"]
    #[doc = " \\param dstrect the destination SDL_Rect structure or NULL for the entire"]
    #[doc = "                rendering target; the texture will be stretched to fill the"]
    #[doc = "                given rectangle"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_RenderCopyEx"]
    #[doc = " \\sa SDL_SetTextureAlphaMod"]
    #[doc = " \\sa SDL_SetTextureBlendMode"]
    #[doc = " \\sa SDL_SetTextureColorMod"]
    pub fn SDL_RenderCopy(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
        srcrect: *const SDL_Rect,
        dstrect: *const SDL_Rect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Copy a portion of the texture to the current rendering, with optional"]
    #[doc = " rotation and flipping."]
    #[doc = ""]
    #[doc = " Copy a portion of the texture to the current rendering target, optionally"]
    #[doc = " rotating it by angle around the given center and also flipping it"]
    #[doc = " top-bottom and/or left-right."]
    #[doc = ""]
    #[doc = " The texture is blended with the destination based on its blend mode set"]
    #[doc = " with SDL_SetTextureBlendMode()."]
    #[doc = ""]
    #[doc = " The texture color is affected based on its color modulation set by"]
    #[doc = " SDL_SetTextureColorMod()."]
    #[doc = ""]
    #[doc = " The texture alpha is affected based on its alpha modulation set by"]
    #[doc = " SDL_SetTextureAlphaMod()."]
    #[doc = ""]
    #[doc = " \\param renderer the rendering context"]
    #[doc = " \\param texture the source texture"]
    #[doc = " \\param srcrect the source SDL_Rect structure or NULL for the entire texture"]
    #[doc = " \\param dstrect the destination SDL_Rect structure or NULL for the entire"]
    #[doc = "                rendering target"]
    #[doc = " \\param angle an angle in degrees that indicates the rotation that will be"]
    #[doc = "              applied to dstrect, rotating it in a clockwise direction"]
    #[doc = " \\param center a pointer to a point indicating the point around which"]
    #[doc = "               dstrect will be rotated (if NULL, rotation will be done"]
    #[doc = "               around `dstrect.w / 2`, `dstrect.h / 2`)"]
    #[doc = " \\param flip a SDL_RendererFlip value stating which flipping actions should"]
    #[doc = "             be performed on the texture"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_RenderCopy"]
    #[doc = " \\sa SDL_SetTextureAlphaMod"]
    #[doc = " \\sa SDL_SetTextureBlendMode"]
    #[doc = " \\sa SDL_SetTextureColorMod"]
    pub fn SDL_RenderCopyEx(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
        srcrect: *const SDL_Rect,
        dstrect: *const SDL_Rect,
        angle: f64,
        center: *const SDL_Point,
        flip: SDL_RendererFlip,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Draw a point on the current rendering target at subpixel precision."]
    #[doc = ""]
    #[doc = " \\param renderer The renderer which should draw a point."]
    #[doc = " \\param x The x coordinate of the point."]
    #[doc = " \\param y The y coordinate of the point."]
    #[doc = " \\return 0 on success, or -1 on error"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.10."]
    pub fn SDL_RenderDrawPointF(renderer: *mut SDL_Renderer, x: f32, y: f32) -> libc::c_int;
}
extern "C" {
    #[doc = " Draw multiple points on the current rendering target at subpixel precision."]
    #[doc = ""]
    #[doc = " \\param renderer The renderer which should draw multiple points."]
    #[doc = " \\param points The points to draw"]
    #[doc = " \\param count The number of points to draw"]
    #[doc = " \\return 0 on success, or -1 on error"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.10."]
    pub fn SDL_RenderDrawPointsF(
        renderer: *mut SDL_Renderer,
        points: *const SDL_FPoint,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Draw a line on the current rendering target at subpixel precision."]
    #[doc = ""]
    #[doc = " \\param renderer The renderer which should draw a line."]
    #[doc = " \\param x1 The x coordinate of the start point."]
    #[doc = " \\param y1 The y coordinate of the start point."]
    #[doc = " \\param x2 The x coordinate of the end point."]
    #[doc = " \\param y2 The y coordinate of the end point."]
    #[doc = " \\return 0 on success, or -1 on error"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.10."]
    pub fn SDL_RenderDrawLineF(
        renderer: *mut SDL_Renderer,
        x1: f32,
        y1: f32,
        x2: f32,
        y2: f32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Draw a series of connected lines on the current rendering target at"]
    #[doc = " subpixel precision."]
    #[doc = ""]
    #[doc = " \\param renderer The renderer which should draw multiple lines."]
    #[doc = " \\param points The points along the lines"]
    #[doc = " \\param count The number of points, drawing count-1 lines"]
    #[doc = " \\return 0 on success, or -1 on error"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.10."]
    pub fn SDL_RenderDrawLinesF(
        renderer: *mut SDL_Renderer,
        points: *const SDL_FPoint,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Draw a rectangle on the current rendering target at subpixel precision."]
    #[doc = ""]
    #[doc = " \\param renderer The renderer which should draw a rectangle."]
    #[doc = " \\param rect A pointer to the destination rectangle, or NULL to outline the"]
    #[doc = "             entire rendering target."]
    #[doc = " \\return 0 on success, or -1 on error"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.10."]
    pub fn SDL_RenderDrawRectF(renderer: *mut SDL_Renderer, rect: *const SDL_FRect) -> libc::c_int;
}
extern "C" {
    #[doc = " Draw some number of rectangles on the current rendering target at subpixel"]
    #[doc = " precision."]
    #[doc = ""]
    #[doc = " \\param renderer The renderer which should draw multiple rectangles."]
    #[doc = " \\param rects A pointer to an array of destination rectangles."]
    #[doc = " \\param count The number of rectangles."]
    #[doc = " \\return 0 on success, or -1 on error"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.10."]
    pub fn SDL_RenderDrawRectsF(
        renderer: *mut SDL_Renderer,
        rects: *const SDL_FRect,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Fill a rectangle on the current rendering target with the drawing color at"]
    #[doc = " subpixel precision."]
    #[doc = ""]
    #[doc = " \\param renderer The renderer which should fill a rectangle."]
    #[doc = " \\param rect A pointer to the destination rectangle, or NULL for the entire"]
    #[doc = "             rendering target."]
    #[doc = " \\return 0 on success, or -1 on error"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.10."]
    pub fn SDL_RenderFillRectF(renderer: *mut SDL_Renderer, rect: *const SDL_FRect) -> libc::c_int;
}
extern "C" {
    #[doc = " Fill some number of rectangles on the current rendering target with the"]
    #[doc = " drawing color at subpixel precision."]
    #[doc = ""]
    #[doc = " \\param renderer The renderer which should fill multiple rectangles."]
    #[doc = " \\param rects A pointer to an array of destination rectangles."]
    #[doc = " \\param count The number of rectangles."]
    #[doc = " \\return 0 on success, or -1 on error"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.10."]
    pub fn SDL_RenderFillRectsF(
        renderer: *mut SDL_Renderer,
        rects: *const SDL_FRect,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Copy a portion of the texture to the current rendering target at subpixel"]
    #[doc = " precision."]
    #[doc = ""]
    #[doc = " \\param renderer The renderer which should copy parts of a texture."]
    #[doc = " \\param texture The source texture."]
    #[doc = " \\param srcrect A pointer to the source rectangle, or NULL for the entire"]
    #[doc = "                texture."]
    #[doc = " \\param dstrect A pointer to the destination rectangle, or NULL for the"]
    #[doc = "                entire rendering target."]
    #[doc = " \\return 0 on success, or -1 on error"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.10."]
    pub fn SDL_RenderCopyF(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
        srcrect: *const SDL_Rect,
        dstrect: *const SDL_FRect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Copy a portion of the source texture to the current rendering target, with"]
    #[doc = " rotation and flipping, at subpixel precision."]
    #[doc = ""]
    #[doc = " \\param renderer The renderer which should copy parts of a texture."]
    #[doc = " \\param texture The source texture."]
    #[doc = " \\param srcrect A pointer to the source rectangle, or NULL for the entire"]
    #[doc = "                texture."]
    #[doc = " \\param dstrect A pointer to the destination rectangle, or NULL for the"]
    #[doc = "                entire rendering target."]
    #[doc = " \\param angle An angle in degrees that indicates the rotation that will be"]
    #[doc = "              applied to dstrect, rotating it in a clockwise direction"]
    #[doc = " \\param center A pointer to a point indicating the point around which"]
    #[doc = "               dstrect will be rotated (if NULL, rotation will be done"]
    #[doc = "               around dstrect.w/2, dstrect.h/2)."]
    #[doc = " \\param flip An SDL_RendererFlip value stating which flipping actions should"]
    #[doc = "             be performed on the texture"]
    #[doc = " \\return 0 on success, or -1 on error"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.10."]
    pub fn SDL_RenderCopyExF(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
        srcrect: *const SDL_Rect,
        dstrect: *const SDL_FRect,
        angle: f64,
        center: *const SDL_FPoint,
        flip: SDL_RendererFlip,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Render a list of triangles, optionally using a texture and indices into the"]
    #[doc = " vertex array Color and alpha modulation is done per vertex"]
    #[doc = " (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored)."]
    #[doc = ""]
    #[doc = " \\param texture (optional) The SDL texture to use."]
    #[doc = " \\param vertices Vertices."]
    #[doc = " \\param num_vertices Number of vertices."]
    #[doc = " \\param indices (optional) An array of integer indices into the 'vertices'"]
    #[doc = "                array, if NULL all vertices will be rendered in sequential"]
    #[doc = "                order."]
    #[doc = " \\param num_indices Number of indices."]
    #[doc = " \\return 0 on success, or -1 if the operation is not supported"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    #[doc = ""]
    #[doc = " \\sa SDL_RenderGeometryRaw"]
    #[doc = " \\sa SDL_Vertex"]
    pub fn SDL_RenderGeometry(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
        vertices: *const SDL_Vertex,
        num_vertices: libc::c_int,
        indices: *const libc::c_int,
        num_indices: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Render a list of triangles, optionally using a texture and indices into the"]
    #[doc = " vertex arrays Color and alpha modulation is done per vertex"]
    #[doc = " (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored)."]
    #[doc = ""]
    #[doc = " \\param texture (optional) The SDL texture to use."]
    #[doc = " \\param xy Vertex positions"]
    #[doc = " \\param xy_stride Byte size to move from one element to the next element"]
    #[doc = " \\param color Vertex colors (as SDL_Color)"]
    #[doc = " \\param color_stride Byte size to move from one element to the next element"]
    #[doc = " \\param uv Vertex normalized texture coordinates"]
    #[doc = " \\param uv_stride Byte size to move from one element to the next element"]
    #[doc = " \\param num_vertices Number of vertices."]
    #[doc = " \\param indices (optional) An array of indices into the 'vertices' arrays,"]
    #[doc = "                if NULL all vertices will be rendered in sequential order."]
    #[doc = " \\param num_indices Number of indices."]
    #[doc = " \\param size_indices Index size: 1 (byte), 2 (short), 4 (int)"]
    #[doc = " \\return 0 on success, or -1 if the operation is not supported"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    #[doc = ""]
    #[doc = " \\sa SDL_RenderGeometry"]
    #[doc = " \\sa SDL_Vertex"]
    pub fn SDL_RenderGeometryRaw(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
        xy: *const f32,
        xy_stride: libc::c_int,
        color: *const SDL_Color,
        color_stride: libc::c_int,
        uv: *const f32,
        uv_stride: libc::c_int,
        num_vertices: libc::c_int,
        indices: *const libc::c_void,
        num_indices: libc::c_int,
        size_indices: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Read pixels from the current rendering target to an array of pixels."]
    #[doc = ""]
    #[doc = " **WARNING**: This is a very slow operation, and should not be used"]
    #[doc = " frequently."]
    #[doc = ""]
    #[doc = " `pitch` specifies the number of bytes between rows in the destination"]
    #[doc = " `pixels` data. This allows you to write to a subrectangle or have padded"]
    #[doc = " rows in the destination. Generally, `pitch` should equal the number of"]
    #[doc = " pixels per row in the `pixels` data times the number of bytes per pixel,"]
    #[doc = " but it might contain additional padding (for example, 24bit RGB Windows"]
    #[doc = " Bitmap data pads all rows to multiples of 4 bytes)."]
    #[doc = ""]
    #[doc = " \\param renderer the rendering context"]
    #[doc = " \\param rect an SDL_Rect structure representing the area to read, or NULL"]
    #[doc = "             for the entire render target"]
    #[doc = " \\param format an SDL_PixelFormatEnum value of the desired format of the"]
    #[doc = "               pixel data, or 0 to use the format of the rendering target"]
    #[doc = " \\param pixels a pointer to the pixel data to copy into"]
    #[doc = " \\param pitch the pitch of the `pixels` parameter"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_RenderReadPixels(
        renderer: *mut SDL_Renderer,
        rect: *const SDL_Rect,
        format: Uint32,
        pixels: *mut libc::c_void,
        pitch: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Update the screen with any rendering performed since the previous call."]
    #[doc = ""]
    #[doc = " SDL's rendering functions operate on a backbuffer; that is, calling a"]
    #[doc = " rendering function such as SDL_RenderDrawLine() does not directly put a"]
    #[doc = " line on the screen, but rather updates the backbuffer. As such, you compose"]
    #[doc = " your entire scene and *present* the composed backbuffer to the screen as a"]
    #[doc = " complete picture."]
    #[doc = ""]
    #[doc = " Therefore, when using SDL's rendering API, one does all drawing intended"]
    #[doc = " for the frame, and then calls this function once per frame to present the"]
    #[doc = " final drawing to the user."]
    #[doc = ""]
    #[doc = " The backbuffer should be considered invalidated after each present; do not"]
    #[doc = " assume that previous contents will exist between frames. You are strongly"]
    #[doc = " encouraged to call SDL_RenderClear() to initialize the backbuffer before"]
    #[doc = " starting each new frame's drawing, even if you plan to overwrite every"]
    #[doc = " pixel."]
    #[doc = ""]
    #[doc = " \\param renderer the rendering context"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_RenderClear"]
    #[doc = " \\sa SDL_RenderDrawLine"]
    #[doc = " \\sa SDL_RenderDrawLines"]
    #[doc = " \\sa SDL_RenderDrawPoint"]
    #[doc = " \\sa SDL_RenderDrawPoints"]
    #[doc = " \\sa SDL_RenderDrawRect"]
    #[doc = " \\sa SDL_RenderDrawRects"]
    #[doc = " \\sa SDL_RenderFillRect"]
    #[doc = " \\sa SDL_RenderFillRects"]
    #[doc = " \\sa SDL_SetRenderDrawBlendMode"]
    #[doc = " \\sa SDL_SetRenderDrawColor"]
    pub fn SDL_RenderPresent(renderer: *mut SDL_Renderer);
}
extern "C" {
    #[doc = " Destroy the specified texture."]
    #[doc = ""]
    #[doc = " Passing NULL or an otherwise invalid texture will set the SDL error message"]
    #[doc = " to \"Invalid texture\"."]
    #[doc = ""]
    #[doc = " \\param texture the texture to destroy"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateTexture"]
    #[doc = " \\sa SDL_CreateTextureFromSurface"]
    pub fn SDL_DestroyTexture(texture: *mut SDL_Texture);
}
extern "C" {
    #[doc = " Destroy the rendering context for a window and free associated textures."]
    #[doc = ""]
    #[doc = " \\param renderer the rendering context"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateRenderer"]
    pub fn SDL_DestroyRenderer(renderer: *mut SDL_Renderer);
}
extern "C" {
    #[doc = " Force the rendering context to flush any pending commands to the underlying"]
    #[doc = " rendering API."]
    #[doc = ""]
    #[doc = " You do not need to (and in fact, shouldn't) call this function unless you"]
    #[doc = " are planning to call into OpenGL/Direct3D/Metal/whatever directly in"]
    #[doc = " addition to using an SDL_Renderer."]
    #[doc = ""]
    #[doc = " This is for a very-specific case: if you are using SDL's render API, you"]
    #[doc = " asked for a specific renderer backend (OpenGL, Direct3D, etc), you set"]
    #[doc = " SDL_HINT_RENDER_BATCHING to \"1\", and you plan to make OpenGL/D3D/whatever"]
    #[doc = " calls in addition to SDL render API calls. If all of this applies, you"]
    #[doc = " should call SDL_RenderFlush() between calls to SDL's render API and the"]
    #[doc = " low-level API you're using in cooperation."]
    #[doc = ""]
    #[doc = " In all other cases, you can ignore this function. This is only here to get"]
    #[doc = " maximum performance out of a specific situation. In all other cases, SDL"]
    #[doc = " will do the right thing, perhaps at a performance loss."]
    #[doc = ""]
    #[doc = " This function is first available in SDL 2.0.10, and is not needed in 2.0.9"]
    #[doc = " and earlier, as earlier versions did not queue rendering commands at all,"]
    #[doc = " instead flushing them to the OS immediately."]
    #[doc = ""]
    #[doc = " \\param renderer the rendering context"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.10."]
    pub fn SDL_RenderFlush(renderer: *mut SDL_Renderer) -> libc::c_int;
}
extern "C" {
    #[doc = " Bind an OpenGL/ES/ES2 texture to the current context."]
    #[doc = ""]
    #[doc = " This is for use with OpenGL instructions when rendering OpenGL primitives"]
    #[doc = " directly."]
    #[doc = ""]
    #[doc = " If not NULL, `texw` and `texh` will be filled with the width and height"]
    #[doc = " values suitable for the provided texture. In most cases, both will be 1.0,"]
    #[doc = " however, on systems that support the GL_ARB_texture_rectangle extension,"]
    #[doc = " these values will actually be the pixel width and height used to create the"]
    #[doc = " texture, so this factor needs to be taken into account when providing"]
    #[doc = " texture coordinates to OpenGL."]
    #[doc = ""]
    #[doc = " You need a renderer to create an SDL_Texture, therefore you can only use"]
    #[doc = " this function with an implicit OpenGL context from SDL_CreateRenderer(),"]
    #[doc = " not with your own OpenGL context. If you need control over your OpenGL"]
    #[doc = " context, you need to write your own texture-loading methods."]
    #[doc = ""]
    #[doc = " Also note that SDL may upload RGB textures as BGR (or vice-versa), and"]
    #[doc = " re-order the color channels in the shaders phase, so the uploaded texture"]
    #[doc = " may have swapped color channels."]
    #[doc = ""]
    #[doc = " \\param texture the texture to bind to the current OpenGL/ES/ES2 context"]
    #[doc = " \\param texw a pointer to a float value which will be filled with the"]
    #[doc = "             texture width or NULL if you don't need that value"]
    #[doc = " \\param texh a pointer to a float value which will be filled with the"]
    #[doc = "             texture height or NULL if you don't need that value"]
    #[doc = " \\returns 0 on success, or -1 if the operation is not supported; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GL_MakeCurrent"]
    #[doc = " \\sa SDL_GL_UnbindTexture"]
    pub fn SDL_GL_BindTexture(
        texture: *mut SDL_Texture,
        texw: *mut f32,
        texh: *mut f32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Unbind an OpenGL/ES/ES2 texture from the current context."]
    #[doc = ""]
    #[doc = " See SDL_GL_BindTexture() for examples on how to use these functions"]
    #[doc = ""]
    #[doc = " \\param texture the texture to unbind from the current OpenGL/ES/ES2 context"]
    #[doc = " \\returns 0 on success, or -1 if the operation is not supported"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GL_BindTexture"]
    #[doc = " \\sa SDL_GL_MakeCurrent"]
    pub fn SDL_GL_UnbindTexture(texture: *mut SDL_Texture) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the CAMetalLayer associated with the given Metal renderer."]
    #[doc = ""]
    #[doc = " This function returns `void *`, so SDL doesn't have to include Metal's"]
    #[doc = " headers, but it can be safely cast to a `CAMetalLayer *`."]
    #[doc = ""]
    #[doc = " \\param renderer The renderer to query"]
    #[doc = " \\returns a `CAMetalLayer *` on success, or NULL if the renderer isn't a"]
    #[doc = "          Metal renderer"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.8."]
    #[doc = ""]
    #[doc = " \\sa SDL_RenderGetMetalCommandEncoder"]
    pub fn SDL_RenderGetMetalLayer(renderer: *mut SDL_Renderer) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Get the Metal command encoder for the current frame"]
    #[doc = ""]
    #[doc = " This function returns `void *`, so SDL doesn't have to include Metal's"]
    #[doc = " headers, but it can be safely cast to an `id<MTLRenderCommandEncoder>`."]
    #[doc = ""]
    #[doc = " Note that as of SDL 2.0.18, this will return NULL if Metal refuses to give"]
    #[doc = " SDL a drawable to render to, which might happen if the window is"]
    #[doc = " hidden/minimized/offscreen. This doesn't apply to command encoders for"]
    #[doc = " render targets, just the window's backbacker. Check your return values!"]
    #[doc = ""]
    #[doc = " \\param renderer The renderer to query"]
    #[doc = " \\returns an `id<MTLRenderCommandEncoder>` on success, or NULL if the"]
    #[doc = "          renderer isn't a Metal renderer or there was an error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.8."]
    #[doc = ""]
    #[doc = " \\sa SDL_RenderGetMetalLayer"]
    pub fn SDL_RenderGetMetalCommandEncoder(renderer: *mut SDL_Renderer) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Toggle VSync of the given renderer."]
    #[doc = ""]
    #[doc = " \\param renderer The renderer to toggle"]
    #[doc = " \\param vsync 1 for on, 0 for off. All other values are reserved"]
    #[doc = " \\returns a 0 int on success, or non-zero on failure"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    pub fn SDL_RenderSetVSync(renderer: *mut SDL_Renderer, vsync: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Create a window that can be shaped with the specified position, dimensions,"]
    #[doc = " and flags."]
    #[doc = ""]
    #[doc = " \\param title The title of the window, in UTF-8 encoding."]
    #[doc = " \\param x The x position of the window, ::SDL_WINDOWPOS_CENTERED, or"]
    #[doc = "          ::SDL_WINDOWPOS_UNDEFINED."]
    #[doc = " \\param y The y position of the window, ::SDL_WINDOWPOS_CENTERED, or"]
    #[doc = "          ::SDL_WINDOWPOS_UNDEFINED."]
    #[doc = " \\param w The width of the window."]
    #[doc = " \\param h The height of the window."]
    #[doc = " \\param flags The flags for the window, a mask of SDL_WINDOW_BORDERLESS with"]
    #[doc = "              any of the following: ::SDL_WINDOW_OPENGL,"]
    #[doc = "              ::SDL_WINDOW_INPUT_GRABBED, ::SDL_WINDOW_HIDDEN,"]
    #[doc = "              ::SDL_WINDOW_RESIZABLE, ::SDL_WINDOW_MAXIMIZED,"]
    #[doc = "              ::SDL_WINDOW_MINIMIZED, ::SDL_WINDOW_BORDERLESS is always set,"]
    #[doc = "              and ::SDL_WINDOW_FULLSCREEN is always unset."]
    #[doc = " \\return the window created, or NULL if window creation failed."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_DestroyWindow"]
    pub fn SDL_CreateShapedWindow(
        title: *const libc::c_char,
        x: libc::c_uint,
        y: libc::c_uint,
        w: libc::c_uint,
        h: libc::c_uint,
        flags: Uint32,
    ) -> *mut SDL_Window;
}
extern "C" {
    #[doc = " Return whether the given window is a shaped window."]
    #[doc = ""]
    #[doc = " \\param window The window to query for being shaped."]
    #[doc = " \\return SDL_TRUE if the window is a window that can be shaped, SDL_FALSE if"]
    #[doc = "         the window is unshaped or NULL."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_CreateShapedWindow"]
    pub fn SDL_IsShapedWindow(window: *const SDL_Window) -> SDL_bool;
}
#[repr(u32)]
#[doc = " \\brief An enum denoting the specific type of contents present in an SDL_WindowShapeParams union."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum WindowShapeMode {
    #[doc = " \\brief The default mode, a binarized alpha cutoff of 1."]
    ShapeModeDefault = 0,
    #[doc = " \\brief A binarized alpha cutoff with a given integer value."]
    ShapeModeBinarizeAlpha = 1,
    #[doc = " \\brief A binarized alpha cutoff with a given integer value, but with the opposite comparison."]
    ShapeModeReverseBinarizeAlpha = 2,
    #[doc = " \\brief A color key is applied."]
    ShapeModeColorKey = 3,
}
#[doc = " \\brief A union containing parameters for shaped windows."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_WindowShapeParams {
    #[doc = " \\brief A cutoff alpha value for binarization of the window shape's alpha channel."]
    pub binarizationCutoff: Uint8,
    pub colorKey: SDL_Color,
    _bindgen_union_align: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_SDL_WindowShapeParams() {
    assert_eq!(
        ::core::mem::size_of::<SDL_WindowShapeParams>(),
        4usize,
        concat!("Size of: ", stringify!(SDL_WindowShapeParams))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_WindowShapeParams>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_WindowShapeParams))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_WindowShapeParams>())).binarizationCutoff as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowShapeParams),
            "::",
            stringify!(binarizationCutoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_WindowShapeParams>())).colorKey as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowShapeParams),
            "::",
            stringify!(colorKey)
        )
    );
}
#[doc = " \\brief A struct that tags the SDL_WindowShapeParams union with an enum describing the type of its contents."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_WindowShapeMode {
    #[doc = " \\brief The mode of these window-shape parameters."]
    pub mode: WindowShapeMode,
    #[doc = " \\brief Window-shape parameters."]
    pub parameters: SDL_WindowShapeParams,
}
#[test]
fn bindgen_test_layout_SDL_WindowShapeMode() {
    assert_eq!(
        ::core::mem::size_of::<SDL_WindowShapeMode>(),
        8usize,
        concat!("Size of: ", stringify!(SDL_WindowShapeMode))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_WindowShapeMode>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_WindowShapeMode))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_WindowShapeMode>())).mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowShapeMode),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_WindowShapeMode>())).parameters as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowShapeMode),
            "::",
            stringify!(parameters)
        )
    );
}
extern "C" {
    #[doc = " Set the shape and parameters of a shaped window."]
    #[doc = ""]
    #[doc = " \\param window The shaped window whose parameters should be set."]
    #[doc = " \\param shape A surface encoding the desired shape for the window."]
    #[doc = " \\param shape_mode The parameters to set for the shaped window."]
    #[doc = " \\return 0 on success, SDL_INVALID_SHAPE_ARGUMENT on an invalid shape"]
    #[doc = "         argument, or SDL_NONSHAPEABLE_WINDOW if the SDL_Window given does"]
    #[doc = "         not reference a valid shaped window."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_WindowShapeMode"]
    #[doc = " \\sa SDL_GetShapedWindowMode"]
    pub fn SDL_SetWindowShape(
        window: *mut SDL_Window,
        shape: *mut SDL_Surface,
        shape_mode: *mut SDL_WindowShapeMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the shape parameters of a shaped window."]
    #[doc = ""]
    #[doc = " \\param window The shaped window whose parameters should be retrieved."]
    #[doc = " \\param shape_mode An empty shape-mode structure to fill, or NULL to check"]
    #[doc = "                   whether the window has a shape."]
    #[doc = " \\return 0 if the window has a shape and, provided shape_mode was not NULL,"]
    #[doc = "         shape_mode has been filled with the mode data,"]
    #[doc = "         SDL_NONSHAPEABLE_WINDOW if the SDL_Window given is not a shaped"]
    #[doc = "         window, or SDL_WINDOW_LACKS_SHAPE if the SDL_Window given is a"]
    #[doc = "         shapeable window currently lacking a shape."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_WindowShapeMode"]
    #[doc = " \\sa SDL_SetWindowShape"]
    pub fn SDL_GetShapedWindowMode(
        window: *mut SDL_Window,
        shape_mode: *mut SDL_WindowShapeMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Sets the UNIX nice value for a thread."]
    #[doc = ""]
    #[doc = " This uses setpriority() if possible, and RealtimeKit if available."]
    #[doc = ""]
    #[doc = " \\param threadID the Unix thread ID to change priority of."]
    #[doc = " \\param priority The new, Unix-specific, priority value."]
    #[doc = " \\returns 0 on success, or -1 on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.9."]
    pub fn SDL_LinuxSetThreadPriority(threadID: Sint64, priority: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Sets the priority (not nice level) and scheduling policy for a thread."]
    #[doc = ""]
    #[doc = " This uses setpriority() if possible, and RealtimeKit if available."]
    #[doc = ""]
    #[doc = " \\param threadID The Unix thread ID to change priority of."]
    #[doc = " \\param sdlPriority The new SDL_ThreadPriority value."]
    #[doc = " \\param schedPolicy The new scheduling policy (SCHED_FIFO, SCHED_RR,"]
    #[doc = "                    SCHED_OTHER, etc...)"]
    #[doc = " \\returns 0 on success, or -1 on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    pub fn SDL_LinuxSetThreadPriorityAndPolicy(
        threadID: Sint64,
        sdlPriority: libc::c_int,
        schedPolicy: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Query if the current device is a tablet."]
    #[doc = ""]
    #[doc = " If SDL can't determine this, it will return SDL_FALSE."]
    #[doc = ""]
    #[doc = " \\returns SDL_TRUE if the device is a tablet, SDL_FALSE otherwise."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.9."]
    pub fn SDL_IsTablet() -> SDL_bool;
}
extern "C" {
    pub fn SDL_OnApplicationWillTerminate();
}
extern "C" {
    pub fn SDL_OnApplicationDidReceiveMemoryWarning();
}
extern "C" {
    pub fn SDL_OnApplicationWillResignActive();
}
extern "C" {
    pub fn SDL_OnApplicationDidEnterBackground();
}
extern "C" {
    pub fn SDL_OnApplicationWillEnterForeground();
}
extern "C" {
    pub fn SDL_OnApplicationDidBecomeActive();
}
extern "C" {
    #[doc = " Get the number of milliseconds since SDL library initialization."]
    #[doc = ""]
    #[doc = " This value wraps if the program runs for more than ~49 days."]
    #[doc = ""]
    #[doc = " This function is not recommended as of SDL 2.0.18; use SDL_GetTicks64()"]
    #[doc = " instead, where the value doesn't wrap every ~49 days. There are places in"]
    #[doc = " SDL where we provide a 32-bit timestamp that can not change without"]
    #[doc = " breaking binary compatibility, though, so this function isn't officially"]
    #[doc = " deprecated."]
    #[doc = ""]
    #[doc = " \\returns an unsigned 32-bit value representing the number of milliseconds"]
    #[doc = "          since the SDL library initialized."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_TICKS_PASSED"]
    pub fn SDL_GetTicks() -> Uint32;
}
extern "C" {
    #[doc = " Get the number of milliseconds since SDL library initialization."]
    #[doc = ""]
    #[doc = " Note that you should not use the SDL_TICKS_PASSED macro with values"]
    #[doc = " returned by this function, as that macro does clever math to compensate for"]
    #[doc = " the 32-bit overflow every ~49 days that SDL_GetTicks() suffers from. 64-bit"]
    #[doc = " values from this function can be safely compared directly."]
    #[doc = ""]
    #[doc = " For example, if you want to wait 100 ms, you could do this:"]
    #[doc = ""]
    #[doc = " ```c"]
    #[doc = " const Uint64 timeout = SDL_GetTicks64() + 100;"]
    #[doc = " while (SDL_GetTicks64() < timeout) {"]
    #[doc = "     // ... do work until timeout has elapsed"]
    #[doc = " }"]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " \\returns an unsigned 64-bit value representing the number of milliseconds"]
    #[doc = "          since the SDL library initialized."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.18."]
    pub fn SDL_GetTicks64() -> Uint64;
}
extern "C" {
    #[doc = " Get the current value of the high resolution counter."]
    #[doc = ""]
    #[doc = " This function is typically used for profiling."]
    #[doc = ""]
    #[doc = " The counter values are only meaningful relative to each other. Differences"]
    #[doc = " between values can be converted to times by using"]
    #[doc = " SDL_GetPerformanceFrequency()."]
    #[doc = ""]
    #[doc = " \\returns the current counter value."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetPerformanceFrequency"]
    pub fn SDL_GetPerformanceCounter() -> Uint64;
}
extern "C" {
    #[doc = " Get the count per second of the high resolution counter."]
    #[doc = ""]
    #[doc = " \\returns a platform-specific count per second."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetPerformanceCounter"]
    pub fn SDL_GetPerformanceFrequency() -> Uint64;
}
extern "C" {
    #[doc = " Wait a specified number of milliseconds before returning."]
    #[doc = ""]
    #[doc = " This function waits a specified number of milliseconds before returning. It"]
    #[doc = " waits at least the specified time, but possibly longer due to OS"]
    #[doc = " scheduling."]
    #[doc = ""]
    #[doc = " \\param ms the number of milliseconds to delay"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_Delay(ms: Uint32);
}
#[doc = " Function prototype for the timer callback function."]
#[doc = ""]
#[doc = " The callback function is passed the current timer interval and returns"]
#[doc = " the next timer interval. If the returned value is the same as the one"]
#[doc = " passed in, the periodic alarm continues, otherwise a new alarm is"]
#[doc = " scheduled. If the callback returns 0, the periodic alarm is cancelled."]
pub type SDL_TimerCallback = ::core::option::Option<
    unsafe extern "C" fn(interval: Uint32, param: *mut libc::c_void) -> Uint32,
>;
#[doc = " Definition of the timer ID type."]
pub type SDL_TimerID = libc::c_int;
extern "C" {
    #[doc = " Call a callback function at a future time."]
    #[doc = ""]
    #[doc = " If you use this function, you must pass `SDL_INIT_TIMER` to SDL_Init()."]
    #[doc = ""]
    #[doc = " The callback function is passed the current timer interval and the user"]
    #[doc = " supplied parameter from the SDL_AddTimer() call and should return the next"]
    #[doc = " timer interval. If the value returned from the callback is 0, the timer is"]
    #[doc = " canceled."]
    #[doc = ""]
    #[doc = " The callback is run on a separate thread."]
    #[doc = ""]
    #[doc = " Timers take into account the amount of time it took to execute the"]
    #[doc = " callback. For example, if the callback took 250 ms to execute and returned"]
    #[doc = " 1000 (ms), the timer would only wait another 750 ms before its next"]
    #[doc = " iteration."]
    #[doc = ""]
    #[doc = " Timing may be inexact due to OS scheduling. Be sure to note the current"]
    #[doc = " time with SDL_GetTicks() or SDL_GetPerformanceCounter() in case your"]
    #[doc = " callback needs to adjust for variances."]
    #[doc = ""]
    #[doc = " \\param interval the timer delay, in milliseconds, passed to `callback`"]
    #[doc = " \\param callback the SDL_TimerCallback function to call when the specified"]
    #[doc = "                 `interval` elapses"]
    #[doc = " \\param param a pointer that is passed to `callback`"]
    #[doc = " \\returns a timer ID or 0 if an error occurs; call SDL_GetError() for more"]
    #[doc = "          information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_RemoveTimer"]
    pub fn SDL_AddTimer(
        interval: Uint32,
        callback: SDL_TimerCallback,
        param: *mut libc::c_void,
    ) -> SDL_TimerID;
}
extern "C" {
    #[doc = " Remove a timer created with SDL_AddTimer()."]
    #[doc = ""]
    #[doc = " \\param id the ID of the timer to remove"]
    #[doc = " \\returns SDL_TRUE if the timer is removed or SDL_FALSE if the timer wasn't"]
    #[doc = "          found."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_AddTimer"]
    pub fn SDL_RemoveTimer(id: SDL_TimerID) -> SDL_bool;
}
#[doc = " Information about the version of SDL in use."]
#[doc = ""]
#[doc = " Represents the library's version as three levels: major revision"]
#[doc = " (increments with massive changes, additions, and enhancements),"]
#[doc = " minor revision (increments with backwards-compatible changes to the"]
#[doc = " major revision), and patchlevel (increments with fixes to the minor"]
#[doc = " revision)."]
#[doc = ""]
#[doc = " \\sa SDL_VERSION"]
#[doc = " \\sa SDL_GetVersion"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_version {
    #[doc = "< major version"]
    pub major: Uint8,
    #[doc = "< minor version"]
    pub minor: Uint8,
    #[doc = "< update version"]
    pub patch: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_version() {
    assert_eq!(
        ::core::mem::size_of::<SDL_version>(),
        3usize,
        concat!("Size of: ", stringify!(SDL_version))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_version>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_version))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_version>())).major as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_version),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_version>())).minor as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_version),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_version>())).patch as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_version),
            "::",
            stringify!(patch)
        )
    );
}
extern "C" {
    #[doc = " Get the version of SDL that is linked against your program."]
    #[doc = ""]
    #[doc = " If you are linking to SDL dynamically, then it is possible that the current"]
    #[doc = " version will be different than the version you compiled against. This"]
    #[doc = " function returns the current version, while SDL_VERSION() is a macro that"]
    #[doc = " tells you what version you compiled with."]
    #[doc = ""]
    #[doc = " This function may be called safely at any time, even before SDL_Init()."]
    #[doc = ""]
    #[doc = " \\param ver the SDL_version structure that contains the version information"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetRevision"]
    pub fn SDL_GetVersion(ver: *mut SDL_version);
}
extern "C" {
    #[doc = " Get the code revision of SDL that is linked against your program."]
    #[doc = ""]
    #[doc = " This value is the revision of the code you are linked with and may be"]
    #[doc = " different from the code you are compiling with, which is found in the"]
    #[doc = " constant SDL_REVISION."]
    #[doc = ""]
    #[doc = " The revision is arbitrary string (a hash value) uniquely identifying the"]
    #[doc = " exact revision of the SDL library in use, and is only useful in comparing"]
    #[doc = " against other revisions. It is NOT an incrementing number."]
    #[doc = ""]
    #[doc = " If SDL wasn't built from a git repository with the appropriate tools, this"]
    #[doc = " will return an empty string."]
    #[doc = ""]
    #[doc = " Prior to SDL 2.0.16, before development moved to GitHub, this returned a"]
    #[doc = " hash for a Mercurial repository."]
    #[doc = ""]
    #[doc = " You shouldn't use this function for anything but logging it for debugging"]
    #[doc = " purposes. The string is not intended to be reliable in any way."]
    #[doc = ""]
    #[doc = " \\returns an arbitrary string, uniquely identifying the exact revision of"]
    #[doc = "          the SDL library in use."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetVersion"]
    pub fn SDL_GetRevision() -> *const libc::c_char;
}
extern "C" {
    #[doc = " Obsolete function, do not use."]
    #[doc = ""]
    #[doc = " When SDL was hosted in a Mercurial repository, and was built carefully,"]
    #[doc = " this would return the revision number that the build was created from. This"]
    #[doc = " number was not reliable for several reasons, but more importantly, SDL is"]
    #[doc = " now hosted in a git repository, which does not offer numbers at all, only"]
    #[doc = " hashes. This function only ever returns zero now. Don't use it."]
    #[doc = ""]
    #[doc = " Before SDL 2.0.16, this might have returned an unreliable, but non-zero"]
    #[doc = " number."]
    #[doc = ""]
    #[doc = " \\deprecated Use SDL_GetRevision() instead; if SDL was carefully built, it"]
    #[doc = "             will return a git hash."]
    #[doc = ""]
    #[doc = " \\returns zero, always, in modern SDL releases."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetRevision"]
    pub fn SDL_GetRevisionNumber() -> libc::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Locale {
    #[doc = "< A language name, like \"en\" for English."]
    pub language: *const libc::c_char,
    #[doc = "< A country, like \"US\" for America. Can be NULL."]
    pub country: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_SDL_Locale() {
    assert_eq!(
        ::core::mem::size_of::<SDL_Locale>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_Locale))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_Locale>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_Locale))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Locale>())).language as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Locale),
            "::",
            stringify!(language)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_Locale>())).country as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Locale),
            "::",
            stringify!(country)
        )
    );
}
extern "C" {
    #[doc = " Report the user's preferred locale."]
    #[doc = ""]
    #[doc = " This returns an array of SDL_Locale structs, the final item zeroed out."]
    #[doc = " When the caller is done with this array, it should call SDL_free() on the"]
    #[doc = " returned value; all the memory involved is allocated in a single block, so"]
    #[doc = " a single SDL_free() will suffice."]
    #[doc = ""]
    #[doc = " Returned language strings are in the format xx, where 'xx' is an ISO-639"]
    #[doc = " language specifier (such as \"en\" for English, \"de\" for German, etc)."]
    #[doc = " Country strings are in the format YY, where \"YY\" is an ISO-3166 country"]
    #[doc = " code (such as \"US\" for the United States, \"CA\" for Canada, etc). Country"]
    #[doc = " might be NULL if there's no specific guidance on them (so you might get {"]
    #[doc = " \"en\", \"US\" } for American English, but { \"en\", NULL } means \"English"]
    #[doc = " language, generically\"). Language strings are never NULL, except to"]
    #[doc = " terminate the array."]
    #[doc = ""]
    #[doc = " Please note that not all of these strings are 2 characters; some are three"]
    #[doc = " or more."]
    #[doc = ""]
    #[doc = " The returned list of locales are in the order of the user's preference. For"]
    #[doc = " example, a German citizen that is fluent in US English and knows enough"]
    #[doc = " Japanese to navigate around Tokyo might have a list like: { \"de\", \"en_US\","]
    #[doc = " \"jp\", NULL }. Someone from England might prefer British English (where"]
    #[doc = " \"color\" is spelled \"colour\", etc), but will settle for anything like it: {"]
    #[doc = " \"en_GB\", \"en\", NULL }."]
    #[doc = ""]
    #[doc = " This function returns NULL on error, including when the platform does not"]
    #[doc = " supply this information at all."]
    #[doc = ""]
    #[doc = " This might be a \"slow\" call that has to query the operating system. It's"]
    #[doc = " best to ask for this once and save the results. However, this list can"]
    #[doc = " change, usually because the user has changed a system preference outside of"]
    #[doc = " your program; SDL will send an SDL_LOCALECHANGED event in this case, if"]
    #[doc = " possible, and you can call this function again to get an updated copy of"]
    #[doc = " preferred locales."]
    #[doc = ""]
    #[doc = " \\return array of locales, terminated with a locale with a NULL language"]
    #[doc = "         field. Will return NULL on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.14."]
    pub fn SDL_GetPreferredLocales() -> *mut SDL_Locale;
}
extern "C" {
    #[doc = " Open a URL/URI in the browser or other appropriate external application."]
    #[doc = ""]
    #[doc = " Open a URL in a separate, system-provided application. How this works will"]
    #[doc = " vary wildly depending on the platform. This will likely launch what makes"]
    #[doc = " sense to handle a specific URL's protocol (a web browser for `http://`,"]
    #[doc = " etc), but it might also be able to launch file managers for directories and"]
    #[doc = " other things."]
    #[doc = ""]
    #[doc = " What happens when you open a URL varies wildly as well: your game window"]
    #[doc = " may lose focus (and may or may not lose focus if your game was fullscreen"]
    #[doc = " or grabbing input at the time). On mobile devices, your app will likely"]
    #[doc = " move to the background or your process might be paused. Any given platform"]
    #[doc = " may or may not handle a given URL."]
    #[doc = ""]
    #[doc = " If this is unimplemented (or simply unavailable) for a platform, this will"]
    #[doc = " fail with an error. A successful result does not mean the URL loaded, just"]
    #[doc = " that we launched _something_ to handle it (or at least believe we did)."]
    #[doc = ""]
    #[doc = " All this to say: this function can be useful, but you should definitely"]
    #[doc = " test it on every platform you target."]
    #[doc = ""]
    #[doc = " \\param url A valid URL/URI to open. Use `file:///full/path/to/file` for"]
    #[doc = "            local files, if supported."]
    #[doc = " \\returns 0 on success, or -1 on error; call SDL_GetError() for more"]
    #[doc = "          information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.14."]
    pub fn SDL_OpenURL(url: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Initialize the SDL library."]
    #[doc = ""]
    #[doc = " SDL_Init() simply forwards to calling SDL_InitSubSystem(). Therefore, the"]
    #[doc = " two may be used interchangeably. Though for readability of your code"]
    #[doc = " SDL_InitSubSystem() might be preferred."]
    #[doc = ""]
    #[doc = " The file I/O (for example: SDL_RWFromFile) and threading (SDL_CreateThread)"]
    #[doc = " subsystems are initialized by default. Message boxes"]
    #[doc = " (SDL_ShowSimpleMessageBox) also attempt to work without initializing the"]
    #[doc = " video subsystem, in hopes of being useful in showing an error dialog when"]
    #[doc = " SDL_Init fails. You must specifically initialize other subsystems if you"]
    #[doc = " use them in your application."]
    #[doc = ""]
    #[doc = " Logging (such as SDL_Log) works without initialization, too."]
    #[doc = ""]
    #[doc = " `flags` may be any of the following OR'd together:"]
    #[doc = ""]
    #[doc = " - `SDL_INIT_TIMER`: timer subsystem"]
    #[doc = " - `SDL_INIT_AUDIO`: audio subsystem"]
    #[doc = " - `SDL_INIT_VIDEO`: video subsystem; automatically initializes the events"]
    #[doc = "   subsystem"]
    #[doc = " - `SDL_INIT_JOYSTICK`: joystick subsystem; automatically initializes the"]
    #[doc = "   events subsystem"]
    #[doc = " - `SDL_INIT_HAPTIC`: haptic (force feedback) subsystem"]
    #[doc = " - `SDL_INIT_GAMECONTROLLER`: controller subsystem; automatically"]
    #[doc = "   initializes the joystick subsystem"]
    #[doc = " - `SDL_INIT_EVENTS`: events subsystem"]
    #[doc = " - `SDL_INIT_EVERYTHING`: all of the above subsystems"]
    #[doc = " - `SDL_INIT_NOPARACHUTE`: compatibility; this flag is ignored"]
    #[doc = ""]
    #[doc = " Subsystem initialization is ref-counted, you must call SDL_QuitSubSystem()"]
    #[doc = " for each SDL_InitSubSystem() to correctly shutdown a subsystem manually (or"]
    #[doc = " call SDL_Quit() to force shutdown). If a subsystem is already loaded then"]
    #[doc = " this call will increase the ref-count and return."]
    #[doc = ""]
    #[doc = " \\param flags subsystem initialization flags"]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_InitSubSystem"]
    #[doc = " \\sa SDL_Quit"]
    #[doc = " \\sa SDL_SetMainReady"]
    #[doc = " \\sa SDL_WasInit"]
    pub fn SDL_Init(flags: Uint32) -> libc::c_int;
}
extern "C" {
    #[doc = " Compatibility function to initialize the SDL library."]
    #[doc = ""]
    #[doc = " In SDL2, this function and SDL_Init() are interchangeable."]
    #[doc = ""]
    #[doc = " \\param flags any of the flags used by SDL_Init(); see SDL_Init for details."]
    #[doc = " \\returns 0 on success or a negative error code on failure; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_Init"]
    #[doc = " \\sa SDL_Quit"]
    #[doc = " \\sa SDL_QuitSubSystem"]
    pub fn SDL_InitSubSystem(flags: Uint32) -> libc::c_int;
}
extern "C" {
    #[doc = " Shut down specific SDL subsystems."]
    #[doc = ""]
    #[doc = " If you start a subsystem using a call to that subsystem's init function"]
    #[doc = " (for example SDL_VideoInit()) instead of SDL_Init() or SDL_InitSubSystem(),"]
    #[doc = " SDL_QuitSubSystem() and SDL_WasInit() will not work. You will need to use"]
    #[doc = " that subsystem's quit function (SDL_VideoQuit()) directly instead. But"]
    #[doc = " generally, you should not be using those functions directly anyhow; use"]
    #[doc = " SDL_Init() instead."]
    #[doc = ""]
    #[doc = " You still need to call SDL_Quit() even if you close all open subsystems"]
    #[doc = " with SDL_QuitSubSystem()."]
    #[doc = ""]
    #[doc = " \\param flags any of the flags used by SDL_Init(); see SDL_Init for details."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_InitSubSystem"]
    #[doc = " \\sa SDL_Quit"]
    pub fn SDL_QuitSubSystem(flags: Uint32);
}
extern "C" {
    #[doc = " Get a mask of the specified subsystems which are currently initialized."]
    #[doc = ""]
    #[doc = " \\param flags any of the flags used by SDL_Init(); see SDL_Init for details."]
    #[doc = " \\returns a mask of all initialized subsystems if `flags` is 0, otherwise it"]
    #[doc = "          returns the initialization status of the specified subsystems."]
    #[doc = ""]
    #[doc = "          The return value does not include SDL_INIT_NOPARACHUTE."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_Init"]
    #[doc = " \\sa SDL_InitSubSystem"]
    pub fn SDL_WasInit(flags: Uint32) -> Uint32;
}
extern "C" {
    #[doc = " Clean up all initialized subsystems."]
    #[doc = ""]
    #[doc = " You should call this function even if you have already shutdown each"]
    #[doc = " initialized subsystem with SDL_QuitSubSystem(). It is safe to call this"]
    #[doc = " function even in the case of errors in initialization."]
    #[doc = ""]
    #[doc = " If you start a subsystem using a call to that subsystem's init function"]
    #[doc = " (for example SDL_VideoInit()) instead of SDL_Init() or SDL_InitSubSystem(),"]
    #[doc = " then you must use that subsystem's quit function (SDL_VideoQuit()) to shut"]
    #[doc = " it down before calling SDL_Quit(). But generally, you should not be using"]
    #[doc = " those functions directly anyhow; use SDL_Init() instead."]
    #[doc = ""]
    #[doc = " You can use this function with atexit() to ensure that it is run when your"]
    #[doc = " application is shutdown, but it is not wise to do this from a library or"]
    #[doc = " other dynamically loaded code."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    #[doc = ""]
    #[doc = " \\sa SDL_Init"]
    #[doc = " \\sa SDL_QuitSubSystem"]
    pub fn SDL_Quit();
}
pub type XID = libc::c_ulong;
pub type Mask = libc::c_ulong;
pub type Atom = libc::c_ulong;
pub type VisualID = libc::c_ulong;
pub type Time = libc::c_ulong;
pub type Window = XID;
pub type Drawable = XID;
pub type Font = XID;
pub type Pixmap = XID;
pub type Cursor = XID;
pub type Colormap = XID;
pub type GContext = XID;
pub type KeySym = XID;
pub type KeyCode = libc::c_uchar;
extern "C" {
    pub fn _Xmblen(str: *mut libc::c_char, len: libc::c_int) -> libc::c_int;
}
pub type XPointer = *mut libc::c_char;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XExtData {
    pub number: libc::c_int,
    pub next: *mut _XExtData,
    pub free_private:
        ::core::option::Option<unsafe extern "C" fn(extension: *mut _XExtData) -> libc::c_int>,
    pub private_data: XPointer,
}
#[test]
fn bindgen_test_layout__XExtData() {
    assert_eq!(
        ::core::mem::size_of::<_XExtData>(),
        32usize,
        concat!("Size of: ", stringify!(_XExtData))
    );
    assert_eq!(
        ::core::mem::align_of::<_XExtData>(),
        8usize,
        concat!("Alignment of ", stringify!(_XExtData))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XExtData>())).number as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XExtData),
            "::",
            stringify!(number)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XExtData>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XExtData),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XExtData>())).free_private as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XExtData),
            "::",
            stringify!(free_private)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XExtData>())).private_data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_XExtData),
            "::",
            stringify!(private_data)
        )
    );
}
pub type XExtData = _XExtData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XExtCodes {
    pub extension: libc::c_int,
    pub major_opcode: libc::c_int,
    pub first_event: libc::c_int,
    pub first_error: libc::c_int,
}
#[test]
fn bindgen_test_layout_XExtCodes() {
    assert_eq!(
        ::core::mem::size_of::<XExtCodes>(),
        16usize,
        concat!("Size of: ", stringify!(XExtCodes))
    );
    assert_eq!(
        ::core::mem::align_of::<XExtCodes>(),
        4usize,
        concat!("Alignment of ", stringify!(XExtCodes))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XExtCodes>())).extension as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XExtCodes),
            "::",
            stringify!(extension)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XExtCodes>())).major_opcode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XExtCodes),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XExtCodes>())).first_event as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XExtCodes),
            "::",
            stringify!(first_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XExtCodes>())).first_error as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XExtCodes),
            "::",
            stringify!(first_error)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XPixmapFormatValues {
    pub depth: libc::c_int,
    pub bits_per_pixel: libc::c_int,
    pub scanline_pad: libc::c_int,
}
#[test]
fn bindgen_test_layout_XPixmapFormatValues() {
    assert_eq!(
        ::core::mem::size_of::<XPixmapFormatValues>(),
        12usize,
        concat!("Size of: ", stringify!(XPixmapFormatValues))
    );
    assert_eq!(
        ::core::mem::align_of::<XPixmapFormatValues>(),
        4usize,
        concat!("Alignment of ", stringify!(XPixmapFormatValues))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XPixmapFormatValues>())).depth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XPixmapFormatValues),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XPixmapFormatValues>())).bits_per_pixel as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XPixmapFormatValues),
            "::",
            stringify!(bits_per_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XPixmapFormatValues>())).scanline_pad as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XPixmapFormatValues),
            "::",
            stringify!(scanline_pad)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XGCValues {
    pub function: libc::c_int,
    pub plane_mask: libc::c_ulong,
    pub foreground: libc::c_ulong,
    pub background: libc::c_ulong,
    pub line_width: libc::c_int,
    pub line_style: libc::c_int,
    pub cap_style: libc::c_int,
    pub join_style: libc::c_int,
    pub fill_style: libc::c_int,
    pub fill_rule: libc::c_int,
    pub arc_mode: libc::c_int,
    pub tile: Pixmap,
    pub stipple: Pixmap,
    pub ts_x_origin: libc::c_int,
    pub ts_y_origin: libc::c_int,
    pub font: Font,
    pub subwindow_mode: libc::c_int,
    pub graphics_exposures: libc::c_int,
    pub clip_x_origin: libc::c_int,
    pub clip_y_origin: libc::c_int,
    pub clip_mask: Pixmap,
    pub dash_offset: libc::c_int,
    pub dashes: libc::c_char,
}
#[test]
fn bindgen_test_layout_XGCValues() {
    assert_eq!(
        ::core::mem::size_of::<XGCValues>(),
        128usize,
        concat!("Size of: ", stringify!(XGCValues))
    );
    assert_eq!(
        ::core::mem::align_of::<XGCValues>(),
        8usize,
        concat!("Alignment of ", stringify!(XGCValues))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGCValues>())).function as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGCValues>())).plane_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(plane_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGCValues>())).foreground as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(foreground)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGCValues>())).background as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(background)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGCValues>())).line_width as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(line_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGCValues>())).line_style as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(line_style)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGCValues>())).cap_style as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(cap_style)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGCValues>())).join_style as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(join_style)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGCValues>())).fill_style as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(fill_style)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGCValues>())).fill_rule as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(fill_rule)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGCValues>())).arc_mode as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(arc_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGCValues>())).tile as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(tile)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGCValues>())).stipple as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(stipple)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGCValues>())).ts_x_origin as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(ts_x_origin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGCValues>())).ts_y_origin as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(ts_y_origin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGCValues>())).font as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(font)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGCValues>())).subwindow_mode as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(subwindow_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGCValues>())).graphics_exposures as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(graphics_exposures)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGCValues>())).clip_x_origin as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(clip_x_origin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGCValues>())).clip_y_origin as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(clip_y_origin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGCValues>())).clip_mask as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(clip_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGCValues>())).dash_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(dash_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGCValues>())).dashes as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(dashes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XGC {
    _unused: [u8; 0],
}
pub type GC = *mut _XGC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Visual {
    pub ext_data: *mut XExtData,
    pub visualid: VisualID,
    pub class: libc::c_int,
    pub red_mask: libc::c_ulong,
    pub green_mask: libc::c_ulong,
    pub blue_mask: libc::c_ulong,
    pub bits_per_rgb: libc::c_int,
    pub map_entries: libc::c_int,
}
#[test]
fn bindgen_test_layout_Visual() {
    assert_eq!(
        ::core::mem::size_of::<Visual>(),
        56usize,
        concat!("Size of: ", stringify!(Visual))
    );
    assert_eq!(
        ::core::mem::align_of::<Visual>(),
        8usize,
        concat!("Alignment of ", stringify!(Visual))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Visual>())).ext_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(ext_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Visual>())).visualid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(visualid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Visual>())).class as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(class)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Visual>())).red_mask as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(red_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Visual>())).green_mask as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(green_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Visual>())).blue_mask as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(blue_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Visual>())).bits_per_rgb as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(bits_per_rgb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Visual>())).map_entries as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(map_entries)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Depth {
    pub depth: libc::c_int,
    pub nvisuals: libc::c_int,
    pub visuals: *mut Visual,
}
#[test]
fn bindgen_test_layout_Depth() {
    assert_eq!(
        ::core::mem::size_of::<Depth>(),
        16usize,
        concat!("Size of: ", stringify!(Depth))
    );
    assert_eq!(
        ::core::mem::align_of::<Depth>(),
        8usize,
        concat!("Alignment of ", stringify!(Depth))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Depth>())).depth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Depth),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Depth>())).nvisuals as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Depth),
            "::",
            stringify!(nvisuals)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Depth>())).visuals as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Depth),
            "::",
            stringify!(visuals)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XDisplay {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Screen {
    pub ext_data: *mut XExtData,
    pub display: *mut _XDisplay,
    pub root: Window,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub mwidth: libc::c_int,
    pub mheight: libc::c_int,
    pub ndepths: libc::c_int,
    pub depths: *mut Depth,
    pub root_depth: libc::c_int,
    pub root_visual: *mut Visual,
    pub default_gc: GC,
    pub cmap: Colormap,
    pub white_pixel: libc::c_ulong,
    pub black_pixel: libc::c_ulong,
    pub max_maps: libc::c_int,
    pub min_maps: libc::c_int,
    pub backing_store: libc::c_int,
    pub save_unders: libc::c_int,
    pub root_input_mask: libc::c_long,
}
#[test]
fn bindgen_test_layout_Screen() {
    assert_eq!(
        ::core::mem::size_of::<Screen>(),
        128usize,
        concat!("Size of: ", stringify!(Screen))
    );
    assert_eq!(
        ::core::mem::align_of::<Screen>(),
        8usize,
        concat!("Alignment of ", stringify!(Screen))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Screen>())).ext_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(ext_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Screen>())).display as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Screen>())).root as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Screen>())).width as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Screen>())).height as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Screen>())).mwidth as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(mwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Screen>())).mheight as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(mheight)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Screen>())).ndepths as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(ndepths)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Screen>())).depths as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(depths)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Screen>())).root_depth as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(root_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Screen>())).root_visual as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(root_visual)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Screen>())).default_gc as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(default_gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Screen>())).cmap as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Screen>())).white_pixel as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(white_pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Screen>())).black_pixel as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(black_pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Screen>())).max_maps as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(max_maps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Screen>())).min_maps as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(min_maps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Screen>())).backing_store as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(backing_store)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Screen>())).save_unders as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(save_unders)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Screen>())).root_input_mask as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(root_input_mask)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ScreenFormat {
    pub ext_data: *mut XExtData,
    pub depth: libc::c_int,
    pub bits_per_pixel: libc::c_int,
    pub scanline_pad: libc::c_int,
}
#[test]
fn bindgen_test_layout_ScreenFormat() {
    assert_eq!(
        ::core::mem::size_of::<ScreenFormat>(),
        24usize,
        concat!("Size of: ", stringify!(ScreenFormat))
    );
    assert_eq!(
        ::core::mem::align_of::<ScreenFormat>(),
        8usize,
        concat!("Alignment of ", stringify!(ScreenFormat))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ScreenFormat>())).ext_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ScreenFormat),
            "::",
            stringify!(ext_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ScreenFormat>())).depth as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ScreenFormat),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ScreenFormat>())).bits_per_pixel as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ScreenFormat),
            "::",
            stringify!(bits_per_pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ScreenFormat>())).scanline_pad as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ScreenFormat),
            "::",
            stringify!(scanline_pad)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XSetWindowAttributes {
    pub background_pixmap: Pixmap,
    pub background_pixel: libc::c_ulong,
    pub border_pixmap: Pixmap,
    pub border_pixel: libc::c_ulong,
    pub bit_gravity: libc::c_int,
    pub win_gravity: libc::c_int,
    pub backing_store: libc::c_int,
    pub backing_planes: libc::c_ulong,
    pub backing_pixel: libc::c_ulong,
    pub save_under: libc::c_int,
    pub event_mask: libc::c_long,
    pub do_not_propagate_mask: libc::c_long,
    pub override_redirect: libc::c_int,
    pub colormap: Colormap,
    pub cursor: Cursor,
}
#[test]
fn bindgen_test_layout_XSetWindowAttributes() {
    assert_eq!(
        ::core::mem::size_of::<XSetWindowAttributes>(),
        112usize,
        concat!("Size of: ", stringify!(XSetWindowAttributes))
    );
    assert_eq!(
        ::core::mem::align_of::<XSetWindowAttributes>(),
        8usize,
        concat!("Alignment of ", stringify!(XSetWindowAttributes))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XSetWindowAttributes>())).background_pixmap as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(background_pixmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XSetWindowAttributes>())).background_pixel as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(background_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XSetWindowAttributes>())).border_pixmap as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(border_pixmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XSetWindowAttributes>())).border_pixel as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(border_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XSetWindowAttributes>())).bit_gravity as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(bit_gravity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XSetWindowAttributes>())).win_gravity as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(win_gravity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XSetWindowAttributes>())).backing_store as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(backing_store)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XSetWindowAttributes>())).backing_planes as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(backing_planes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XSetWindowAttributes>())).backing_pixel as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(backing_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XSetWindowAttributes>())).save_under as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(save_under)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XSetWindowAttributes>())).event_mask as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(event_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XSetWindowAttributes>())).do_not_propagate_mask as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(do_not_propagate_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XSetWindowAttributes>())).override_redirect as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XSetWindowAttributes>())).colormap as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(colormap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XSetWindowAttributes>())).cursor as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(cursor)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XWindowAttributes {
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub border_width: libc::c_int,
    pub depth: libc::c_int,
    pub visual: *mut Visual,
    pub root: Window,
    pub class: libc::c_int,
    pub bit_gravity: libc::c_int,
    pub win_gravity: libc::c_int,
    pub backing_store: libc::c_int,
    pub backing_planes: libc::c_ulong,
    pub backing_pixel: libc::c_ulong,
    pub save_under: libc::c_int,
    pub colormap: Colormap,
    pub map_installed: libc::c_int,
    pub map_state: libc::c_int,
    pub all_event_masks: libc::c_long,
    pub your_event_mask: libc::c_long,
    pub do_not_propagate_mask: libc::c_long,
    pub override_redirect: libc::c_int,
    pub screen: *mut Screen,
}
#[test]
fn bindgen_test_layout_XWindowAttributes() {
    assert_eq!(
        ::core::mem::size_of::<XWindowAttributes>(),
        136usize,
        concat!("Size of: ", stringify!(XWindowAttributes))
    );
    assert_eq!(
        ::core::mem::align_of::<XWindowAttributes>(),
        8usize,
        concat!("Alignment of ", stringify!(XWindowAttributes))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XWindowAttributes>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XWindowAttributes>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XWindowAttributes>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XWindowAttributes>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XWindowAttributes>())).border_width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XWindowAttributes>())).depth as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XWindowAttributes>())).visual as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(visual)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XWindowAttributes>())).root as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XWindowAttributes>())).class as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(class)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XWindowAttributes>())).bit_gravity as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(bit_gravity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XWindowAttributes>())).win_gravity as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(win_gravity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XWindowAttributes>())).backing_store as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(backing_store)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XWindowAttributes>())).backing_planes as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(backing_planes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XWindowAttributes>())).backing_pixel as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(backing_pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XWindowAttributes>())).save_under as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(save_under)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XWindowAttributes>())).colormap as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(colormap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XWindowAttributes>())).map_installed as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(map_installed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XWindowAttributes>())).map_state as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(map_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XWindowAttributes>())).all_event_masks as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(all_event_masks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XWindowAttributes>())).your_event_mask as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(your_event_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XWindowAttributes>())).do_not_propagate_mask as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(do_not_propagate_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XWindowAttributes>())).override_redirect as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XWindowAttributes>())).screen as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(screen)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XHostAddress {
    pub family: libc::c_int,
    pub length: libc::c_int,
    pub address: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_XHostAddress() {
    assert_eq!(
        ::core::mem::size_of::<XHostAddress>(),
        16usize,
        concat!("Size of: ", stringify!(XHostAddress))
    );
    assert_eq!(
        ::core::mem::align_of::<XHostAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(XHostAddress))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XHostAddress>())).family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XHostAddress),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XHostAddress>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XHostAddress),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XHostAddress>())).address as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XHostAddress),
            "::",
            stringify!(address)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XServerInterpretedAddress {
    pub typelength: libc::c_int,
    pub valuelength: libc::c_int,
    pub type_: *mut libc::c_char,
    pub value: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_XServerInterpretedAddress() {
    assert_eq!(
        ::core::mem::size_of::<XServerInterpretedAddress>(),
        24usize,
        concat!("Size of: ", stringify!(XServerInterpretedAddress))
    );
    assert_eq!(
        ::core::mem::align_of::<XServerInterpretedAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(XServerInterpretedAddress))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XServerInterpretedAddress>())).typelength as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XServerInterpretedAddress),
            "::",
            stringify!(typelength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XServerInterpretedAddress>())).valuelength as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XServerInterpretedAddress),
            "::",
            stringify!(valuelength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XServerInterpretedAddress>())).type_ as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XServerInterpretedAddress),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XServerInterpretedAddress>())).value as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XServerInterpretedAddress),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XImage {
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub xoffset: libc::c_int,
    pub format: libc::c_int,
    pub data: *mut libc::c_char,
    pub byte_order: libc::c_int,
    pub bitmap_unit: libc::c_int,
    pub bitmap_bit_order: libc::c_int,
    pub bitmap_pad: libc::c_int,
    pub depth: libc::c_int,
    pub bytes_per_line: libc::c_int,
    pub bits_per_pixel: libc::c_int,
    pub red_mask: libc::c_ulong,
    pub green_mask: libc::c_ulong,
    pub blue_mask: libc::c_ulong,
    pub obdata: XPointer,
    pub f: _XImage_funcs,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XImage_funcs {
    pub create_image: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _XDisplay,
            arg2: *mut Visual,
            arg3: libc::c_uint,
            arg4: libc::c_int,
            arg5: libc::c_int,
            arg6: *mut libc::c_char,
            arg7: libc::c_uint,
            arg8: libc::c_uint,
            arg9: libc::c_int,
            arg10: libc::c_int,
        ) -> *mut _XImage,
    >,
    pub destroy_image:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut _XImage) -> libc::c_int>,
    pub get_pixel: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _XImage,
            arg2: libc::c_int,
            arg3: libc::c_int,
        ) -> libc::c_ulong,
    >,
    pub put_pixel: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _XImage,
            arg2: libc::c_int,
            arg3: libc::c_int,
            arg4: libc::c_ulong,
        ) -> libc::c_int,
    >,
    pub sub_image: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _XImage,
            arg2: libc::c_int,
            arg3: libc::c_int,
            arg4: libc::c_uint,
            arg5: libc::c_uint,
        ) -> *mut _XImage,
    >,
    pub add_pixel: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut _XImage, arg2: libc::c_long) -> libc::c_int,
    >,
}
#[test]
fn bindgen_test_layout__XImage_funcs() {
    assert_eq!(
        ::core::mem::size_of::<_XImage_funcs>(),
        48usize,
        concat!("Size of: ", stringify!(_XImage_funcs))
    );
    assert_eq!(
        ::core::mem::align_of::<_XImage_funcs>(),
        8usize,
        concat!("Alignment of ", stringify!(_XImage_funcs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XImage_funcs>())).create_image as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage_funcs),
            "::",
            stringify!(create_image)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XImage_funcs>())).destroy_image as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage_funcs),
            "::",
            stringify!(destroy_image)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XImage_funcs>())).get_pixel as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage_funcs),
            "::",
            stringify!(get_pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XImage_funcs>())).put_pixel as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage_funcs),
            "::",
            stringify!(put_pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XImage_funcs>())).sub_image as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage_funcs),
            "::",
            stringify!(sub_image)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XImage_funcs>())).add_pixel as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage_funcs),
            "::",
            stringify!(add_pixel)
        )
    );
}
#[test]
fn bindgen_test_layout__XImage() {
    assert_eq!(
        ::core::mem::size_of::<_XImage>(),
        136usize,
        concat!("Size of: ", stringify!(_XImage))
    );
    assert_eq!(
        ::core::mem::align_of::<_XImage>(),
        8usize,
        concat!("Alignment of ", stringify!(_XImage))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XImage>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XImage>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XImage>())).xoffset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(xoffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XImage>())).format as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XImage>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XImage>())).byte_order as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(byte_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XImage>())).bitmap_unit as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(bitmap_unit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XImage>())).bitmap_bit_order as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(bitmap_bit_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XImage>())).bitmap_pad as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(bitmap_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XImage>())).depth as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XImage>())).bytes_per_line as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(bytes_per_line)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XImage>())).bits_per_pixel as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(bits_per_pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XImage>())).red_mask as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(red_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XImage>())).green_mask as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(green_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XImage>())).blue_mask as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(blue_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XImage>())).obdata as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(obdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XImage>())).f as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(f)
        )
    );
}
pub type XImage = _XImage;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XWindowChanges {
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub border_width: libc::c_int,
    pub sibling: Window,
    pub stack_mode: libc::c_int,
}
#[test]
fn bindgen_test_layout_XWindowChanges() {
    assert_eq!(
        ::core::mem::size_of::<XWindowChanges>(),
        40usize,
        concat!("Size of: ", stringify!(XWindowChanges))
    );
    assert_eq!(
        ::core::mem::align_of::<XWindowChanges>(),
        8usize,
        concat!("Alignment of ", stringify!(XWindowChanges))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XWindowChanges>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowChanges),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XWindowChanges>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowChanges),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XWindowChanges>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowChanges),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XWindowChanges>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowChanges),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XWindowChanges>())).border_width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowChanges),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XWindowChanges>())).sibling as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowChanges),
            "::",
            stringify!(sibling)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XWindowChanges>())).stack_mode as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowChanges),
            "::",
            stringify!(stack_mode)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XColor {
    pub pixel: libc::c_ulong,
    pub red: libc::c_ushort,
    pub green: libc::c_ushort,
    pub blue: libc::c_ushort,
    pub flags: libc::c_char,
    pub pad: libc::c_char,
}
#[test]
fn bindgen_test_layout_XColor() {
    assert_eq!(
        ::core::mem::size_of::<XColor>(),
        16usize,
        concat!("Size of: ", stringify!(XColor))
    );
    assert_eq!(
        ::core::mem::align_of::<XColor>(),
        8usize,
        concat!("Alignment of ", stringify!(XColor))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XColor>())).pixel as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XColor),
            "::",
            stringify!(pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XColor>())).red as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XColor),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XColor>())).green as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(XColor),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XColor>())).blue as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XColor),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XColor>())).flags as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(XColor),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XColor>())).pad as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(XColor),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XSegment {
    pub x1: libc::c_short,
    pub y1: libc::c_short,
    pub x2: libc::c_short,
    pub y2: libc::c_short,
}
#[test]
fn bindgen_test_layout_XSegment() {
    assert_eq!(
        ::core::mem::size_of::<XSegment>(),
        8usize,
        concat!("Size of: ", stringify!(XSegment))
    );
    assert_eq!(
        ::core::mem::align_of::<XSegment>(),
        2usize,
        concat!("Alignment of ", stringify!(XSegment))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XSegment>())).x1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XSegment),
            "::",
            stringify!(x1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XSegment>())).y1 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(XSegment),
            "::",
            stringify!(y1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XSegment>())).x2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XSegment),
            "::",
            stringify!(x2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XSegment>())).y2 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(XSegment),
            "::",
            stringify!(y2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XPoint {
    pub x: libc::c_short,
    pub y: libc::c_short,
}
#[test]
fn bindgen_test_layout_XPoint() {
    assert_eq!(
        ::core::mem::size_of::<XPoint>(),
        4usize,
        concat!("Size of: ", stringify!(XPoint))
    );
    assert_eq!(
        ::core::mem::align_of::<XPoint>(),
        2usize,
        concat!("Alignment of ", stringify!(XPoint))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XPoint>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(XPoint), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XPoint>())).y as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(XPoint), "::", stringify!(y))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XRectangle {
    pub x: libc::c_short,
    pub y: libc::c_short,
    pub width: libc::c_ushort,
    pub height: libc::c_ushort,
}
#[test]
fn bindgen_test_layout_XRectangle() {
    assert_eq!(
        ::core::mem::size_of::<XRectangle>(),
        8usize,
        concat!("Size of: ", stringify!(XRectangle))
    );
    assert_eq!(
        ::core::mem::align_of::<XRectangle>(),
        2usize,
        concat!("Alignment of ", stringify!(XRectangle))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XRectangle>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XRectangle),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XRectangle>())).y as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(XRectangle),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XRectangle>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XRectangle),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XRectangle>())).height as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(XRectangle),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XArc {
    pub x: libc::c_short,
    pub y: libc::c_short,
    pub width: libc::c_ushort,
    pub height: libc::c_ushort,
    pub angle1: libc::c_short,
    pub angle2: libc::c_short,
}
#[test]
fn bindgen_test_layout_XArc() {
    assert_eq!(
        ::core::mem::size_of::<XArc>(),
        12usize,
        concat!("Size of: ", stringify!(XArc))
    );
    assert_eq!(
        ::core::mem::align_of::<XArc>(),
        2usize,
        concat!("Alignment of ", stringify!(XArc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XArc>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(XArc), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XArc>())).y as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(XArc), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XArc>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XArc),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XArc>())).height as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(XArc),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XArc>())).angle1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XArc),
            "::",
            stringify!(angle1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XArc>())).angle2 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(XArc),
            "::",
            stringify!(angle2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XKeyboardControl {
    pub key_click_percent: libc::c_int,
    pub bell_percent: libc::c_int,
    pub bell_pitch: libc::c_int,
    pub bell_duration: libc::c_int,
    pub led: libc::c_int,
    pub led_mode: libc::c_int,
    pub key: libc::c_int,
    pub auto_repeat_mode: libc::c_int,
}
#[test]
fn bindgen_test_layout_XKeyboardControl() {
    assert_eq!(
        ::core::mem::size_of::<XKeyboardControl>(),
        32usize,
        concat!("Size of: ", stringify!(XKeyboardControl))
    );
    assert_eq!(
        ::core::mem::align_of::<XKeyboardControl>(),
        4usize,
        concat!("Alignment of ", stringify!(XKeyboardControl))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XKeyboardControl>())).key_click_percent as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardControl),
            "::",
            stringify!(key_click_percent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeyboardControl>())).bell_percent as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardControl),
            "::",
            stringify!(bell_percent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeyboardControl>())).bell_pitch as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardControl),
            "::",
            stringify!(bell_pitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeyboardControl>())).bell_duration as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardControl),
            "::",
            stringify!(bell_duration)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeyboardControl>())).led as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardControl),
            "::",
            stringify!(led)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeyboardControl>())).led_mode as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardControl),
            "::",
            stringify!(led_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeyboardControl>())).key as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardControl),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XKeyboardControl>())).auto_repeat_mode as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardControl),
            "::",
            stringify!(auto_repeat_mode)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XKeyboardState {
    pub key_click_percent: libc::c_int,
    pub bell_percent: libc::c_int,
    pub bell_pitch: libc::c_uint,
    pub bell_duration: libc::c_uint,
    pub led_mask: libc::c_ulong,
    pub global_auto_repeat: libc::c_int,
    pub auto_repeats: [libc::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_XKeyboardState() {
    assert_eq!(
        ::core::mem::size_of::<XKeyboardState>(),
        64usize,
        concat!("Size of: ", stringify!(XKeyboardState))
    );
    assert_eq!(
        ::core::mem::align_of::<XKeyboardState>(),
        8usize,
        concat!("Alignment of ", stringify!(XKeyboardState))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XKeyboardState>())).key_click_percent as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardState),
            "::",
            stringify!(key_click_percent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeyboardState>())).bell_percent as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardState),
            "::",
            stringify!(bell_percent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeyboardState>())).bell_pitch as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardState),
            "::",
            stringify!(bell_pitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeyboardState>())).bell_duration as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardState),
            "::",
            stringify!(bell_duration)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeyboardState>())).led_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardState),
            "::",
            stringify!(led_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XKeyboardState>())).global_auto_repeat as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardState),
            "::",
            stringify!(global_auto_repeat)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeyboardState>())).auto_repeats as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardState),
            "::",
            stringify!(auto_repeats)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XTimeCoord {
    pub time: Time,
    pub x: libc::c_short,
    pub y: libc::c_short,
}
#[test]
fn bindgen_test_layout_XTimeCoord() {
    assert_eq!(
        ::core::mem::size_of::<XTimeCoord>(),
        16usize,
        concat!("Size of: ", stringify!(XTimeCoord))
    );
    assert_eq!(
        ::core::mem::align_of::<XTimeCoord>(),
        8usize,
        concat!("Alignment of ", stringify!(XTimeCoord))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XTimeCoord>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XTimeCoord),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XTimeCoord>())).x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XTimeCoord),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XTimeCoord>())).y as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(XTimeCoord),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XModifierKeymap {
    pub max_keypermod: libc::c_int,
    pub modifiermap: *mut KeyCode,
}
#[test]
fn bindgen_test_layout_XModifierKeymap() {
    assert_eq!(
        ::core::mem::size_of::<XModifierKeymap>(),
        16usize,
        concat!("Size of: ", stringify!(XModifierKeymap))
    );
    assert_eq!(
        ::core::mem::align_of::<XModifierKeymap>(),
        8usize,
        concat!("Alignment of ", stringify!(XModifierKeymap))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XModifierKeymap>())).max_keypermod as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XModifierKeymap),
            "::",
            stringify!(max_keypermod)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XModifierKeymap>())).modifiermap as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XModifierKeymap),
            "::",
            stringify!(modifiermap)
        )
    );
}
pub type Display = _XDisplay;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XPrivate {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XrmHashBucketRec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _bindgen_ty_1 {
    pub ext_data: *mut XExtData,
    pub private1: *mut _XPrivate,
    pub fd: libc::c_int,
    pub private2: libc::c_int,
    pub proto_major_version: libc::c_int,
    pub proto_minor_version: libc::c_int,
    pub vendor: *mut libc::c_char,
    pub private3: XID,
    pub private4: XID,
    pub private5: XID,
    pub private6: libc::c_int,
    pub resource_alloc: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _XDisplay) -> XID>,
    pub byte_order: libc::c_int,
    pub bitmap_unit: libc::c_int,
    pub bitmap_pad: libc::c_int,
    pub bitmap_bit_order: libc::c_int,
    pub nformats: libc::c_int,
    pub pixmap_format: *mut ScreenFormat,
    pub private8: libc::c_int,
    pub release: libc::c_int,
    pub private9: *mut _XPrivate,
    pub private10: *mut _XPrivate,
    pub qlen: libc::c_int,
    pub last_request_read: libc::c_ulong,
    pub request: libc::c_ulong,
    pub private11: XPointer,
    pub private12: XPointer,
    pub private13: XPointer,
    pub private14: XPointer,
    pub max_request_size: libc::c_uint,
    pub db: *mut _XrmHashBucketRec,
    pub private15:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut _XDisplay) -> libc::c_int>,
    pub display_name: *mut libc::c_char,
    pub default_screen: libc::c_int,
    pub nscreens: libc::c_int,
    pub screens: *mut Screen,
    pub motion_buffer: libc::c_ulong,
    pub private16: libc::c_ulong,
    pub min_keycode: libc::c_int,
    pub max_keycode: libc::c_int,
    pub private17: XPointer,
    pub private18: XPointer,
    pub private19: libc::c_int,
    pub xdefaults: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_bindgen_ty_1>(),
        296usize,
        concat!("Size of: ", stringify!(_bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).ext_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(ext_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).private1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).fd as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).private2 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_bindgen_ty_1>())).proto_major_version as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(proto_major_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_bindgen_ty_1>())).proto_minor_version as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(proto_minor_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).vendor as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(vendor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).private3 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).private4 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).private5 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).private6 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private6)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).resource_alloc as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(resource_alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).byte_order as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(byte_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).bitmap_unit as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(bitmap_unit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).bitmap_pad as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(bitmap_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).bitmap_bit_order as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(bitmap_bit_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).nformats as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(nformats)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).pixmap_format as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(pixmap_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).private8 as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private8)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).release as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).private9 as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private9)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).private10 as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private10)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).qlen as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(qlen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_bindgen_ty_1>())).last_request_read as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(last_request_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).request as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).private11 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private11)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).private12 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private12)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).private13 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private13)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).private14 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private14)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).max_request_size as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(max_request_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).db as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(db)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).private15 as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private15)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).display_name as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(display_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).default_screen as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(default_screen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).nscreens as *const _ as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(nscreens)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).screens as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(screens)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).motion_buffer as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(motion_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).private16 as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private16)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).min_keycode as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(min_keycode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).max_keycode as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(max_keycode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).private17 as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private17)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).private18 as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private18)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).private19 as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private19)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_bindgen_ty_1>())).xdefaults as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(xdefaults)
        )
    );
}
pub type _XPrivDisplay = *mut _bindgen_ty_1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XKeyEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub root: Window,
    pub subwindow: Window,
    pub time: Time,
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub x_root: libc::c_int,
    pub y_root: libc::c_int,
    pub state: libc::c_uint,
    pub keycode: libc::c_uint,
    pub same_screen: libc::c_int,
}
#[test]
fn bindgen_test_layout_XKeyEvent() {
    assert_eq!(
        ::core::mem::size_of::<XKeyEvent>(),
        96usize,
        concat!("Size of: ", stringify!(XKeyEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XKeyEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XKeyEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeyEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeyEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeyEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeyEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeyEvent>())).window as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeyEvent>())).root as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeyEvent>())).subwindow as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(subwindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeyEvent>())).time as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeyEvent>())).x as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeyEvent>())).y as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeyEvent>())).x_root as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(x_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeyEvent>())).y_root as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(y_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeyEvent>())).state as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeyEvent>())).keycode as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(keycode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeyEvent>())).same_screen as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(same_screen)
        )
    );
}
pub type XKeyPressedEvent = XKeyEvent;
pub type XKeyReleasedEvent = XKeyEvent;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XButtonEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub root: Window,
    pub subwindow: Window,
    pub time: Time,
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub x_root: libc::c_int,
    pub y_root: libc::c_int,
    pub state: libc::c_uint,
    pub button: libc::c_uint,
    pub same_screen: libc::c_int,
}
#[test]
fn bindgen_test_layout_XButtonEvent() {
    assert_eq!(
        ::core::mem::size_of::<XButtonEvent>(),
        96usize,
        concat!("Size of: ", stringify!(XButtonEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XButtonEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XButtonEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XButtonEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XButtonEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XButtonEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XButtonEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XButtonEvent>())).window as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XButtonEvent>())).root as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XButtonEvent>())).subwindow as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(subwindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XButtonEvent>())).time as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XButtonEvent>())).x as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XButtonEvent>())).y as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XButtonEvent>())).x_root as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(x_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XButtonEvent>())).y_root as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(y_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XButtonEvent>())).state as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XButtonEvent>())).button as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XButtonEvent>())).same_screen as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(same_screen)
        )
    );
}
pub type XButtonPressedEvent = XButtonEvent;
pub type XButtonReleasedEvent = XButtonEvent;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XMotionEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub root: Window,
    pub subwindow: Window,
    pub time: Time,
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub x_root: libc::c_int,
    pub y_root: libc::c_int,
    pub state: libc::c_uint,
    pub is_hint: libc::c_char,
    pub same_screen: libc::c_int,
}
#[test]
fn bindgen_test_layout_XMotionEvent() {
    assert_eq!(
        ::core::mem::size_of::<XMotionEvent>(),
        96usize,
        concat!("Size of: ", stringify!(XMotionEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XMotionEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XMotionEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMotionEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMotionEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMotionEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMotionEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMotionEvent>())).window as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMotionEvent>())).root as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMotionEvent>())).subwindow as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(subwindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMotionEvent>())).time as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMotionEvent>())).x as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMotionEvent>())).y as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMotionEvent>())).x_root as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(x_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMotionEvent>())).y_root as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(y_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMotionEvent>())).state as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMotionEvent>())).is_hint as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(is_hint)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMotionEvent>())).same_screen as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(same_screen)
        )
    );
}
pub type XPointerMovedEvent = XMotionEvent;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XCrossingEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub root: Window,
    pub subwindow: Window,
    pub time: Time,
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub x_root: libc::c_int,
    pub y_root: libc::c_int,
    pub mode: libc::c_int,
    pub detail: libc::c_int,
    pub same_screen: libc::c_int,
    pub focus: libc::c_int,
    pub state: libc::c_uint,
}
#[test]
fn bindgen_test_layout_XCrossingEvent() {
    assert_eq!(
        ::core::mem::size_of::<XCrossingEvent>(),
        104usize,
        concat!("Size of: ", stringify!(XCrossingEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XCrossingEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XCrossingEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).window as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).root as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).subwindow as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(subwindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).time as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).x as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).y as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).x_root as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(x_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).y_root as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(y_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).mode as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).detail as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).same_screen as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(same_screen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).focus as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(focus)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCrossingEvent>())).state as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(state)
        )
    );
}
pub type XEnterWindowEvent = XCrossingEvent;
pub type XLeaveWindowEvent = XCrossingEvent;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XFocusChangeEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub mode: libc::c_int,
    pub detail: libc::c_int,
}
#[test]
fn bindgen_test_layout_XFocusChangeEvent() {
    assert_eq!(
        ::core::mem::size_of::<XFocusChangeEvent>(),
        48usize,
        concat!("Size of: ", stringify!(XFocusChangeEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XFocusChangeEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XFocusChangeEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XFocusChangeEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XFocusChangeEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XFocusChangeEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XFocusChangeEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XFocusChangeEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XFocusChangeEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XFocusChangeEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XFocusChangeEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XFocusChangeEvent>())).window as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XFocusChangeEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XFocusChangeEvent>())).mode as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XFocusChangeEvent),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XFocusChangeEvent>())).detail as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XFocusChangeEvent),
            "::",
            stringify!(detail)
        )
    );
}
pub type XFocusInEvent = XFocusChangeEvent;
pub type XFocusOutEvent = XFocusChangeEvent;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XKeymapEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub key_vector: [libc::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_XKeymapEvent() {
    assert_eq!(
        ::core::mem::size_of::<XKeymapEvent>(),
        72usize,
        concat!("Size of: ", stringify!(XKeymapEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XKeymapEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XKeymapEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeymapEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeymapEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeymapEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeymapEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeymapEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeymapEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeymapEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeymapEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeymapEvent>())).window as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeymapEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XKeymapEvent>())).key_vector as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeymapEvent),
            "::",
            stringify!(key_vector)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XExposeEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub count: libc::c_int,
}
#[test]
fn bindgen_test_layout_XExposeEvent() {
    assert_eq!(
        ::core::mem::size_of::<XExposeEvent>(),
        64usize,
        concat!("Size of: ", stringify!(XExposeEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XExposeEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XExposeEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XExposeEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XExposeEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XExposeEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XExposeEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XExposeEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XExposeEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XExposeEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XExposeEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XExposeEvent>())).window as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XExposeEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XExposeEvent>())).x as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XExposeEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XExposeEvent>())).y as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XExposeEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XExposeEvent>())).width as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XExposeEvent),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XExposeEvent>())).height as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(XExposeEvent),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XExposeEvent>())).count as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XExposeEvent),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XGraphicsExposeEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub drawable: Drawable,
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub count: libc::c_int,
    pub major_code: libc::c_int,
    pub minor_code: libc::c_int,
}
#[test]
fn bindgen_test_layout_XGraphicsExposeEvent() {
    assert_eq!(
        ::core::mem::size_of::<XGraphicsExposeEvent>(),
        72usize,
        concat!("Size of: ", stringify!(XGraphicsExposeEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XGraphicsExposeEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XGraphicsExposeEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGraphicsExposeEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGraphicsExposeEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XGraphicsExposeEvent>())).send_event as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGraphicsExposeEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGraphicsExposeEvent>())).drawable as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGraphicsExposeEvent>())).x as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGraphicsExposeEvent>())).y as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGraphicsExposeEvent>())).width as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGraphicsExposeEvent>())).height as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGraphicsExposeEvent>())).count as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XGraphicsExposeEvent>())).major_code as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(major_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XGraphicsExposeEvent>())).minor_code as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(minor_code)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XNoExposeEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub drawable: Drawable,
    pub major_code: libc::c_int,
    pub minor_code: libc::c_int,
}
#[test]
fn bindgen_test_layout_XNoExposeEvent() {
    assert_eq!(
        ::core::mem::size_of::<XNoExposeEvent>(),
        48usize,
        concat!("Size of: ", stringify!(XNoExposeEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XNoExposeEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XNoExposeEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XNoExposeEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XNoExposeEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XNoExposeEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XNoExposeEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XNoExposeEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XNoExposeEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XNoExposeEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XNoExposeEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XNoExposeEvent>())).drawable as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XNoExposeEvent),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XNoExposeEvent>())).major_code as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XNoExposeEvent),
            "::",
            stringify!(major_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XNoExposeEvent>())).minor_code as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XNoExposeEvent),
            "::",
            stringify!(minor_code)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XVisibilityEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub state: libc::c_int,
}
#[test]
fn bindgen_test_layout_XVisibilityEvent() {
    assert_eq!(
        ::core::mem::size_of::<XVisibilityEvent>(),
        48usize,
        concat!("Size of: ", stringify!(XVisibilityEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XVisibilityEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XVisibilityEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XVisibilityEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XVisibilityEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XVisibilityEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XVisibilityEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XVisibilityEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XVisibilityEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XVisibilityEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XVisibilityEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XVisibilityEvent>())).window as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XVisibilityEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XVisibilityEvent>())).state as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XVisibilityEvent),
            "::",
            stringify!(state)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XCreateWindowEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub parent: Window,
    pub window: Window,
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub border_width: libc::c_int,
    pub override_redirect: libc::c_int,
}
#[test]
fn bindgen_test_layout_XCreateWindowEvent() {
    assert_eq!(
        ::core::mem::size_of::<XCreateWindowEvent>(),
        72usize,
        concat!("Size of: ", stringify!(XCreateWindowEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XCreateWindowEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XCreateWindowEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCreateWindowEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCreateWindowEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCreateWindowEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCreateWindowEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCreateWindowEvent>())).parent as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCreateWindowEvent>())).window as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCreateWindowEvent>())).x as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCreateWindowEvent>())).y as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCreateWindowEvent>())).width as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCreateWindowEvent>())).height as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XCreateWindowEvent>())).border_width as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XCreateWindowEvent>())).override_redirect as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(override_redirect)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XDestroyWindowEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
}
#[test]
fn bindgen_test_layout_XDestroyWindowEvent() {
    assert_eq!(
        ::core::mem::size_of::<XDestroyWindowEvent>(),
        48usize,
        concat!("Size of: ", stringify!(XDestroyWindowEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XDestroyWindowEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XDestroyWindowEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XDestroyWindowEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XDestroyWindowEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XDestroyWindowEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XDestroyWindowEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XDestroyWindowEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XDestroyWindowEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XDestroyWindowEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XDestroyWindowEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XDestroyWindowEvent>())).event as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XDestroyWindowEvent),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XDestroyWindowEvent>())).window as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XDestroyWindowEvent),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XUnmapEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
    pub from_configure: libc::c_int,
}
#[test]
fn bindgen_test_layout_XUnmapEvent() {
    assert_eq!(
        ::core::mem::size_of::<XUnmapEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XUnmapEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XUnmapEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XUnmapEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XUnmapEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XUnmapEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XUnmapEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XUnmapEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XUnmapEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XUnmapEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XUnmapEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XUnmapEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XUnmapEvent>())).event as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XUnmapEvent),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XUnmapEvent>())).window as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XUnmapEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XUnmapEvent>())).from_configure as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XUnmapEvent),
            "::",
            stringify!(from_configure)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XMapEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
    pub override_redirect: libc::c_int,
}
#[test]
fn bindgen_test_layout_XMapEvent() {
    assert_eq!(
        ::core::mem::size_of::<XMapEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XMapEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XMapEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XMapEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMapEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMapEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMapEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMapEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMapEvent>())).event as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapEvent),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMapEvent>())).window as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMapEvent>())).override_redirect as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapEvent),
            "::",
            stringify!(override_redirect)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XMapRequestEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub parent: Window,
    pub window: Window,
}
#[test]
fn bindgen_test_layout_XMapRequestEvent() {
    assert_eq!(
        ::core::mem::size_of::<XMapRequestEvent>(),
        48usize,
        concat!("Size of: ", stringify!(XMapRequestEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XMapRequestEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XMapRequestEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMapRequestEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapRequestEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMapRequestEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapRequestEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMapRequestEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapRequestEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMapRequestEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapRequestEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMapRequestEvent>())).parent as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapRequestEvent),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMapRequestEvent>())).window as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapRequestEvent),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XReparentEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
    pub parent: Window,
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub override_redirect: libc::c_int,
}
#[test]
fn bindgen_test_layout_XReparentEvent() {
    assert_eq!(
        ::core::mem::size_of::<XReparentEvent>(),
        72usize,
        concat!("Size of: ", stringify!(XReparentEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XReparentEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XReparentEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XReparentEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XReparentEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XReparentEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XReparentEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XReparentEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XReparentEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XReparentEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XReparentEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XReparentEvent>())).event as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XReparentEvent),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XReparentEvent>())).window as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XReparentEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XReparentEvent>())).parent as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XReparentEvent),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XReparentEvent>())).x as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XReparentEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XReparentEvent>())).y as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(XReparentEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XReparentEvent>())).override_redirect as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XReparentEvent),
            "::",
            stringify!(override_redirect)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XConfigureEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub border_width: libc::c_int,
    pub above: Window,
    pub override_redirect: libc::c_int,
}
#[test]
fn bindgen_test_layout_XConfigureEvent() {
    assert_eq!(
        ::core::mem::size_of::<XConfigureEvent>(),
        88usize,
        concat!("Size of: ", stringify!(XConfigureEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XConfigureEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XConfigureEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XConfigureEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XConfigureEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XConfigureEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XConfigureEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XConfigureEvent>())).event as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XConfigureEvent>())).window as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XConfigureEvent>())).x as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XConfigureEvent>())).y as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XConfigureEvent>())).width as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XConfigureEvent>())).height as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XConfigureEvent>())).border_width as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XConfigureEvent>())).above as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(above)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XConfigureEvent>())).override_redirect as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(override_redirect)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XGravityEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
    pub x: libc::c_int,
    pub y: libc::c_int,
}
#[test]
fn bindgen_test_layout_XGravityEvent() {
    assert_eq!(
        ::core::mem::size_of::<XGravityEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XGravityEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XGravityEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XGravityEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGravityEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XGravityEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGravityEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XGravityEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGravityEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XGravityEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGravityEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XGravityEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGravityEvent>())).event as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XGravityEvent),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGravityEvent>())).window as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XGravityEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGravityEvent>())).x as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XGravityEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGravityEvent>())).y as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(XGravityEvent),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XResizeRequestEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub width: libc::c_int,
    pub height: libc::c_int,
}
#[test]
fn bindgen_test_layout_XResizeRequestEvent() {
    assert_eq!(
        ::core::mem::size_of::<XResizeRequestEvent>(),
        48usize,
        concat!("Size of: ", stringify!(XResizeRequestEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XResizeRequestEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XResizeRequestEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XResizeRequestEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XResizeRequestEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XResizeRequestEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XResizeRequestEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XResizeRequestEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XResizeRequestEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XResizeRequestEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XResizeRequestEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XResizeRequestEvent>())).window as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XResizeRequestEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XResizeRequestEvent>())).width as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XResizeRequestEvent),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XResizeRequestEvent>())).height as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XResizeRequestEvent),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XConfigureRequestEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub parent: Window,
    pub window: Window,
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub border_width: libc::c_int,
    pub above: Window,
    pub detail: libc::c_int,
    pub value_mask: libc::c_ulong,
}
#[test]
fn bindgen_test_layout_XConfigureRequestEvent() {
    assert_eq!(
        ::core::mem::size_of::<XConfigureRequestEvent>(),
        96usize,
        concat!("Size of: ", stringify!(XConfigureRequestEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XConfigureRequestEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XConfigureRequestEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XConfigureRequestEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XConfigureRequestEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XConfigureRequestEvent>())).send_event as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XConfigureRequestEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XConfigureRequestEvent>())).parent as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XConfigureRequestEvent>())).window as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XConfigureRequestEvent>())).x as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XConfigureRequestEvent>())).y as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XConfigureRequestEvent>())).width as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XConfigureRequestEvent>())).height as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XConfigureRequestEvent>())).border_width as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XConfigureRequestEvent>())).above as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(above)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XConfigureRequestEvent>())).detail as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XConfigureRequestEvent>())).value_mask as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(value_mask)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XCirculateEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
    pub place: libc::c_int,
}
#[test]
fn bindgen_test_layout_XCirculateEvent() {
    assert_eq!(
        ::core::mem::size_of::<XCirculateEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XCirculateEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XCirculateEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XCirculateEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCirculateEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCirculateEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCirculateEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCirculateEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCirculateEvent>())).event as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateEvent),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCirculateEvent>())).window as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCirculateEvent>())).place as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateEvent),
            "::",
            stringify!(place)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XCirculateRequestEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub parent: Window,
    pub window: Window,
    pub place: libc::c_int,
}
#[test]
fn bindgen_test_layout_XCirculateRequestEvent() {
    assert_eq!(
        ::core::mem::size_of::<XCirculateRequestEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XCirculateRequestEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XCirculateRequestEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XCirculateRequestEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCirculateRequestEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateRequestEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCirculateRequestEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateRequestEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XCirculateRequestEvent>())).send_event as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateRequestEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCirculateRequestEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateRequestEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCirculateRequestEvent>())).parent as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateRequestEvent),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCirculateRequestEvent>())).window as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateRequestEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCirculateRequestEvent>())).place as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateRequestEvent),
            "::",
            stringify!(place)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XPropertyEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub atom: Atom,
    pub time: Time,
    pub state: libc::c_int,
}
#[test]
fn bindgen_test_layout_XPropertyEvent() {
    assert_eq!(
        ::core::mem::size_of::<XPropertyEvent>(),
        64usize,
        concat!("Size of: ", stringify!(XPropertyEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XPropertyEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XPropertyEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XPropertyEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XPropertyEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XPropertyEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XPropertyEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XPropertyEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XPropertyEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XPropertyEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XPropertyEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XPropertyEvent>())).window as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XPropertyEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XPropertyEvent>())).atom as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XPropertyEvent),
            "::",
            stringify!(atom)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XPropertyEvent>())).time as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XPropertyEvent),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XPropertyEvent>())).state as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XPropertyEvent),
            "::",
            stringify!(state)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XSelectionClearEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub selection: Atom,
    pub time: Time,
}
#[test]
fn bindgen_test_layout_XSelectionClearEvent() {
    assert_eq!(
        ::core::mem::size_of::<XSelectionClearEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XSelectionClearEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XSelectionClearEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XSelectionClearEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XSelectionClearEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionClearEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XSelectionClearEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionClearEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XSelectionClearEvent>())).send_event as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionClearEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XSelectionClearEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionClearEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XSelectionClearEvent>())).window as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionClearEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XSelectionClearEvent>())).selection as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionClearEvent),
            "::",
            stringify!(selection)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XSelectionClearEvent>())).time as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionClearEvent),
            "::",
            stringify!(time)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XSelectionRequestEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub owner: Window,
    pub requestor: Window,
    pub selection: Atom,
    pub target: Atom,
    pub property: Atom,
    pub time: Time,
}
#[test]
fn bindgen_test_layout_XSelectionRequestEvent() {
    assert_eq!(
        ::core::mem::size_of::<XSelectionRequestEvent>(),
        80usize,
        concat!("Size of: ", stringify!(XSelectionRequestEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XSelectionRequestEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XSelectionRequestEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XSelectionRequestEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionRequestEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XSelectionRequestEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionRequestEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XSelectionRequestEvent>())).send_event as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionRequestEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XSelectionRequestEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionRequestEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XSelectionRequestEvent>())).owner as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionRequestEvent),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XSelectionRequestEvent>())).requestor as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionRequestEvent),
            "::",
            stringify!(requestor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XSelectionRequestEvent>())).selection as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionRequestEvent),
            "::",
            stringify!(selection)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XSelectionRequestEvent>())).target as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionRequestEvent),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XSelectionRequestEvent>())).property as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionRequestEvent),
            "::",
            stringify!(property)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XSelectionRequestEvent>())).time as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionRequestEvent),
            "::",
            stringify!(time)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XSelectionEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub requestor: Window,
    pub selection: Atom,
    pub target: Atom,
    pub property: Atom,
    pub time: Time,
}
#[test]
fn bindgen_test_layout_XSelectionEvent() {
    assert_eq!(
        ::core::mem::size_of::<XSelectionEvent>(),
        72usize,
        concat!("Size of: ", stringify!(XSelectionEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XSelectionEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XSelectionEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XSelectionEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XSelectionEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XSelectionEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XSelectionEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XSelectionEvent>())).requestor as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionEvent),
            "::",
            stringify!(requestor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XSelectionEvent>())).selection as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionEvent),
            "::",
            stringify!(selection)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XSelectionEvent>())).target as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionEvent),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XSelectionEvent>())).property as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionEvent),
            "::",
            stringify!(property)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XSelectionEvent>())).time as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionEvent),
            "::",
            stringify!(time)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XColormapEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub colormap: Colormap,
    pub new: libc::c_int,
    pub state: libc::c_int,
}
#[test]
fn bindgen_test_layout_XColormapEvent() {
    assert_eq!(
        ::core::mem::size_of::<XColormapEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XColormapEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XColormapEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XColormapEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XColormapEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XColormapEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XColormapEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XColormapEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XColormapEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XColormapEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XColormapEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XColormapEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XColormapEvent>())).window as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XColormapEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XColormapEvent>())).colormap as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XColormapEvent),
            "::",
            stringify!(colormap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XColormapEvent>())).new as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XColormapEvent),
            "::",
            stringify!(new)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XColormapEvent>())).state as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(XColormapEvent),
            "::",
            stringify!(state)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XClientMessageEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub message_type: Atom,
    pub format: libc::c_int,
    pub data: XClientMessageEvent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union XClientMessageEvent__bindgen_ty_1 {
    pub b: [libc::c_char; 20usize],
    pub s: [libc::c_short; 10usize],
    pub l: [libc::c_long; 5usize],
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_XClientMessageEvent__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<XClientMessageEvent__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(XClientMessageEvent__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<XClientMessageEvent__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(XClientMessageEvent__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XClientMessageEvent__bindgen_ty_1>())).b as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent__bindgen_ty_1),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XClientMessageEvent__bindgen_ty_1>())).s as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent__bindgen_ty_1),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XClientMessageEvent__bindgen_ty_1>())).l as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent__bindgen_ty_1),
            "::",
            stringify!(l)
        )
    );
}
#[test]
fn bindgen_test_layout_XClientMessageEvent() {
    assert_eq!(
        ::core::mem::size_of::<XClientMessageEvent>(),
        96usize,
        concat!("Size of: ", stringify!(XClientMessageEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XClientMessageEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XClientMessageEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XClientMessageEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XClientMessageEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XClientMessageEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XClientMessageEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XClientMessageEvent>())).window as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XClientMessageEvent>())).message_type as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent),
            "::",
            stringify!(message_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XClientMessageEvent>())).format as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XClientMessageEvent>())).data as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XMappingEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub request: libc::c_int,
    pub first_keycode: libc::c_int,
    pub count: libc::c_int,
}
#[test]
fn bindgen_test_layout_XMappingEvent() {
    assert_eq!(
        ::core::mem::size_of::<XMappingEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XMappingEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XMappingEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XMappingEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMappingEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XMappingEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMappingEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XMappingEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMappingEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XMappingEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMappingEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XMappingEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMappingEvent>())).window as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XMappingEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMappingEvent>())).request as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XMappingEvent),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMappingEvent>())).first_keycode as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XMappingEvent),
            "::",
            stringify!(first_keycode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XMappingEvent>())).count as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XMappingEvent),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XErrorEvent {
    pub type_: libc::c_int,
    pub display: *mut Display,
    pub resourceid: XID,
    pub serial: libc::c_ulong,
    pub error_code: libc::c_uchar,
    pub request_code: libc::c_uchar,
    pub minor_code: libc::c_uchar,
}
#[test]
fn bindgen_test_layout_XErrorEvent() {
    assert_eq!(
        ::core::mem::size_of::<XErrorEvent>(),
        40usize,
        concat!("Size of: ", stringify!(XErrorEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XErrorEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XErrorEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XErrorEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XErrorEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XErrorEvent>())).display as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XErrorEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XErrorEvent>())).resourceid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XErrorEvent),
            "::",
            stringify!(resourceid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XErrorEvent>())).serial as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XErrorEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XErrorEvent>())).error_code as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XErrorEvent),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XErrorEvent>())).request_code as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(XErrorEvent),
            "::",
            stringify!(request_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XErrorEvent>())).minor_code as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(XErrorEvent),
            "::",
            stringify!(minor_code)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XAnyEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
}
#[test]
fn bindgen_test_layout_XAnyEvent() {
    assert_eq!(
        ::core::mem::size_of::<XAnyEvent>(),
        40usize,
        concat!("Size of: ", stringify!(XAnyEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XAnyEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XAnyEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XAnyEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XAnyEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XAnyEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XAnyEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XAnyEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XAnyEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XAnyEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XAnyEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XAnyEvent>())).window as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XAnyEvent),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XGenericEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub extension: libc::c_int,
    pub evtype: libc::c_int,
}
#[test]
fn bindgen_test_layout_XGenericEvent() {
    assert_eq!(
        ::core::mem::size_of::<XGenericEvent>(),
        40usize,
        concat!("Size of: ", stringify!(XGenericEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XGenericEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XGenericEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGenericEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGenericEvent>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGenericEvent>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGenericEvent>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGenericEvent>())).extension as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEvent),
            "::",
            stringify!(extension)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGenericEvent>())).evtype as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEvent),
            "::",
            stringify!(evtype)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XGenericEventCookie {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub extension: libc::c_int,
    pub evtype: libc::c_int,
    pub cookie: libc::c_uint,
    pub data: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_XGenericEventCookie() {
    assert_eq!(
        ::core::mem::size_of::<XGenericEventCookie>(),
        56usize,
        concat!("Size of: ", stringify!(XGenericEventCookie))
    );
    assert_eq!(
        ::core::mem::align_of::<XGenericEventCookie>(),
        8usize,
        concat!("Alignment of ", stringify!(XGenericEventCookie))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGenericEventCookie>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEventCookie),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGenericEventCookie>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEventCookie),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGenericEventCookie>())).send_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEventCookie),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGenericEventCookie>())).display as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEventCookie),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGenericEventCookie>())).extension as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEventCookie),
            "::",
            stringify!(extension)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGenericEventCookie>())).evtype as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEventCookie),
            "::",
            stringify!(evtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGenericEventCookie>())).cookie as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEventCookie),
            "::",
            stringify!(cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XGenericEventCookie>())).data as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEventCookie),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _XEvent {
    pub type_: libc::c_int,
    pub xany: XAnyEvent,
    pub xkey: XKeyEvent,
    pub xbutton: XButtonEvent,
    pub xmotion: XMotionEvent,
    pub xcrossing: XCrossingEvent,
    pub xfocus: XFocusChangeEvent,
    pub xexpose: XExposeEvent,
    pub xgraphicsexpose: XGraphicsExposeEvent,
    pub xnoexpose: XNoExposeEvent,
    pub xvisibility: XVisibilityEvent,
    pub xcreatewindow: XCreateWindowEvent,
    pub xdestroywindow: XDestroyWindowEvent,
    pub xunmap: XUnmapEvent,
    pub xmap: XMapEvent,
    pub xmaprequest: XMapRequestEvent,
    pub xreparent: XReparentEvent,
    pub xconfigure: XConfigureEvent,
    pub xgravity: XGravityEvent,
    pub xresizerequest: XResizeRequestEvent,
    pub xconfigurerequest: XConfigureRequestEvent,
    pub xcirculate: XCirculateEvent,
    pub xcirculaterequest: XCirculateRequestEvent,
    pub xproperty: XPropertyEvent,
    pub xselectionclear: XSelectionClearEvent,
    pub xselectionrequest: XSelectionRequestEvent,
    pub xselection: XSelectionEvent,
    pub xcolormap: XColormapEvent,
    pub xclient: XClientMessageEvent,
    pub xmapping: XMappingEvent,
    pub xerror: XErrorEvent,
    pub xkeymap: XKeymapEvent,
    pub xgeneric: XGenericEvent,
    pub xcookie: XGenericEventCookie,
    pub pad: [libc::c_long; 24usize],
    _bindgen_union_align: [u64; 24usize],
}
#[test]
fn bindgen_test_layout__XEvent() {
    assert_eq!(
        ::core::mem::size_of::<_XEvent>(),
        192usize,
        concat!("Size of: ", stringify!(_XEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<_XEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(_XEvent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xany as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xany)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xkey as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xbutton as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xbutton)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xmotion as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xmotion)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xcrossing as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xcrossing)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xfocus as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xfocus)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xexpose as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xexpose)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xgraphicsexpose as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xgraphicsexpose)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xnoexpose as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xnoexpose)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xvisibility as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xvisibility)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xcreatewindow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xcreatewindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xdestroywindow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xdestroywindow)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xunmap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xunmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xmap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xmaprequest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xmaprequest)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xreparent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xreparent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xconfigure as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xconfigure)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xgravity as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xgravity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xresizerequest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xresizerequest)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xconfigurerequest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xconfigurerequest)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xcirculate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xcirculate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xcirculaterequest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xcirculaterequest)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xproperty as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xproperty)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xselectionclear as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xselectionclear)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xselectionrequest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xselectionrequest)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xselection as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xselection)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xcolormap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xcolormap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xclient as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xclient)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xmapping as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xmapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xerror as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xerror)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xkeymap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xkeymap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xgeneric as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xgeneric)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).xcookie as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xcookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XEvent>())).pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(pad)
        )
    );
}
pub type XEvent = _XEvent;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XCharStruct {
    pub lbearing: libc::c_short,
    pub rbearing: libc::c_short,
    pub width: libc::c_short,
    pub ascent: libc::c_short,
    pub descent: libc::c_short,
    pub attributes: libc::c_ushort,
}
#[test]
fn bindgen_test_layout_XCharStruct() {
    assert_eq!(
        ::core::mem::size_of::<XCharStruct>(),
        12usize,
        concat!("Size of: ", stringify!(XCharStruct))
    );
    assert_eq!(
        ::core::mem::align_of::<XCharStruct>(),
        2usize,
        concat!("Alignment of ", stringify!(XCharStruct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCharStruct>())).lbearing as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XCharStruct),
            "::",
            stringify!(lbearing)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCharStruct>())).rbearing as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(XCharStruct),
            "::",
            stringify!(rbearing)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCharStruct>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XCharStruct),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCharStruct>())).ascent as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(XCharStruct),
            "::",
            stringify!(ascent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCharStruct>())).descent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XCharStruct),
            "::",
            stringify!(descent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XCharStruct>())).attributes as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(XCharStruct),
            "::",
            stringify!(attributes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XFontProp {
    pub name: Atom,
    pub card32: libc::c_ulong,
}
#[test]
fn bindgen_test_layout_XFontProp() {
    assert_eq!(
        ::core::mem::size_of::<XFontProp>(),
        16usize,
        concat!("Size of: ", stringify!(XFontProp))
    );
    assert_eq!(
        ::core::mem::align_of::<XFontProp>(),
        8usize,
        concat!("Alignment of ", stringify!(XFontProp))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XFontProp>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontProp),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XFontProp>())).card32 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontProp),
            "::",
            stringify!(card32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XFontStruct {
    pub ext_data: *mut XExtData,
    pub fid: Font,
    pub direction: libc::c_uint,
    pub min_char_or_byte2: libc::c_uint,
    pub max_char_or_byte2: libc::c_uint,
    pub min_byte1: libc::c_uint,
    pub max_byte1: libc::c_uint,
    pub all_chars_exist: libc::c_int,
    pub default_char: libc::c_uint,
    pub n_properties: libc::c_int,
    pub properties: *mut XFontProp,
    pub min_bounds: XCharStruct,
    pub max_bounds: XCharStruct,
    pub per_char: *mut XCharStruct,
    pub ascent: libc::c_int,
    pub descent: libc::c_int,
}
#[test]
fn bindgen_test_layout_XFontStruct() {
    assert_eq!(
        ::core::mem::size_of::<XFontStruct>(),
        96usize,
        concat!("Size of: ", stringify!(XFontStruct))
    );
    assert_eq!(
        ::core::mem::align_of::<XFontStruct>(),
        8usize,
        concat!("Alignment of ", stringify!(XFontStruct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XFontStruct>())).ext_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(ext_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XFontStruct>())).fid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(fid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XFontStruct>())).direction as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XFontStruct>())).min_char_or_byte2 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(min_char_or_byte2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XFontStruct>())).max_char_or_byte2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(max_char_or_byte2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XFontStruct>())).min_byte1 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(min_byte1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XFontStruct>())).max_byte1 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(max_byte1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XFontStruct>())).all_chars_exist as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(all_chars_exist)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XFontStruct>())).default_char as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(default_char)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XFontStruct>())).n_properties as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(n_properties)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XFontStruct>())).properties as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(properties)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XFontStruct>())).min_bounds as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(min_bounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XFontStruct>())).max_bounds as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(max_bounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XFontStruct>())).per_char as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(per_char)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XFontStruct>())).ascent as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(ascent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XFontStruct>())).descent as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(descent)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XTextItem {
    pub chars: *mut libc::c_char,
    pub nchars: libc::c_int,
    pub delta: libc::c_int,
    pub font: Font,
}
#[test]
fn bindgen_test_layout_XTextItem() {
    assert_eq!(
        ::core::mem::size_of::<XTextItem>(),
        24usize,
        concat!("Size of: ", stringify!(XTextItem))
    );
    assert_eq!(
        ::core::mem::align_of::<XTextItem>(),
        8usize,
        concat!("Alignment of ", stringify!(XTextItem))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XTextItem>())).chars as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XTextItem),
            "::",
            stringify!(chars)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XTextItem>())).nchars as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XTextItem),
            "::",
            stringify!(nchars)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XTextItem>())).delta as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XTextItem),
            "::",
            stringify!(delta)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XTextItem>())).font as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XTextItem),
            "::",
            stringify!(font)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XChar2b {
    pub byte1: libc::c_uchar,
    pub byte2: libc::c_uchar,
}
#[test]
fn bindgen_test_layout_XChar2b() {
    assert_eq!(
        ::core::mem::size_of::<XChar2b>(),
        2usize,
        concat!("Size of: ", stringify!(XChar2b))
    );
    assert_eq!(
        ::core::mem::align_of::<XChar2b>(),
        1usize,
        concat!("Alignment of ", stringify!(XChar2b))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XChar2b>())).byte1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XChar2b),
            "::",
            stringify!(byte1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XChar2b>())).byte2 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(XChar2b),
            "::",
            stringify!(byte2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XTextItem16 {
    pub chars: *mut XChar2b,
    pub nchars: libc::c_int,
    pub delta: libc::c_int,
    pub font: Font,
}
#[test]
fn bindgen_test_layout_XTextItem16() {
    assert_eq!(
        ::core::mem::size_of::<XTextItem16>(),
        24usize,
        concat!("Size of: ", stringify!(XTextItem16))
    );
    assert_eq!(
        ::core::mem::align_of::<XTextItem16>(),
        8usize,
        concat!("Alignment of ", stringify!(XTextItem16))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XTextItem16>())).chars as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XTextItem16),
            "::",
            stringify!(chars)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XTextItem16>())).nchars as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XTextItem16),
            "::",
            stringify!(nchars)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XTextItem16>())).delta as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XTextItem16),
            "::",
            stringify!(delta)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XTextItem16>())).font as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XTextItem16),
            "::",
            stringify!(font)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union XEDataObject {
    pub display: *mut Display,
    pub gc: GC,
    pub visual: *mut Visual,
    pub screen: *mut Screen,
    pub pixmap_format: *mut ScreenFormat,
    pub font: *mut XFontStruct,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_XEDataObject() {
    assert_eq!(
        ::core::mem::size_of::<XEDataObject>(),
        8usize,
        concat!("Size of: ", stringify!(XEDataObject))
    );
    assert_eq!(
        ::core::mem::align_of::<XEDataObject>(),
        8usize,
        concat!("Alignment of ", stringify!(XEDataObject))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XEDataObject>())).display as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XEDataObject),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XEDataObject>())).gc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XEDataObject),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XEDataObject>())).visual as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XEDataObject),
            "::",
            stringify!(visual)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XEDataObject>())).screen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XEDataObject),
            "::",
            stringify!(screen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XEDataObject>())).pixmap_format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XEDataObject),
            "::",
            stringify!(pixmap_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XEDataObject>())).font as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XEDataObject),
            "::",
            stringify!(font)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XFontSetExtents {
    pub max_ink_extent: XRectangle,
    pub max_logical_extent: XRectangle,
}
#[test]
fn bindgen_test_layout_XFontSetExtents() {
    assert_eq!(
        ::core::mem::size_of::<XFontSetExtents>(),
        16usize,
        concat!("Size of: ", stringify!(XFontSetExtents))
    );
    assert_eq!(
        ::core::mem::align_of::<XFontSetExtents>(),
        2usize,
        concat!("Alignment of ", stringify!(XFontSetExtents))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XFontSetExtents>())).max_ink_extent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontSetExtents),
            "::",
            stringify!(max_ink_extent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<XFontSetExtents>())).max_logical_extent as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontSetExtents),
            "::",
            stringify!(max_logical_extent)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XOM {
    _unused: [u8; 0],
}
pub type XOM = *mut _XOM;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XOC {
    _unused: [u8; 0],
}
pub type XOC = *mut _XOC;
pub type XFontSet = *mut _XOC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XmbTextItem {
    pub chars: *mut libc::c_char,
    pub nchars: libc::c_int,
    pub delta: libc::c_int,
    pub font_set: XFontSet,
}
#[test]
fn bindgen_test_layout_XmbTextItem() {
    assert_eq!(
        ::core::mem::size_of::<XmbTextItem>(),
        24usize,
        concat!("Size of: ", stringify!(XmbTextItem))
    );
    assert_eq!(
        ::core::mem::align_of::<XmbTextItem>(),
        8usize,
        concat!("Alignment of ", stringify!(XmbTextItem))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XmbTextItem>())).chars as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XmbTextItem),
            "::",
            stringify!(chars)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XmbTextItem>())).nchars as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XmbTextItem),
            "::",
            stringify!(nchars)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XmbTextItem>())).delta as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XmbTextItem),
            "::",
            stringify!(delta)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XmbTextItem>())).font_set as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XmbTextItem),
            "::",
            stringify!(font_set)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XwcTextItem {
    pub chars: *mut wchar_t,
    pub nchars: libc::c_int,
    pub delta: libc::c_int,
    pub font_set: XFontSet,
}
#[test]
fn bindgen_test_layout_XwcTextItem() {
    assert_eq!(
        ::core::mem::size_of::<XwcTextItem>(),
        24usize,
        concat!("Size of: ", stringify!(XwcTextItem))
    );
    assert_eq!(
        ::core::mem::align_of::<XwcTextItem>(),
        8usize,
        concat!("Alignment of ", stringify!(XwcTextItem))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XwcTextItem>())).chars as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XwcTextItem),
            "::",
            stringify!(chars)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XwcTextItem>())).nchars as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XwcTextItem),
            "::",
            stringify!(nchars)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XwcTextItem>())).delta as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XwcTextItem),
            "::",
            stringify!(delta)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XwcTextItem>())).font_set as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XwcTextItem),
            "::",
            stringify!(font_set)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XOMCharSetList {
    pub charset_count: libc::c_int,
    pub charset_list: *mut *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_XOMCharSetList() {
    assert_eq!(
        ::core::mem::size_of::<XOMCharSetList>(),
        16usize,
        concat!("Size of: ", stringify!(XOMCharSetList))
    );
    assert_eq!(
        ::core::mem::align_of::<XOMCharSetList>(),
        8usize,
        concat!("Alignment of ", stringify!(XOMCharSetList))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XOMCharSetList>())).charset_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XOMCharSetList),
            "::",
            stringify!(charset_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XOMCharSetList>())).charset_list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XOMCharSetList),
            "::",
            stringify!(charset_list)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum XOrientation {
    XOMOrientation_LTR_TTB = 0,
    XOMOrientation_RTL_TTB = 1,
    XOMOrientation_TTB_LTR = 2,
    XOMOrientation_TTB_RTL = 3,
    XOMOrientation_Context = 4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XOMOrientation {
    pub num_orientation: libc::c_int,
    pub orientation: *mut XOrientation,
}
#[test]
fn bindgen_test_layout_XOMOrientation() {
    assert_eq!(
        ::core::mem::size_of::<XOMOrientation>(),
        16usize,
        concat!("Size of: ", stringify!(XOMOrientation))
    );
    assert_eq!(
        ::core::mem::align_of::<XOMOrientation>(),
        8usize,
        concat!("Alignment of ", stringify!(XOMOrientation))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XOMOrientation>())).num_orientation as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XOMOrientation),
            "::",
            stringify!(num_orientation)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XOMOrientation>())).orientation as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XOMOrientation),
            "::",
            stringify!(orientation)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XOMFontInfo {
    pub num_font: libc::c_int,
    pub font_struct_list: *mut *mut XFontStruct,
    pub font_name_list: *mut *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_XOMFontInfo() {
    assert_eq!(
        ::core::mem::size_of::<XOMFontInfo>(),
        24usize,
        concat!("Size of: ", stringify!(XOMFontInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<XOMFontInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(XOMFontInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XOMFontInfo>())).num_font as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XOMFontInfo),
            "::",
            stringify!(num_font)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XOMFontInfo>())).font_struct_list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XOMFontInfo),
            "::",
            stringify!(font_struct_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XOMFontInfo>())).font_name_list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XOMFontInfo),
            "::",
            stringify!(font_name_list)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIM {
    _unused: [u8; 0],
}
pub type XIM = *mut _XIM;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIC {
    _unused: [u8; 0],
}
pub type XIC = *mut _XIC;
pub type XIMProc =
    ::core::option::Option<unsafe extern "C" fn(arg1: XIM, arg2: XPointer, arg3: XPointer)>;
pub type XICProc = ::core::option::Option<
    unsafe extern "C" fn(arg1: XIC, arg2: XPointer, arg3: XPointer) -> libc::c_int,
>;
pub type XIDProc = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut Display, arg2: XPointer, arg3: XPointer),
>;
pub type XIMStyle = libc::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XIMStyles {
    pub count_styles: libc::c_ushort,
    pub supported_styles: *mut XIMStyle,
}
#[test]
fn bindgen_test_layout_XIMStyles() {
    assert_eq!(
        ::core::mem::size_of::<XIMStyles>(),
        16usize,
        concat!("Size of: ", stringify!(XIMStyles))
    );
    assert_eq!(
        ::core::mem::align_of::<XIMStyles>(),
        8usize,
        concat!("Alignment of ", stringify!(XIMStyles))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XIMStyles>())).count_styles as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XIMStyles),
            "::",
            stringify!(count_styles)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XIMStyles>())).supported_styles as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XIMStyles),
            "::",
            stringify!(supported_styles)
        )
    );
}
pub type XVaNestedList = *mut libc::c_void;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XIMCallback {
    pub client_data: XPointer,
    pub callback: XIMProc,
}
#[test]
fn bindgen_test_layout_XIMCallback() {
    assert_eq!(
        ::core::mem::size_of::<XIMCallback>(),
        16usize,
        concat!("Size of: ", stringify!(XIMCallback))
    );
    assert_eq!(
        ::core::mem::align_of::<XIMCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(XIMCallback))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XIMCallback>())).client_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XIMCallback),
            "::",
            stringify!(client_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XIMCallback>())).callback as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XIMCallback),
            "::",
            stringify!(callback)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XICCallback {
    pub client_data: XPointer,
    pub callback: XICProc,
}
#[test]
fn bindgen_test_layout_XICCallback() {
    assert_eq!(
        ::core::mem::size_of::<XICCallback>(),
        16usize,
        concat!("Size of: ", stringify!(XICCallback))
    );
    assert_eq!(
        ::core::mem::align_of::<XICCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(XICCallback))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XICCallback>())).client_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XICCallback),
            "::",
            stringify!(client_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XICCallback>())).callback as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XICCallback),
            "::",
            stringify!(callback)
        )
    );
}
pub type XIMFeedback = libc::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIMText {
    pub length: libc::c_ushort,
    pub feedback: *mut XIMFeedback,
    pub encoding_is_wchar: libc::c_int,
    pub string: _XIMText__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _XIMText__bindgen_ty_1 {
    pub multi_byte: *mut libc::c_char,
    pub wide_char: *mut wchar_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__XIMText__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_XIMText__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_XIMText__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_XIMText__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_XIMText__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_XIMText__bindgen_ty_1>())).multi_byte as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMText__bindgen_ty_1),
            "::",
            stringify!(multi_byte)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_XIMText__bindgen_ty_1>())).wide_char as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMText__bindgen_ty_1),
            "::",
            stringify!(wide_char)
        )
    );
}
#[test]
fn bindgen_test_layout__XIMText() {
    assert_eq!(
        ::core::mem::size_of::<_XIMText>(),
        32usize,
        concat!("Size of: ", stringify!(_XIMText))
    );
    assert_eq!(
        ::core::mem::align_of::<_XIMText>(),
        8usize,
        concat!("Alignment of ", stringify!(_XIMText))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XIMText>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMText),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XIMText>())).feedback as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMText),
            "::",
            stringify!(feedback)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XIMText>())).encoding_is_wchar as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMText),
            "::",
            stringify!(encoding_is_wchar)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XIMText>())).string as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMText),
            "::",
            stringify!(string)
        )
    );
}
pub type XIMText = _XIMText;
pub type XIMPreeditState = libc::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIMPreeditStateNotifyCallbackStruct {
    pub state: XIMPreeditState,
}
#[test]
fn bindgen_test_layout__XIMPreeditStateNotifyCallbackStruct() {
    assert_eq!(
        ::core::mem::size_of::<_XIMPreeditStateNotifyCallbackStruct>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_XIMPreeditStateNotifyCallbackStruct)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_XIMPreeditStateNotifyCallbackStruct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_XIMPreeditStateNotifyCallbackStruct)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_XIMPreeditStateNotifyCallbackStruct>())).state as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMPreeditStateNotifyCallbackStruct),
            "::",
            stringify!(state)
        )
    );
}
pub type XIMPreeditStateNotifyCallbackStruct = _XIMPreeditStateNotifyCallbackStruct;
pub type XIMResetState = libc::c_ulong;
pub type XIMStringConversionFeedback = libc::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIMStringConversionText {
    pub length: libc::c_ushort,
    pub feedback: *mut XIMStringConversionFeedback,
    pub encoding_is_wchar: libc::c_int,
    pub string: _XIMStringConversionText__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _XIMStringConversionText__bindgen_ty_1 {
    pub mbs: *mut libc::c_char,
    pub wcs: *mut wchar_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__XIMStringConversionText__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_XIMStringConversionText__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_XIMStringConversionText__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_XIMStringConversionText__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_XIMStringConversionText__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_XIMStringConversionText__bindgen_ty_1>())).mbs as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionText__bindgen_ty_1),
            "::",
            stringify!(mbs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_XIMStringConversionText__bindgen_ty_1>())).wcs as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionText__bindgen_ty_1),
            "::",
            stringify!(wcs)
        )
    );
}
#[test]
fn bindgen_test_layout__XIMStringConversionText() {
    assert_eq!(
        ::core::mem::size_of::<_XIMStringConversionText>(),
        32usize,
        concat!("Size of: ", stringify!(_XIMStringConversionText))
    );
    assert_eq!(
        ::core::mem::align_of::<_XIMStringConversionText>(),
        8usize,
        concat!("Alignment of ", stringify!(_XIMStringConversionText))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_XIMStringConversionText>())).length as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionText),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_XIMStringConversionText>())).feedback as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionText),
            "::",
            stringify!(feedback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_XIMStringConversionText>())).encoding_is_wchar as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionText),
            "::",
            stringify!(encoding_is_wchar)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_XIMStringConversionText>())).string as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionText),
            "::",
            stringify!(string)
        )
    );
}
pub type XIMStringConversionText = _XIMStringConversionText;
pub type XIMStringConversionPosition = libc::c_ushort;
pub type XIMStringConversionType = libc::c_ushort;
pub type XIMStringConversionOperation = libc::c_ushort;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum XIMCaretDirection {
    XIMForwardChar = 0,
    XIMBackwardChar = 1,
    XIMForwardWord = 2,
    XIMBackwardWord = 3,
    XIMCaretUp = 4,
    XIMCaretDown = 5,
    XIMNextLine = 6,
    XIMPreviousLine = 7,
    XIMLineStart = 8,
    XIMLineEnd = 9,
    XIMAbsolutePosition = 10,
    XIMDontChange = 11,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIMStringConversionCallbackStruct {
    pub position: XIMStringConversionPosition,
    pub direction: XIMCaretDirection,
    pub operation: XIMStringConversionOperation,
    pub factor: libc::c_ushort,
    pub text: *mut XIMStringConversionText,
}
#[test]
fn bindgen_test_layout__XIMStringConversionCallbackStruct() {
    assert_eq!(
        ::core::mem::size_of::<_XIMStringConversionCallbackStruct>(),
        24usize,
        concat!("Size of: ", stringify!(_XIMStringConversionCallbackStruct))
    );
    assert_eq!(
        ::core::mem::align_of::<_XIMStringConversionCallbackStruct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_XIMStringConversionCallbackStruct)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_XIMStringConversionCallbackStruct>())).position as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionCallbackStruct),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_XIMStringConversionCallbackStruct>())).direction as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionCallbackStruct),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_XIMStringConversionCallbackStruct>())).operation as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionCallbackStruct),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_XIMStringConversionCallbackStruct>())).factor as *const _
                as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionCallbackStruct),
            "::",
            stringify!(factor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_XIMStringConversionCallbackStruct>())).text as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionCallbackStruct),
            "::",
            stringify!(text)
        )
    );
}
pub type XIMStringConversionCallbackStruct = _XIMStringConversionCallbackStruct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIMPreeditDrawCallbackStruct {
    pub caret: libc::c_int,
    pub chg_first: libc::c_int,
    pub chg_length: libc::c_int,
    pub text: *mut XIMText,
}
#[test]
fn bindgen_test_layout__XIMPreeditDrawCallbackStruct() {
    assert_eq!(
        ::core::mem::size_of::<_XIMPreeditDrawCallbackStruct>(),
        24usize,
        concat!("Size of: ", stringify!(_XIMPreeditDrawCallbackStruct))
    );
    assert_eq!(
        ::core::mem::align_of::<_XIMPreeditDrawCallbackStruct>(),
        8usize,
        concat!("Alignment of ", stringify!(_XIMPreeditDrawCallbackStruct))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_XIMPreeditDrawCallbackStruct>())).caret as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMPreeditDrawCallbackStruct),
            "::",
            stringify!(caret)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_XIMPreeditDrawCallbackStruct>())).chg_first as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMPreeditDrawCallbackStruct),
            "::",
            stringify!(chg_first)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_XIMPreeditDrawCallbackStruct>())).chg_length as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMPreeditDrawCallbackStruct),
            "::",
            stringify!(chg_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_XIMPreeditDrawCallbackStruct>())).text as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMPreeditDrawCallbackStruct),
            "::",
            stringify!(text)
        )
    );
}
pub type XIMPreeditDrawCallbackStruct = _XIMPreeditDrawCallbackStruct;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum XIMCaretStyle {
    XIMIsInvisible = 0,
    XIMIsPrimary = 1,
    XIMIsSecondary = 2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIMPreeditCaretCallbackStruct {
    pub position: libc::c_int,
    pub direction: XIMCaretDirection,
    pub style: XIMCaretStyle,
}
#[test]
fn bindgen_test_layout__XIMPreeditCaretCallbackStruct() {
    assert_eq!(
        ::core::mem::size_of::<_XIMPreeditCaretCallbackStruct>(),
        12usize,
        concat!("Size of: ", stringify!(_XIMPreeditCaretCallbackStruct))
    );
    assert_eq!(
        ::core::mem::align_of::<_XIMPreeditCaretCallbackStruct>(),
        4usize,
        concat!("Alignment of ", stringify!(_XIMPreeditCaretCallbackStruct))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_XIMPreeditCaretCallbackStruct>())).position as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMPreeditCaretCallbackStruct),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_XIMPreeditCaretCallbackStruct>())).direction as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMPreeditCaretCallbackStruct),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_XIMPreeditCaretCallbackStruct>())).style as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMPreeditCaretCallbackStruct),
            "::",
            stringify!(style)
        )
    );
}
pub type XIMPreeditCaretCallbackStruct = _XIMPreeditCaretCallbackStruct;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum XIMStatusDataType {
    XIMTextType = 0,
    XIMBitmapType = 1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIMStatusDrawCallbackStruct {
    pub type_: XIMStatusDataType,
    pub data: _XIMStatusDrawCallbackStruct__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _XIMStatusDrawCallbackStruct__bindgen_ty_1 {
    pub text: *mut XIMText,
    pub bitmap: Pixmap,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__XIMStatusDrawCallbackStruct__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_XIMStatusDrawCallbackStruct__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_XIMStatusDrawCallbackStruct__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_XIMStatusDrawCallbackStruct__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_XIMStatusDrawCallbackStruct__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_XIMStatusDrawCallbackStruct__bindgen_ty_1>())).text as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStatusDrawCallbackStruct__bindgen_ty_1),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_XIMStatusDrawCallbackStruct__bindgen_ty_1>())).bitmap
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStatusDrawCallbackStruct__bindgen_ty_1),
            "::",
            stringify!(bitmap)
        )
    );
}
#[test]
fn bindgen_test_layout__XIMStatusDrawCallbackStruct() {
    assert_eq!(
        ::core::mem::size_of::<_XIMStatusDrawCallbackStruct>(),
        16usize,
        concat!("Size of: ", stringify!(_XIMStatusDrawCallbackStruct))
    );
    assert_eq!(
        ::core::mem::align_of::<_XIMStatusDrawCallbackStruct>(),
        8usize,
        concat!("Alignment of ", stringify!(_XIMStatusDrawCallbackStruct))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_XIMStatusDrawCallbackStruct>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStatusDrawCallbackStruct),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_XIMStatusDrawCallbackStruct>())).data as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStatusDrawCallbackStruct),
            "::",
            stringify!(data)
        )
    );
}
pub type XIMStatusDrawCallbackStruct = _XIMStatusDrawCallbackStruct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIMHotKeyTrigger {
    pub keysym: KeySym,
    pub modifier: libc::c_int,
    pub modifier_mask: libc::c_int,
}
#[test]
fn bindgen_test_layout__XIMHotKeyTrigger() {
    assert_eq!(
        ::core::mem::size_of::<_XIMHotKeyTrigger>(),
        16usize,
        concat!("Size of: ", stringify!(_XIMHotKeyTrigger))
    );
    assert_eq!(
        ::core::mem::align_of::<_XIMHotKeyTrigger>(),
        8usize,
        concat!("Alignment of ", stringify!(_XIMHotKeyTrigger))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XIMHotKeyTrigger>())).keysym as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMHotKeyTrigger),
            "::",
            stringify!(keysym)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XIMHotKeyTrigger>())).modifier as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMHotKeyTrigger),
            "::",
            stringify!(modifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_XIMHotKeyTrigger>())).modifier_mask as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMHotKeyTrigger),
            "::",
            stringify!(modifier_mask)
        )
    );
}
pub type XIMHotKeyTrigger = _XIMHotKeyTrigger;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIMHotKeyTriggers {
    pub num_hot_key: libc::c_int,
    pub key: *mut XIMHotKeyTrigger,
}
#[test]
fn bindgen_test_layout__XIMHotKeyTriggers() {
    assert_eq!(
        ::core::mem::size_of::<_XIMHotKeyTriggers>(),
        16usize,
        concat!("Size of: ", stringify!(_XIMHotKeyTriggers))
    );
    assert_eq!(
        ::core::mem::align_of::<_XIMHotKeyTriggers>(),
        8usize,
        concat!("Alignment of ", stringify!(_XIMHotKeyTriggers))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XIMHotKeyTriggers>())).num_hot_key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMHotKeyTriggers),
            "::",
            stringify!(num_hot_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_XIMHotKeyTriggers>())).key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMHotKeyTriggers),
            "::",
            stringify!(key)
        )
    );
}
pub type XIMHotKeyTriggers = _XIMHotKeyTriggers;
pub type XIMHotKeyState = libc::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XIMValuesList {
    pub count_values: libc::c_ushort,
    pub supported_values: *mut *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_XIMValuesList() {
    assert_eq!(
        ::core::mem::size_of::<XIMValuesList>(),
        16usize,
        concat!("Size of: ", stringify!(XIMValuesList))
    );
    assert_eq!(
        ::core::mem::align_of::<XIMValuesList>(),
        8usize,
        concat!("Alignment of ", stringify!(XIMValuesList))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XIMValuesList>())).count_values as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XIMValuesList),
            "::",
            stringify!(count_values)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<XIMValuesList>())).supported_values as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XIMValuesList),
            "::",
            stringify!(supported_values)
        )
    );
}
extern "C" {
    pub static mut _Xdebug: libc::c_int;
}
extern "C" {
    pub fn XLoadQueryFont(arg1: *mut Display, arg2: *const libc::c_char) -> *mut XFontStruct;
}
extern "C" {
    pub fn XQueryFont(arg1: *mut Display, arg2: XID) -> *mut XFontStruct;
}
extern "C" {
    pub fn XGetMotionEvents(
        arg1: *mut Display,
        arg2: Window,
        arg3: Time,
        arg4: Time,
        arg5: *mut libc::c_int,
    ) -> *mut XTimeCoord;
}
extern "C" {
    pub fn XDeleteModifiermapEntry(
        arg1: *mut XModifierKeymap,
        arg2: KeyCode,
        arg3: libc::c_int,
    ) -> *mut XModifierKeymap;
}
extern "C" {
    pub fn XGetModifierMapping(arg1: *mut Display) -> *mut XModifierKeymap;
}
extern "C" {
    pub fn XInsertModifiermapEntry(
        arg1: *mut XModifierKeymap,
        arg2: KeyCode,
        arg3: libc::c_int,
    ) -> *mut XModifierKeymap;
}
extern "C" {
    pub fn XNewModifiermap(arg1: libc::c_int) -> *mut XModifierKeymap;
}
extern "C" {
    pub fn XCreateImage(
        arg1: *mut Display,
        arg2: *mut Visual,
        arg3: libc::c_uint,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: *mut libc::c_char,
        arg7: libc::c_uint,
        arg8: libc::c_uint,
        arg9: libc::c_int,
        arg10: libc::c_int,
    ) -> *mut XImage;
}
extern "C" {
    pub fn XInitImage(arg1: *mut XImage) -> libc::c_int;
}
extern "C" {
    pub fn XGetImage(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_uint,
        arg6: libc::c_uint,
        arg7: libc::c_ulong,
        arg8: libc::c_int,
    ) -> *mut XImage;
}
extern "C" {
    pub fn XGetSubImage(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_uint,
        arg6: libc::c_uint,
        arg7: libc::c_ulong,
        arg8: libc::c_int,
        arg9: *mut XImage,
        arg10: libc::c_int,
        arg11: libc::c_int,
    ) -> *mut XImage;
}
extern "C" {
    pub fn XOpenDisplay(arg1: *const libc::c_char) -> *mut Display;
}
extern "C" {
    pub fn XrmInitialize();
}
extern "C" {
    pub fn XFetchBytes(arg1: *mut Display, arg2: *mut libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn XFetchBuffer(
        arg1: *mut Display,
        arg2: *mut libc::c_int,
        arg3: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn XGetAtomName(arg1: *mut Display, arg2: Atom) -> *mut libc::c_char;
}
extern "C" {
    pub fn XGetAtomNames(
        arg1: *mut Display,
        arg2: *mut Atom,
        arg3: libc::c_int,
        arg4: *mut *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGetDefault(
        arg1: *mut Display,
        arg2: *const libc::c_char,
        arg3: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn XDisplayName(arg1: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn XKeysymToString(arg1: KeySym) -> *mut libc::c_char;
}
extern "C" {
    pub fn XSynchronize(
        arg1: *mut Display,
        arg2: libc::c_int,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int,
    >;
}
extern "C" {
    pub fn XSetAfterFunction(
        arg1: *mut Display,
        arg2: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Display) -> libc::c_int>,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Display,
            arg2: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Display) -> libc::c_int>,
        ) -> libc::c_int,
    >;
}
extern "C" {
    pub fn XInternAtom(arg1: *mut Display, arg2: *const libc::c_char, arg3: libc::c_int) -> Atom;
}
extern "C" {
    pub fn XInternAtoms(
        arg1: *mut Display,
        arg2: *mut *mut libc::c_char,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: *mut Atom,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XCopyColormapAndFree(arg1: *mut Display, arg2: Colormap) -> Colormap;
}
extern "C" {
    pub fn XCreateColormap(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut Visual,
        arg4: libc::c_int,
    ) -> Colormap;
}
extern "C" {
    pub fn XCreatePixmapCursor(
        arg1: *mut Display,
        arg2: Pixmap,
        arg3: Pixmap,
        arg4: *mut XColor,
        arg5: *mut XColor,
        arg6: libc::c_uint,
        arg7: libc::c_uint,
    ) -> Cursor;
}
extern "C" {
    pub fn XCreateGlyphCursor(
        arg1: *mut Display,
        arg2: Font,
        arg3: Font,
        arg4: libc::c_uint,
        arg5: libc::c_uint,
        arg6: *const XColor,
        arg7: *const XColor,
    ) -> Cursor;
}
extern "C" {
    pub fn XCreateFontCursor(arg1: *mut Display, arg2: libc::c_uint) -> Cursor;
}
extern "C" {
    pub fn XLoadFont(arg1: *mut Display, arg2: *const libc::c_char) -> Font;
}
extern "C" {
    pub fn XCreateGC(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: libc::c_ulong,
        arg4: *mut XGCValues,
    ) -> GC;
}
extern "C" {
    pub fn XGContextFromGC(arg1: GC) -> GContext;
}
extern "C" {
    pub fn XFlushGC(arg1: *mut Display, arg2: GC);
}
extern "C" {
    pub fn XCreatePixmap(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: libc::c_uint,
        arg4: libc::c_uint,
        arg5: libc::c_uint,
    ) -> Pixmap;
}
extern "C" {
    pub fn XCreateBitmapFromData(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: *const libc::c_char,
        arg4: libc::c_uint,
        arg5: libc::c_uint,
    ) -> Pixmap;
}
extern "C" {
    pub fn XCreatePixmapFromBitmapData(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: *mut libc::c_char,
        arg4: libc::c_uint,
        arg5: libc::c_uint,
        arg6: libc::c_ulong,
        arg7: libc::c_ulong,
        arg8: libc::c_uint,
    ) -> Pixmap;
}
extern "C" {
    pub fn XCreateSimpleWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_uint,
        arg6: libc::c_uint,
        arg7: libc::c_uint,
        arg8: libc::c_ulong,
        arg9: libc::c_ulong,
    ) -> Window;
}
extern "C" {
    pub fn XGetSelectionOwner(arg1: *mut Display, arg2: Atom) -> Window;
}
extern "C" {
    pub fn XCreateWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_uint,
        arg6: libc::c_uint,
        arg7: libc::c_uint,
        arg8: libc::c_int,
        arg9: libc::c_uint,
        arg10: *mut Visual,
        arg11: libc::c_ulong,
        arg12: *mut XSetWindowAttributes,
    ) -> Window;
}
extern "C" {
    pub fn XListInstalledColormaps(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut libc::c_int,
    ) -> *mut Colormap;
}
extern "C" {
    pub fn XListFonts(
        arg1: *mut Display,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
        arg4: *mut libc::c_int,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn XListFontsWithInfo(
        arg1: *mut Display,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
        arg4: *mut libc::c_int,
        arg5: *mut *mut XFontStruct,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn XGetFontPath(arg1: *mut Display, arg2: *mut libc::c_int) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn XListExtensions(arg1: *mut Display, arg2: *mut libc::c_int) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn XListProperties(arg1: *mut Display, arg2: Window, arg3: *mut libc::c_int) -> *mut Atom;
}
extern "C" {
    pub fn XListHosts(
        arg1: *mut Display,
        arg2: *mut libc::c_int,
        arg3: *mut libc::c_int,
    ) -> *mut XHostAddress;
}
extern "C" {
    pub fn XKeycodeToKeysym(arg1: *mut Display, arg2: KeyCode, arg3: libc::c_int) -> KeySym;
}
extern "C" {
    pub fn XLookupKeysym(arg1: *mut XKeyEvent, arg2: libc::c_int) -> KeySym;
}
extern "C" {
    pub fn XGetKeyboardMapping(
        arg1: *mut Display,
        arg2: KeyCode,
        arg3: libc::c_int,
        arg4: *mut libc::c_int,
    ) -> *mut KeySym;
}
extern "C" {
    pub fn XStringToKeysym(arg1: *const libc::c_char) -> KeySym;
}
extern "C" {
    pub fn XMaxRequestSize(arg1: *mut Display) -> libc::c_long;
}
extern "C" {
    pub fn XExtendedMaxRequestSize(arg1: *mut Display) -> libc::c_long;
}
extern "C" {
    pub fn XResourceManagerString(arg1: *mut Display) -> *mut libc::c_char;
}
extern "C" {
    pub fn XScreenResourceString(arg1: *mut Screen) -> *mut libc::c_char;
}
extern "C" {
    pub fn XDisplayMotionBufferSize(arg1: *mut Display) -> libc::c_ulong;
}
extern "C" {
    pub fn XVisualIDFromVisual(arg1: *mut Visual) -> VisualID;
}
extern "C" {
    pub fn XInitThreads() -> libc::c_int;
}
extern "C" {
    pub fn XLockDisplay(arg1: *mut Display);
}
extern "C" {
    pub fn XUnlockDisplay(arg1: *mut Display);
}
extern "C" {
    pub fn XInitExtension(arg1: *mut Display, arg2: *const libc::c_char) -> *mut XExtCodes;
}
extern "C" {
    pub fn XAddExtension(arg1: *mut Display) -> *mut XExtCodes;
}
extern "C" {
    pub fn XFindOnExtensionList(arg1: *mut *mut XExtData, arg2: libc::c_int) -> *mut XExtData;
}
extern "C" {
    pub fn XEHeadOfExtensionList(arg1: XEDataObject) -> *mut *mut XExtData;
}
extern "C" {
    pub fn XRootWindow(arg1: *mut Display, arg2: libc::c_int) -> Window;
}
extern "C" {
    pub fn XDefaultRootWindow(arg1: *mut Display) -> Window;
}
extern "C" {
    pub fn XRootWindowOfScreen(arg1: *mut Screen) -> Window;
}
extern "C" {
    pub fn XDefaultVisual(arg1: *mut Display, arg2: libc::c_int) -> *mut Visual;
}
extern "C" {
    pub fn XDefaultVisualOfScreen(arg1: *mut Screen) -> *mut Visual;
}
extern "C" {
    pub fn XDefaultGC(arg1: *mut Display, arg2: libc::c_int) -> GC;
}
extern "C" {
    pub fn XDefaultGCOfScreen(arg1: *mut Screen) -> GC;
}
extern "C" {
    pub fn XBlackPixel(arg1: *mut Display, arg2: libc::c_int) -> libc::c_ulong;
}
extern "C" {
    pub fn XWhitePixel(arg1: *mut Display, arg2: libc::c_int) -> libc::c_ulong;
}
extern "C" {
    pub fn XAllPlanes() -> libc::c_ulong;
}
extern "C" {
    pub fn XBlackPixelOfScreen(arg1: *mut Screen) -> libc::c_ulong;
}
extern "C" {
    pub fn XWhitePixelOfScreen(arg1: *mut Screen) -> libc::c_ulong;
}
extern "C" {
    pub fn XNextRequest(arg1: *mut Display) -> libc::c_ulong;
}
extern "C" {
    pub fn XLastKnownRequestProcessed(arg1: *mut Display) -> libc::c_ulong;
}
extern "C" {
    pub fn XServerVendor(arg1: *mut Display) -> *mut libc::c_char;
}
extern "C" {
    pub fn XDisplayString(arg1: *mut Display) -> *mut libc::c_char;
}
extern "C" {
    pub fn XDefaultColormap(arg1: *mut Display, arg2: libc::c_int) -> Colormap;
}
extern "C" {
    pub fn XDefaultColormapOfScreen(arg1: *mut Screen) -> Colormap;
}
extern "C" {
    pub fn XDisplayOfScreen(arg1: *mut Screen) -> *mut Display;
}
extern "C" {
    pub fn XScreenOfDisplay(arg1: *mut Display, arg2: libc::c_int) -> *mut Screen;
}
extern "C" {
    pub fn XDefaultScreenOfDisplay(arg1: *mut Display) -> *mut Screen;
}
extern "C" {
    pub fn XEventMaskOfScreen(arg1: *mut Screen) -> libc::c_long;
}
extern "C" {
    pub fn XScreenNumberOfScreen(arg1: *mut Screen) -> libc::c_int;
}
pub type XErrorHandler = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut Display, arg2: *mut XErrorEvent) -> libc::c_int,
>;
extern "C" {
    pub fn XSetErrorHandler(arg1: XErrorHandler) -> XErrorHandler;
}
pub type XIOErrorHandler =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut Display) -> libc::c_int>;
extern "C" {
    pub fn XSetIOErrorHandler(arg1: XIOErrorHandler) -> XIOErrorHandler;
}
pub type XIOErrorExitHandler =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut Display, arg2: *mut libc::c_void)>;
extern "C" {
    pub fn XSetIOErrorExitHandler(
        arg1: *mut Display,
        arg2: XIOErrorExitHandler,
        arg3: *mut libc::c_void,
    );
}
extern "C" {
    pub fn XListPixmapFormats(
        arg1: *mut Display,
        arg2: *mut libc::c_int,
    ) -> *mut XPixmapFormatValues;
}
extern "C" {
    pub fn XListDepths(
        arg1: *mut Display,
        arg2: libc::c_int,
        arg3: *mut libc::c_int,
    ) -> *mut libc::c_int;
}
extern "C" {
    pub fn XReconfigureWMWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_int,
        arg4: libc::c_uint,
        arg5: *mut XWindowChanges,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGetWMProtocols(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut *mut Atom,
        arg4: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetWMProtocols(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut Atom,
        arg4: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XIconifyWindow(arg1: *mut Display, arg2: Window, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XWithdrawWindow(arg1: *mut Display, arg2: Window, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XGetCommand(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut *mut *mut libc::c_char,
        arg4: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGetWMColormapWindows(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut *mut Window,
        arg4: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetWMColormapWindows(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut Window,
        arg4: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XFreeStringList(arg1: *mut *mut libc::c_char);
}
extern "C" {
    pub fn XSetTransientForHint(arg1: *mut Display, arg2: Window, arg3: Window) -> libc::c_int;
}
extern "C" {
    pub fn XActivateScreenSaver(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XAddHost(arg1: *mut Display, arg2: *mut XHostAddress) -> libc::c_int;
}
extern "C" {
    pub fn XAddHosts(arg1: *mut Display, arg2: *mut XHostAddress, arg3: libc::c_int)
        -> libc::c_int;
}
extern "C" {
    pub fn XAddToExtensionList(arg1: *mut *mut _XExtData, arg2: *mut XExtData) -> libc::c_int;
}
extern "C" {
    pub fn XAddToSaveSet(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XAllocColor(arg1: *mut Display, arg2: Colormap, arg3: *mut XColor) -> libc::c_int;
}
extern "C" {
    pub fn XAllocColorCells(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: libc::c_int,
        arg4: *mut libc::c_ulong,
        arg5: libc::c_uint,
        arg6: *mut libc::c_ulong,
        arg7: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XAllocColorPlanes(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: libc::c_int,
        arg4: *mut libc::c_ulong,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: libc::c_int,
        arg8: libc::c_int,
        arg9: *mut libc::c_ulong,
        arg10: *mut libc::c_ulong,
        arg11: *mut libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XAllocNamedColor(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *const libc::c_char,
        arg4: *mut XColor,
        arg5: *mut XColor,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XAllowEvents(arg1: *mut Display, arg2: libc::c_int, arg3: Time) -> libc::c_int;
}
extern "C" {
    pub fn XAutoRepeatOff(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XAutoRepeatOn(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XBell(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XBitmapBitOrder(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XBitmapPad(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XBitmapUnit(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XCellsOfScreen(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XChangeActivePointerGrab(
        arg1: *mut Display,
        arg2: libc::c_uint,
        arg3: Cursor,
        arg4: Time,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XChangeGC(
        arg1: *mut Display,
        arg2: GC,
        arg3: libc::c_ulong,
        arg4: *mut XGCValues,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XChangeKeyboardControl(
        arg1: *mut Display,
        arg2: libc::c_ulong,
        arg3: *mut XKeyboardControl,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XChangeKeyboardMapping(
        arg1: *mut Display,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: *mut KeySym,
        arg5: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XChangePointerControl(
        arg1: *mut Display,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XChangeProperty(
        arg1: *mut Display,
        arg2: Window,
        arg3: Atom,
        arg4: Atom,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: *const libc::c_uchar,
        arg8: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XChangeSaveSet(arg1: *mut Display, arg2: Window, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XChangeWindowAttributes(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_ulong,
        arg4: *mut XSetWindowAttributes,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XCheckIfEvent(
        arg1: *mut Display,
        arg2: *mut XEvent,
        arg3: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Display,
                arg2: *mut XEvent,
                arg3: XPointer,
            ) -> libc::c_int,
        >,
        arg4: XPointer,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XCheckMaskEvent(
        arg1: *mut Display,
        arg2: libc::c_long,
        arg3: *mut XEvent,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XCheckTypedEvent(
        arg1: *mut Display,
        arg2: libc::c_int,
        arg3: *mut XEvent,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XCheckTypedWindowEvent(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_int,
        arg4: *mut XEvent,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XCheckWindowEvent(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_long,
        arg4: *mut XEvent,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XCirculateSubwindows(arg1: *mut Display, arg2: Window, arg3: libc::c_int)
        -> libc::c_int;
}
extern "C" {
    pub fn XCirculateSubwindowsDown(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XCirculateSubwindowsUp(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XClearArea(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_uint,
        arg6: libc::c_uint,
        arg7: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XClearWindow(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XCloseDisplay(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XConfigureWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_uint,
        arg4: *mut XWindowChanges,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XConnectionNumber(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XConvertSelection(
        arg1: *mut Display,
        arg2: Atom,
        arg3: Atom,
        arg4: Atom,
        arg5: Window,
        arg6: Time,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XCopyArea(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: Drawable,
        arg4: GC,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: libc::c_uint,
        arg8: libc::c_uint,
        arg9: libc::c_int,
        arg10: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XCopyGC(arg1: *mut Display, arg2: GC, arg3: libc::c_ulong, arg4: GC) -> libc::c_int;
}
extern "C" {
    pub fn XCopyPlane(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: Drawable,
        arg4: GC,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: libc::c_uint,
        arg8: libc::c_uint,
        arg9: libc::c_int,
        arg10: libc::c_int,
        arg11: libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDefaultDepth(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XDefaultDepthOfScreen(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XDefaultScreen(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XDefineCursor(arg1: *mut Display, arg2: Window, arg3: Cursor) -> libc::c_int;
}
extern "C" {
    pub fn XDeleteProperty(arg1: *mut Display, arg2: Window, arg3: Atom) -> libc::c_int;
}
extern "C" {
    pub fn XDestroyWindow(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XDestroySubwindows(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XDoesBackingStore(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XDoesSaveUnders(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XDisableAccessControl(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XDisplayCells(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XDisplayHeight(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XDisplayHeightMM(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XDisplayKeycodes(
        arg1: *mut Display,
        arg2: *mut libc::c_int,
        arg3: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDisplayPlanes(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XDisplayWidth(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XDisplayWidthMM(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XDrawArc(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: libc::c_uint,
        arg7: libc::c_uint,
        arg8: libc::c_int,
        arg9: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDrawArcs(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XArc,
        arg5: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDrawImageString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: *const libc::c_char,
        arg7: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDrawImageString16(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: *const XChar2b,
        arg7: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDrawLine(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDrawLines(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XPoint,
        arg5: libc::c_int,
        arg6: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDrawPoint(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: libc::c_int,
        arg5: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDrawPoints(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XPoint,
        arg5: libc::c_int,
        arg6: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDrawRectangle(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: libc::c_uint,
        arg7: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDrawRectangles(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XRectangle,
        arg5: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDrawSegments(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XSegment,
        arg5: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDrawString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: *const libc::c_char,
        arg7: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDrawString16(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: *const XChar2b,
        arg7: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDrawText(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: *mut XTextItem,
        arg7: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDrawText16(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: *mut XTextItem16,
        arg7: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XEnableAccessControl(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XEventsQueued(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XFetchName(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XFillArc(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: libc::c_uint,
        arg7: libc::c_uint,
        arg8: libc::c_int,
        arg9: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XFillArcs(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XArc,
        arg5: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XFillPolygon(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XPoint,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XFillRectangle(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: libc::c_uint,
        arg7: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XFillRectangles(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XRectangle,
        arg5: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XFlush(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XForceScreenSaver(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XFree(arg1: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn XFreeColormap(arg1: *mut Display, arg2: Colormap) -> libc::c_int;
}
extern "C" {
    pub fn XFreeColors(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *mut libc::c_ulong,
        arg4: libc::c_int,
        arg5: libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XFreeCursor(arg1: *mut Display, arg2: Cursor) -> libc::c_int;
}
extern "C" {
    pub fn XFreeExtensionList(arg1: *mut *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn XFreeFont(arg1: *mut Display, arg2: *mut XFontStruct) -> libc::c_int;
}
extern "C" {
    pub fn XFreeFontInfo(
        arg1: *mut *mut libc::c_char,
        arg2: *mut XFontStruct,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XFreeFontNames(arg1: *mut *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn XFreeFontPath(arg1: *mut *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn XFreeGC(arg1: *mut Display, arg2: GC) -> libc::c_int;
}
extern "C" {
    pub fn XFreeModifiermap(arg1: *mut XModifierKeymap) -> libc::c_int;
}
extern "C" {
    pub fn XFreePixmap(arg1: *mut Display, arg2: Pixmap) -> libc::c_int;
}
extern "C" {
    pub fn XGeometry(
        arg1: *mut Display,
        arg2: libc::c_int,
        arg3: *const libc::c_char,
        arg4: *const libc::c_char,
        arg5: libc::c_uint,
        arg6: libc::c_uint,
        arg7: libc::c_uint,
        arg8: libc::c_int,
        arg9: libc::c_int,
        arg10: *mut libc::c_int,
        arg11: *mut libc::c_int,
        arg12: *mut libc::c_int,
        arg13: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGetErrorDatabaseText(
        arg1: *mut Display,
        arg2: *const libc::c_char,
        arg3: *const libc::c_char,
        arg4: *const libc::c_char,
        arg5: *mut libc::c_char,
        arg6: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGetErrorText(
        arg1: *mut Display,
        arg2: libc::c_int,
        arg3: *mut libc::c_char,
        arg4: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGetFontProperty(
        arg1: *mut XFontStruct,
        arg2: Atom,
        arg3: *mut libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGetGCValues(
        arg1: *mut Display,
        arg2: GC,
        arg3: libc::c_ulong,
        arg4: *mut XGCValues,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGetGeometry(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: *mut Window,
        arg4: *mut libc::c_int,
        arg5: *mut libc::c_int,
        arg6: *mut libc::c_uint,
        arg7: *mut libc::c_uint,
        arg8: *mut libc::c_uint,
        arg9: *mut libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGetIconName(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGetInputFocus(
        arg1: *mut Display,
        arg2: *mut Window,
        arg3: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGetKeyboardControl(arg1: *mut Display, arg2: *mut XKeyboardState) -> libc::c_int;
}
extern "C" {
    pub fn XGetPointerControl(
        arg1: *mut Display,
        arg2: *mut libc::c_int,
        arg3: *mut libc::c_int,
        arg4: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGetPointerMapping(
        arg1: *mut Display,
        arg2: *mut libc::c_uchar,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGetScreenSaver(
        arg1: *mut Display,
        arg2: *mut libc::c_int,
        arg3: *mut libc::c_int,
        arg4: *mut libc::c_int,
        arg5: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGetTransientForHint(arg1: *mut Display, arg2: Window, arg3: *mut Window)
        -> libc::c_int;
}
extern "C" {
    pub fn XGetWindowProperty(
        arg1: *mut Display,
        arg2: Window,
        arg3: Atom,
        arg4: libc::c_long,
        arg5: libc::c_long,
        arg6: libc::c_int,
        arg7: Atom,
        arg8: *mut Atom,
        arg9: *mut libc::c_int,
        arg10: *mut libc::c_ulong,
        arg11: *mut libc::c_ulong,
        arg12: *mut *mut libc::c_uchar,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGetWindowAttributes(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut XWindowAttributes,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGrabButton(
        arg1: *mut Display,
        arg2: libc::c_uint,
        arg3: libc::c_uint,
        arg4: Window,
        arg5: libc::c_int,
        arg6: libc::c_uint,
        arg7: libc::c_int,
        arg8: libc::c_int,
        arg9: Window,
        arg10: Cursor,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGrabKey(
        arg1: *mut Display,
        arg2: libc::c_int,
        arg3: libc::c_uint,
        arg4: Window,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGrabKeyboard(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: Time,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGrabPointer(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_int,
        arg4: libc::c_uint,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: Window,
        arg8: Cursor,
        arg9: Time,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGrabServer(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XHeightMMOfScreen(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XHeightOfScreen(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XIfEvent(
        arg1: *mut Display,
        arg2: *mut XEvent,
        arg3: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Display,
                arg2: *mut XEvent,
                arg3: XPointer,
            ) -> libc::c_int,
        >,
        arg4: XPointer,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XImageByteOrder(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XInstallColormap(arg1: *mut Display, arg2: Colormap) -> libc::c_int;
}
extern "C" {
    pub fn XKeysymToKeycode(arg1: *mut Display, arg2: KeySym) -> KeyCode;
}
extern "C" {
    pub fn XKillClient(arg1: *mut Display, arg2: XID) -> libc::c_int;
}
extern "C" {
    pub fn XLookupColor(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *const libc::c_char,
        arg4: *mut XColor,
        arg5: *mut XColor,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XLowerWindow(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XMapRaised(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XMapSubwindows(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XMapWindow(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XMaskEvent(arg1: *mut Display, arg2: libc::c_long, arg3: *mut XEvent) -> libc::c_int;
}
extern "C" {
    pub fn XMaxCmapsOfScreen(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XMinCmapsOfScreen(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XMoveResizeWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_uint,
        arg6: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XMoveWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_int,
        arg4: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XNextEvent(arg1: *mut Display, arg2: *mut XEvent) -> libc::c_int;
}
extern "C" {
    pub fn XNoOp(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XParseColor(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *const libc::c_char,
        arg4: *mut XColor,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XParseGeometry(
        arg1: *const libc::c_char,
        arg2: *mut libc::c_int,
        arg3: *mut libc::c_int,
        arg4: *mut libc::c_uint,
        arg5: *mut libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XPeekEvent(arg1: *mut Display, arg2: *mut XEvent) -> libc::c_int;
}
extern "C" {
    pub fn XPeekIfEvent(
        arg1: *mut Display,
        arg2: *mut XEvent,
        arg3: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Display,
                arg2: *mut XEvent,
                arg3: XPointer,
            ) -> libc::c_int,
        >,
        arg4: XPointer,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XPending(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XPlanesOfScreen(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XProtocolRevision(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XProtocolVersion(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XPutBackEvent(arg1: *mut Display, arg2: *mut XEvent) -> libc::c_int;
}
extern "C" {
    pub fn XPutImage(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XImage,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: libc::c_int,
        arg8: libc::c_int,
        arg9: libc::c_uint,
        arg10: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XQLength(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XQueryBestCursor(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: libc::c_uint,
        arg4: libc::c_uint,
        arg5: *mut libc::c_uint,
        arg6: *mut libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XQueryBestSize(
        arg1: *mut Display,
        arg2: libc::c_int,
        arg3: Drawable,
        arg4: libc::c_uint,
        arg5: libc::c_uint,
        arg6: *mut libc::c_uint,
        arg7: *mut libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XQueryBestStipple(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: libc::c_uint,
        arg4: libc::c_uint,
        arg5: *mut libc::c_uint,
        arg6: *mut libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XQueryBestTile(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: libc::c_uint,
        arg4: libc::c_uint,
        arg5: *mut libc::c_uint,
        arg6: *mut libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XQueryColor(arg1: *mut Display, arg2: Colormap, arg3: *mut XColor) -> libc::c_int;
}
extern "C" {
    pub fn XQueryColors(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *mut XColor,
        arg4: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XQueryExtension(
        arg1: *mut Display,
        arg2: *const libc::c_char,
        arg3: *mut libc::c_int,
        arg4: *mut libc::c_int,
        arg5: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XQueryKeymap(arg1: *mut Display, arg2: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn XQueryPointer(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut Window,
        arg4: *mut Window,
        arg5: *mut libc::c_int,
        arg6: *mut libc::c_int,
        arg7: *mut libc::c_int,
        arg8: *mut libc::c_int,
        arg9: *mut libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XQueryTextExtents(
        arg1: *mut Display,
        arg2: XID,
        arg3: *const libc::c_char,
        arg4: libc::c_int,
        arg5: *mut libc::c_int,
        arg6: *mut libc::c_int,
        arg7: *mut libc::c_int,
        arg8: *mut XCharStruct,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XQueryTextExtents16(
        arg1: *mut Display,
        arg2: XID,
        arg3: *const XChar2b,
        arg4: libc::c_int,
        arg5: *mut libc::c_int,
        arg6: *mut libc::c_int,
        arg7: *mut libc::c_int,
        arg8: *mut XCharStruct,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XQueryTree(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut Window,
        arg4: *mut Window,
        arg5: *mut *mut Window,
        arg6: *mut libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XRaiseWindow(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XReadBitmapFile(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: *const libc::c_char,
        arg4: *mut libc::c_uint,
        arg5: *mut libc::c_uint,
        arg6: *mut Pixmap,
        arg7: *mut libc::c_int,
        arg8: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XReadBitmapFileData(
        arg1: *const libc::c_char,
        arg2: *mut libc::c_uint,
        arg3: *mut libc::c_uint,
        arg4: *mut *mut libc::c_uchar,
        arg5: *mut libc::c_int,
        arg6: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XRebindKeysym(
        arg1: *mut Display,
        arg2: KeySym,
        arg3: *mut KeySym,
        arg4: libc::c_int,
        arg5: *const libc::c_uchar,
        arg6: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XRecolorCursor(
        arg1: *mut Display,
        arg2: Cursor,
        arg3: *mut XColor,
        arg4: *mut XColor,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XRefreshKeyboardMapping(arg1: *mut XMappingEvent) -> libc::c_int;
}
extern "C" {
    pub fn XRemoveFromSaveSet(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XRemoveHost(arg1: *mut Display, arg2: *mut XHostAddress) -> libc::c_int;
}
extern "C" {
    pub fn XRemoveHosts(
        arg1: *mut Display,
        arg2: *mut XHostAddress,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XReparentWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: Window,
        arg4: libc::c_int,
        arg5: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XResetScreenSaver(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XResizeWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_uint,
        arg4: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XRestackWindows(arg1: *mut Display, arg2: *mut Window, arg3: libc::c_int)
        -> libc::c_int;
}
extern "C" {
    pub fn XRotateBuffers(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XRotateWindowProperties(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut Atom,
        arg4: libc::c_int,
        arg5: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XScreenCount(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XSelectInput(arg1: *mut Display, arg2: Window, arg3: libc::c_long) -> libc::c_int;
}
extern "C" {
    pub fn XSendEvent(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_int,
        arg4: libc::c_long,
        arg5: *mut XEvent,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetAccessControl(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XSetArcMode(arg1: *mut Display, arg2: GC, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XSetBackground(arg1: *mut Display, arg2: GC, arg3: libc::c_ulong) -> libc::c_int;
}
extern "C" {
    pub fn XSetClipMask(arg1: *mut Display, arg2: GC, arg3: Pixmap) -> libc::c_int;
}
extern "C" {
    pub fn XSetClipOrigin(
        arg1: *mut Display,
        arg2: GC,
        arg3: libc::c_int,
        arg4: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetClipRectangles(
        arg1: *mut Display,
        arg2: GC,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: *mut XRectangle,
        arg6: libc::c_int,
        arg7: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetCloseDownMode(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XSetCommand(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut *mut libc::c_char,
        arg4: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetDashes(
        arg1: *mut Display,
        arg2: GC,
        arg3: libc::c_int,
        arg4: *const libc::c_char,
        arg5: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetFillRule(arg1: *mut Display, arg2: GC, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XSetFillStyle(arg1: *mut Display, arg2: GC, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XSetFont(arg1: *mut Display, arg2: GC, arg3: Font) -> libc::c_int;
}
extern "C" {
    pub fn XSetFontPath(
        arg1: *mut Display,
        arg2: *mut *mut libc::c_char,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetForeground(arg1: *mut Display, arg2: GC, arg3: libc::c_ulong) -> libc::c_int;
}
extern "C" {
    pub fn XSetFunction(arg1: *mut Display, arg2: GC, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XSetGraphicsExposures(arg1: *mut Display, arg2: GC, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XSetIconName(arg1: *mut Display, arg2: Window, arg3: *const libc::c_char)
        -> libc::c_int;
}
extern "C" {
    pub fn XSetInputFocus(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_int,
        arg4: Time,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetLineAttributes(
        arg1: *mut Display,
        arg2: GC,
        arg3: libc::c_uint,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetModifierMapping(arg1: *mut Display, arg2: *mut XModifierKeymap) -> libc::c_int;
}
extern "C" {
    pub fn XSetPlaneMask(arg1: *mut Display, arg2: GC, arg3: libc::c_ulong) -> libc::c_int;
}
extern "C" {
    pub fn XSetPointerMapping(
        arg1: *mut Display,
        arg2: *const libc::c_uchar,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetScreenSaver(
        arg1: *mut Display,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetSelectionOwner(
        arg1: *mut Display,
        arg2: Atom,
        arg3: Window,
        arg4: Time,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetState(
        arg1: *mut Display,
        arg2: GC,
        arg3: libc::c_ulong,
        arg4: libc::c_ulong,
        arg5: libc::c_int,
        arg6: libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetStipple(arg1: *mut Display, arg2: GC, arg3: Pixmap) -> libc::c_int;
}
extern "C" {
    pub fn XSetSubwindowMode(arg1: *mut Display, arg2: GC, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XSetTSOrigin(
        arg1: *mut Display,
        arg2: GC,
        arg3: libc::c_int,
        arg4: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetTile(arg1: *mut Display, arg2: GC, arg3: Pixmap) -> libc::c_int;
}
extern "C" {
    pub fn XSetWindowBackground(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetWindowBackgroundPixmap(
        arg1: *mut Display,
        arg2: Window,
        arg3: Pixmap,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetWindowBorder(arg1: *mut Display, arg2: Window, arg3: libc::c_ulong) -> libc::c_int;
}
extern "C" {
    pub fn XSetWindowBorderPixmap(arg1: *mut Display, arg2: Window, arg3: Pixmap) -> libc::c_int;
}
extern "C" {
    pub fn XSetWindowBorderWidth(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetWindowColormap(arg1: *mut Display, arg2: Window, arg3: Colormap) -> libc::c_int;
}
extern "C" {
    pub fn XStoreBuffer(
        arg1: *mut Display,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
        arg4: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XStoreBytes(
        arg1: *mut Display,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XStoreColor(arg1: *mut Display, arg2: Colormap, arg3: *mut XColor) -> libc::c_int;
}
extern "C" {
    pub fn XStoreColors(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *mut XColor,
        arg4: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XStoreName(arg1: *mut Display, arg2: Window, arg3: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn XStoreNamedColor(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *const libc::c_char,
        arg4: libc::c_ulong,
        arg5: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSync(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XTextExtents(
        arg1: *mut XFontStruct,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
        arg4: *mut libc::c_int,
        arg5: *mut libc::c_int,
        arg6: *mut libc::c_int,
        arg7: *mut XCharStruct,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XTextExtents16(
        arg1: *mut XFontStruct,
        arg2: *const XChar2b,
        arg3: libc::c_int,
        arg4: *mut libc::c_int,
        arg5: *mut libc::c_int,
        arg6: *mut libc::c_int,
        arg7: *mut XCharStruct,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XTextWidth(
        arg1: *mut XFontStruct,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XTextWidth16(
        arg1: *mut XFontStruct,
        arg2: *const XChar2b,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XTranslateCoordinates(
        arg1: *mut Display,
        arg2: Window,
        arg3: Window,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: *mut libc::c_int,
        arg7: *mut libc::c_int,
        arg8: *mut Window,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XUndefineCursor(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XUngrabButton(
        arg1: *mut Display,
        arg2: libc::c_uint,
        arg3: libc::c_uint,
        arg4: Window,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XUngrabKey(
        arg1: *mut Display,
        arg2: libc::c_int,
        arg3: libc::c_uint,
        arg4: Window,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XUngrabKeyboard(arg1: *mut Display, arg2: Time) -> libc::c_int;
}
extern "C" {
    pub fn XUngrabPointer(arg1: *mut Display, arg2: Time) -> libc::c_int;
}
extern "C" {
    pub fn XUngrabServer(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XUninstallColormap(arg1: *mut Display, arg2: Colormap) -> libc::c_int;
}
extern "C" {
    pub fn XUnloadFont(arg1: *mut Display, arg2: Font) -> libc::c_int;
}
extern "C" {
    pub fn XUnmapSubwindows(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XUnmapWindow(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XVendorRelease(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XWarpPointer(
        arg1: *mut Display,
        arg2: Window,
        arg3: Window,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: libc::c_uint,
        arg7: libc::c_uint,
        arg8: libc::c_int,
        arg9: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XWidthMMOfScreen(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XWidthOfScreen(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XWindowEvent(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_long,
        arg4: *mut XEvent,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XWriteBitmapFile(
        arg1: *mut Display,
        arg2: *const libc::c_char,
        arg3: Pixmap,
        arg4: libc::c_uint,
        arg5: libc::c_uint,
        arg6: libc::c_int,
        arg7: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSupportsLocale() -> libc::c_int;
}
extern "C" {
    pub fn XSetLocaleModifiers(arg1: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn XOpenOM(
        arg1: *mut Display,
        arg2: *mut _XrmHashBucketRec,
        arg3: *const libc::c_char,
        arg4: *const libc::c_char,
    ) -> XOM;
}
extern "C" {
    pub fn XCloseOM(arg1: XOM) -> libc::c_int;
}
extern "C" {
    pub fn XSetOMValues(arg1: XOM, ...) -> *mut libc::c_char;
}
extern "C" {
    pub fn XGetOMValues(arg1: XOM, ...) -> *mut libc::c_char;
}
extern "C" {
    pub fn XDisplayOfOM(arg1: XOM) -> *mut Display;
}
extern "C" {
    pub fn XLocaleOfOM(arg1: XOM) -> *mut libc::c_char;
}
extern "C" {
    pub fn XCreateOC(arg1: XOM, ...) -> XOC;
}
extern "C" {
    pub fn XDestroyOC(arg1: XOC);
}
extern "C" {
    pub fn XOMOfOC(arg1: XOC) -> XOM;
}
extern "C" {
    pub fn XSetOCValues(arg1: XOC, ...) -> *mut libc::c_char;
}
extern "C" {
    pub fn XGetOCValues(arg1: XOC, ...) -> *mut libc::c_char;
}
extern "C" {
    pub fn XCreateFontSet(
        arg1: *mut Display,
        arg2: *const libc::c_char,
        arg3: *mut *mut *mut libc::c_char,
        arg4: *mut libc::c_int,
        arg5: *mut *mut libc::c_char,
    ) -> XFontSet;
}
extern "C" {
    pub fn XFreeFontSet(arg1: *mut Display, arg2: XFontSet);
}
extern "C" {
    pub fn XFontsOfFontSet(
        arg1: XFontSet,
        arg2: *mut *mut *mut XFontStruct,
        arg3: *mut *mut *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XBaseFontNameListOfFontSet(arg1: XFontSet) -> *mut libc::c_char;
}
extern "C" {
    pub fn XLocaleOfFontSet(arg1: XFontSet) -> *mut libc::c_char;
}
extern "C" {
    pub fn XContextDependentDrawing(arg1: XFontSet) -> libc::c_int;
}
extern "C" {
    pub fn XDirectionalDependentDrawing(arg1: XFontSet) -> libc::c_int;
}
extern "C" {
    pub fn XContextualDrawing(arg1: XFontSet) -> libc::c_int;
}
extern "C" {
    pub fn XExtentsOfFontSet(arg1: XFontSet) -> *mut XFontSetExtents;
}
extern "C" {
    pub fn XmbTextEscapement(
        arg1: XFontSet,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XwcTextEscapement(
        arg1: XFontSet,
        arg2: *const wchar_t,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn Xutf8TextEscapement(
        arg1: XFontSet,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XmbTextExtents(
        arg1: XFontSet,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
        arg4: *mut XRectangle,
        arg5: *mut XRectangle,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XwcTextExtents(
        arg1: XFontSet,
        arg2: *const wchar_t,
        arg3: libc::c_int,
        arg4: *mut XRectangle,
        arg5: *mut XRectangle,
    ) -> libc::c_int;
}
extern "C" {
    pub fn Xutf8TextExtents(
        arg1: XFontSet,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
        arg4: *mut XRectangle,
        arg5: *mut XRectangle,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XmbTextPerCharExtents(
        arg1: XFontSet,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
        arg4: *mut XRectangle,
        arg5: *mut XRectangle,
        arg6: libc::c_int,
        arg7: *mut libc::c_int,
        arg8: *mut XRectangle,
        arg9: *mut XRectangle,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XwcTextPerCharExtents(
        arg1: XFontSet,
        arg2: *const wchar_t,
        arg3: libc::c_int,
        arg4: *mut XRectangle,
        arg5: *mut XRectangle,
        arg6: libc::c_int,
        arg7: *mut libc::c_int,
        arg8: *mut XRectangle,
        arg9: *mut XRectangle,
    ) -> libc::c_int;
}
extern "C" {
    pub fn Xutf8TextPerCharExtents(
        arg1: XFontSet,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
        arg4: *mut XRectangle,
        arg5: *mut XRectangle,
        arg6: libc::c_int,
        arg7: *mut libc::c_int,
        arg8: *mut XRectangle,
        arg9: *mut XRectangle,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XmbDrawText(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: *mut XmbTextItem,
        arg7: libc::c_int,
    );
}
extern "C" {
    pub fn XwcDrawText(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: *mut XwcTextItem,
        arg7: libc::c_int,
    );
}
extern "C" {
    pub fn Xutf8DrawText(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: *mut XmbTextItem,
        arg7: libc::c_int,
    );
}
extern "C" {
    pub fn XmbDrawString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: XFontSet,
        arg4: GC,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: *const libc::c_char,
        arg8: libc::c_int,
    );
}
extern "C" {
    pub fn XwcDrawString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: XFontSet,
        arg4: GC,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: *const wchar_t,
        arg8: libc::c_int,
    );
}
extern "C" {
    pub fn Xutf8DrawString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: XFontSet,
        arg4: GC,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: *const libc::c_char,
        arg8: libc::c_int,
    );
}
extern "C" {
    pub fn XmbDrawImageString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: XFontSet,
        arg4: GC,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: *const libc::c_char,
        arg8: libc::c_int,
    );
}
extern "C" {
    pub fn XwcDrawImageString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: XFontSet,
        arg4: GC,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: *const wchar_t,
        arg8: libc::c_int,
    );
}
extern "C" {
    pub fn Xutf8DrawImageString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: XFontSet,
        arg4: GC,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: *const libc::c_char,
        arg8: libc::c_int,
    );
}
extern "C" {
    pub fn XOpenIM(
        arg1: *mut Display,
        arg2: *mut _XrmHashBucketRec,
        arg3: *mut libc::c_char,
        arg4: *mut libc::c_char,
    ) -> XIM;
}
extern "C" {
    pub fn XCloseIM(arg1: XIM) -> libc::c_int;
}
extern "C" {
    pub fn XGetIMValues(arg1: XIM, ...) -> *mut libc::c_char;
}
extern "C" {
    pub fn XSetIMValues(arg1: XIM, ...) -> *mut libc::c_char;
}
extern "C" {
    pub fn XDisplayOfIM(arg1: XIM) -> *mut Display;
}
extern "C" {
    pub fn XLocaleOfIM(arg1: XIM) -> *mut libc::c_char;
}
extern "C" {
    pub fn XCreateIC(arg1: XIM, ...) -> XIC;
}
extern "C" {
    pub fn XDestroyIC(arg1: XIC);
}
extern "C" {
    pub fn XSetICFocus(arg1: XIC);
}
extern "C" {
    pub fn XUnsetICFocus(arg1: XIC);
}
extern "C" {
    pub fn XwcResetIC(arg1: XIC) -> *mut wchar_t;
}
extern "C" {
    pub fn XmbResetIC(arg1: XIC) -> *mut libc::c_char;
}
extern "C" {
    pub fn Xutf8ResetIC(arg1: XIC) -> *mut libc::c_char;
}
extern "C" {
    pub fn XSetICValues(arg1: XIC, ...) -> *mut libc::c_char;
}
extern "C" {
    pub fn XGetICValues(arg1: XIC, ...) -> *mut libc::c_char;
}
extern "C" {
    pub fn XIMOfIC(arg1: XIC) -> XIM;
}
extern "C" {
    pub fn XFilterEvent(arg1: *mut XEvent, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XmbLookupString(
        arg1: XIC,
        arg2: *mut XKeyPressedEvent,
        arg3: *mut libc::c_char,
        arg4: libc::c_int,
        arg5: *mut KeySym,
        arg6: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XwcLookupString(
        arg1: XIC,
        arg2: *mut XKeyPressedEvent,
        arg3: *mut wchar_t,
        arg4: libc::c_int,
        arg5: *mut KeySym,
        arg6: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn Xutf8LookupString(
        arg1: XIC,
        arg2: *mut XKeyPressedEvent,
        arg3: *mut libc::c_char,
        arg4: libc::c_int,
        arg5: *mut KeySym,
        arg6: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XVaCreateNestedList(arg1: libc::c_int, ...) -> XVaNestedList;
}
extern "C" {
    pub fn XRegisterIMInstantiateCallback(
        arg1: *mut Display,
        arg2: *mut _XrmHashBucketRec,
        arg3: *mut libc::c_char,
        arg4: *mut libc::c_char,
        arg5: XIDProc,
        arg6: XPointer,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XUnregisterIMInstantiateCallback(
        arg1: *mut Display,
        arg2: *mut _XrmHashBucketRec,
        arg3: *mut libc::c_char,
        arg4: *mut libc::c_char,
        arg5: XIDProc,
        arg6: XPointer,
    ) -> libc::c_int;
}
pub type XConnectionWatchProc = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut Display,
        arg2: XPointer,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: *mut XPointer,
    ),
>;
extern "C" {
    pub fn XInternalConnectionNumbers(
        arg1: *mut Display,
        arg2: *mut *mut libc::c_int,
        arg3: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XProcessInternalConnection(arg1: *mut Display, arg2: libc::c_int);
}
extern "C" {
    pub fn XAddConnectionWatch(
        arg1: *mut Display,
        arg2: XConnectionWatchProc,
        arg3: XPointer,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XRemoveConnectionWatch(arg1: *mut Display, arg2: XConnectionWatchProc, arg3: XPointer);
}
extern "C" {
    pub fn XSetAuthorization(
        arg1: *mut libc::c_char,
        arg2: libc::c_int,
        arg3: *mut libc::c_char,
        arg4: libc::c_int,
    );
}
extern "C" {
    pub fn _Xmbtowc(arg1: *mut wchar_t, arg2: *mut libc::c_char, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn _Xwctomb(arg1: *mut libc::c_char, arg2: wchar_t) -> libc::c_int;
}
extern "C" {
    pub fn XGetEventData(arg1: *mut Display, arg2: *mut XGenericEventCookie) -> libc::c_int;
}
extern "C" {
    pub fn XFreeEventData(arg1: *mut Display, arg2: *mut XGenericEventCookie);
}
#[repr(u32)]
#[doc = "  These are the various supported windowing subsystems"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_SYSWM_TYPE {
    SDL_SYSWM_UNKNOWN = 0,
    SDL_SYSWM_WINDOWS = 1,
    SDL_SYSWM_X11 = 2,
    SDL_SYSWM_DIRECTFB = 3,
    SDL_SYSWM_COCOA = 4,
    SDL_SYSWM_UIKIT = 5,
    SDL_SYSWM_WAYLAND = 6,
    SDL_SYSWM_MIR = 7,
    SDL_SYSWM_WINRT = 8,
    SDL_SYSWM_ANDROID = 9,
    SDL_SYSWM_VIVANTE = 10,
    SDL_SYSWM_OS2 = 11,
    SDL_SYSWM_HAIKU = 12,
    SDL_SYSWM_KMSDRM = 13,
    SDL_SYSWM_RISCOS = 14,
}
#[doc = "  The custom event structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_SysWMmsg {
    pub version: SDL_version,
    pub subsystem: SDL_SYSWM_TYPE,
    pub msg: SDL_SysWMmsg__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_SysWMmsg__bindgen_ty_1 {
    pub x11: SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1,
    pub dummy: libc::c_int,
    _bindgen_union_align: [u64; 24usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1 {
    pub event: XEvent,
}
#[test]
fn bindgen_test_layout_SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1>(),
        192usize,
        concat!(
            "Size of: ",
            stringify!(SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1>())).event as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(event)
        )
    );
}
#[test]
fn bindgen_test_layout_SDL_SysWMmsg__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SDL_SysWMmsg__bindgen_ty_1>(),
        192usize,
        concat!("Size of: ", stringify!(SDL_SysWMmsg__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_SysWMmsg__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_SysWMmsg__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_SysWMmsg__bindgen_ty_1>())).x11 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMmsg__bindgen_ty_1),
            "::",
            stringify!(x11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_SysWMmsg__bindgen_ty_1>())).dummy as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMmsg__bindgen_ty_1),
            "::",
            stringify!(dummy)
        )
    );
}
#[test]
fn bindgen_test_layout_SDL_SysWMmsg() {
    assert_eq!(
        ::core::mem::size_of::<SDL_SysWMmsg>(),
        200usize,
        concat!("Size of: ", stringify!(SDL_SysWMmsg))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_SysWMmsg>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_SysWMmsg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_SysWMmsg>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMmsg),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_SysWMmsg>())).subsystem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMmsg),
            "::",
            stringify!(subsystem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_SysWMmsg>())).msg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMmsg),
            "::",
            stringify!(msg)
        )
    );
}
#[doc = "  \\brief SDL_syswm.h"]
#[doc = ""]
#[doc = "  Your application has access to a special type of event ::SDL_SYSWMEVENT,"]
#[doc = "  which contains window-manager specific information and arrives whenever"]
#[doc = "  an unhandled window event occurs.  This event is ignored by default, but"]
#[doc = "  you can enable it with SDL_EventState()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_SysWMinfo {
    pub version: SDL_version,
    pub subsystem: SDL_SYSWM_TYPE,
    pub info: SDL_SysWMinfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_SysWMinfo__bindgen_ty_1 {
    pub x11: SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1,
    pub wl: SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2,
    pub dummy: [Uint8; 64usize],
    _bindgen_union_align: [u64; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< The X11 display"]
    pub display: *mut Display,
    #[doc = "< The X11 window"]
    pub window: Window,
}
#[test]
fn bindgen_test_layout_SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1>())).display
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1>())).window
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< Wayland display"]
    pub display: *mut wl_display,
    #[doc = "< Wayland surface"]
    pub surface: *mut wl_surface,
    #[doc = "< DEPRECATED Wayland shell_surface (window manager handle)"]
    pub shell_surface: *mut libc::c_void,
    #[doc = "< Wayland EGL window (native window)"]
    pub egl_window: *mut wl_egl_window,
    #[doc = "< Wayland xdg surface (window manager handle)"]
    pub xdg_surface: *mut xdg_surface,
    #[doc = "< Wayland xdg toplevel role"]
    pub xdg_toplevel: *mut xdg_toplevel,
}
#[test]
fn bindgen_test_layout_SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2>())).display
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2>())).surface
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(surface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2>())).shell_surface
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(shell_surface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2>())).egl_window
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(egl_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2>())).xdg_surface
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(xdg_surface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2>())).xdg_toplevel
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(xdg_toplevel)
        )
    );
}
#[test]
fn bindgen_test_layout_SDL_SysWMinfo__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SDL_SysWMinfo__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(SDL_SysWMinfo__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_SysWMinfo__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_SysWMinfo__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_SysWMinfo__bindgen_ty_1>())).x11 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1),
            "::",
            stringify!(x11)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_SysWMinfo__bindgen_ty_1>())).wl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1),
            "::",
            stringify!(wl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<SDL_SysWMinfo__bindgen_ty_1>())).dummy as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1),
            "::",
            stringify!(dummy)
        )
    );
}
#[test]
fn bindgen_test_layout_SDL_SysWMinfo() {
    assert_eq!(
        ::core::mem::size_of::<SDL_SysWMinfo>(),
        72usize,
        concat!("Size of: ", stringify!(SDL_SysWMinfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_SysWMinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_SysWMinfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_SysWMinfo>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_SysWMinfo>())).subsystem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo),
            "::",
            stringify!(subsystem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SDL_SysWMinfo>())).info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo),
            "::",
            stringify!(info)
        )
    );
}
extern "C" {
    #[doc = " Get driver-specific information about a window."]
    #[doc = ""]
    #[doc = " You must include SDL_syswm.h for the declaration of SDL_SysWMinfo."]
    #[doc = ""]
    #[doc = " The caller must initialize the `info` structure's version by using"]
    #[doc = " `SDL_VERSION(&info.version)`, and then this function will fill in the rest"]
    #[doc = " of the structure with information about the given window."]
    #[doc = ""]
    #[doc = " \\param window the window about which information is being requested"]
    #[doc = " \\param info an SDL_SysWMinfo structure filled in with window information"]
    #[doc = " \\returns SDL_TRUE if the function is implemented and the `version` member"]
    #[doc = "          of the `info` struct is valid, or SDL_FALSE if the information"]
    #[doc = "          could not be retrieved; call SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.0."]
    pub fn SDL_GetWindowWMInfo(window: *mut SDL_Window, info: *mut SDL_SysWMinfo) -> SDL_bool;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkInstance_T {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSurfaceKHR_T {
    _unused: [u8; 0],
}
pub type SDL_vulkanInstance = VkInstance;
pub type SDL_vulkanSurface = VkSurfaceKHR;
extern "C" {
    #[doc = " Dynamically load the Vulkan loader library."]
    #[doc = ""]
    #[doc = " This should be called after initializing the video driver, but before"]
    #[doc = " creating any Vulkan windows. If no Vulkan loader library is loaded, the"]
    #[doc = " default library will be loaded upon creation of the first Vulkan window."]
    #[doc = ""]
    #[doc = " It is fairly common for Vulkan applications to link with libvulkan instead"]
    #[doc = " of explicitly loading it at run time. This will work with SDL provided the"]
    #[doc = " application links to a dynamic library and both it and SDL use the same"]
    #[doc = " search path."]
    #[doc = ""]
    #[doc = " If you specify a non-NULL `path`, an application should retrieve all of the"]
    #[doc = " Vulkan functions it uses from the dynamic library using"]
    #[doc = " SDL_Vulkan_GetVkGetInstanceProcAddr unless you can guarantee `path` points"]
    #[doc = " to the same vulkan loader library the application linked to."]
    #[doc = ""]
    #[doc = " On Apple devices, if `path` is NULL, SDL will attempt to find the"]
    #[doc = " `vkGetInstanceProcAddr` address within all the Mach-O images of the current"]
    #[doc = " process. This is because it is fairly common for Vulkan applications to"]
    #[doc = " link with libvulkan (and historically MoltenVK was provided as a static"]
    #[doc = " library). If it is not found, on macOS, SDL will attempt to load"]
    #[doc = " `vulkan.framework/vulkan`, `libvulkan.1.dylib`,"]
    #[doc = " `MoltenVK.framework/MoltenVK`, and `libMoltenVK.dylib`, in that order. On"]
    #[doc = " iOS, SDL will attempt to load `libMoltenVK.dylib`. Applications using a"]
    #[doc = " dynamic framework or .dylib must ensure it is included in its application"]
    #[doc = " bundle."]
    #[doc = ""]
    #[doc = " On non-Apple devices, application linking with a static libvulkan is not"]
    #[doc = " supported. Either do not link to the Vulkan loader or link to a dynamic"]
    #[doc = " library version."]
    #[doc = ""]
    #[doc = " \\param path The platform dependent Vulkan loader library name or NULL"]
    #[doc = " \\returns 0 on success or -1 if the library couldn't be loaded; call"]
    #[doc = "          SDL_GetError() for more information."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.6."]
    #[doc = ""]
    #[doc = " \\sa SDL_Vulkan_GetVkInstanceProcAddr"]
    #[doc = " \\sa SDL_Vulkan_UnloadLibrary"]
    pub fn SDL_Vulkan_LoadLibrary(path: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the address of the `vkGetInstanceProcAddr` function."]
    #[doc = ""]
    #[doc = " This should be called after either calling SDL_Vulkan_LoadLibrary() or"]
    #[doc = " creating an SDL_Window with the `SDL_WINDOW_VULKAN` flag."]
    #[doc = ""]
    #[doc = " \\returns the function pointer for `vkGetInstanceProcAddr` or NULL on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.6."]
    pub fn SDL_Vulkan_GetVkGetInstanceProcAddr() -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Unload the Vulkan library previously loaded by SDL_Vulkan_LoadLibrary()"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.6."]
    #[doc = ""]
    #[doc = " \\sa SDL_Vulkan_LoadLibrary"]
    pub fn SDL_Vulkan_UnloadLibrary();
}
extern "C" {
    #[doc = " Get the names of the Vulkan instance extensions needed to create a surface"]
    #[doc = " with SDL_Vulkan_CreateSurface."]
    #[doc = ""]
    #[doc = " If `pNames` is NULL, then the number of required Vulkan instance extensions"]
    #[doc = " is returned in `pCount`. Otherwise, `pCount` must point to a variable set"]
    #[doc = " to the number of elements in the `pNames` array, and on return the variable"]
    #[doc = " is overwritten with the number of names actually written to `pNames`. If"]
    #[doc = " `pCount` is less than the number of required extensions, at most `pCount`"]
    #[doc = " structures will be written. If `pCount` is smaller than the number of"]
    #[doc = " required extensions, SDL_FALSE will be returned instead of SDL_TRUE, to"]
    #[doc = " indicate that not all the required extensions were returned."]
    #[doc = ""]
    #[doc = " The `window` parameter is currently needed to be valid as of SDL 2.0.8,"]
    #[doc = " however, this parameter will likely be removed in future releases"]
    #[doc = ""]
    #[doc = " \\param window A window for which the required Vulkan instance extensions"]
    #[doc = "               should be retrieved (will be deprecated in a future release)"]
    #[doc = " \\param pCount A pointer to an unsigned int corresponding to the number of"]
    #[doc = "               extensions to be returned"]
    #[doc = " \\param pNames NULL or a pointer to an array to be filled with required"]
    #[doc = "               Vulkan instance extensions"]
    #[doc = " \\returns SDL_TRUE on success, SDL_FALSE on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.6."]
    #[doc = ""]
    #[doc = " \\sa SDL_Vulkan_CreateSurface"]
    pub fn SDL_Vulkan_GetInstanceExtensions(
        window: *mut SDL_Window,
        pCount: *mut libc::c_uint,
        pNames: *mut *const libc::c_char,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = " Create a Vulkan rendering surface for a window."]
    #[doc = ""]
    #[doc = " The `window` must have been created with the `SDL_WINDOW_VULKAN` flag and"]
    #[doc = " `instance` must have been created with extensions returned by"]
    #[doc = " SDL_Vulkan_GetInstanceExtensions() enabled."]
    #[doc = ""]
    #[doc = " \\param window The window to which to attach the Vulkan surface"]
    #[doc = " \\param instance The Vulkan instance handle"]
    #[doc = " \\param surface A pointer to a VkSurfaceKHR handle to output the newly"]
    #[doc = "                created surface"]
    #[doc = " \\returns SDL_TRUE on success, SDL_FALSE on error."]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.6."]
    #[doc = ""]
    #[doc = " \\sa SDL_Vulkan_GetInstanceExtensions"]
    #[doc = " \\sa SDL_Vulkan_GetDrawableSize"]
    pub fn SDL_Vulkan_CreateSurface(
        window: *mut SDL_Window,
        instance: VkInstance,
        surface: *mut VkSurfaceKHR,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = " Get the size of the window's underlying drawable dimensions in pixels."]
    #[doc = ""]
    #[doc = " This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI"]
    #[doc = " drawable, i.e. the window was created with `SDL_WINDOW_ALLOW_HIGHDPI` on a"]
    #[doc = " platform with high-DPI support (Apple calls this \"Retina\"), and not"]
    #[doc = " disabled by the `SDL_HINT_VIDEO_HIGHDPI_DISABLED` hint."]
    #[doc = ""]
    #[doc = " \\param window an SDL_Window for which the size is to be queried"]
    #[doc = " \\param w Pointer to the variable to write the width to or NULL"]
    #[doc = " \\param h Pointer to the variable to write the height to or NULL"]
    #[doc = ""]
    #[doc = " \\since This function is available since SDL 2.0.6."]
    #[doc = ""]
    #[doc = " \\sa SDL_GetWindowSize"]
    #[doc = " \\sa SDL_CreateWindow"]
    #[doc = " \\sa SDL_Vulkan_CreateSurface"]
    pub fn SDL_Vulkan_GetDrawableSize(
        window: *mut SDL_Window,
        w: *mut libc::c_int,
        h: *mut libc::c_int,
    );
}
#[doc = " <div rustbindgen replaces=\"VkInstance\"></div>"]
pub type VkInstance = usize;
#[doc = " <div rustbindgen replaces=\"VkSurfaceKHR\"></div>"]
pub type VkSurfaceKHR = u64;
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::core::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[doc = "< Private"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_BlitMap {
    pub _address: u8,
}
#[doc = "< Wayland display"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wl_display {
    pub _address: u8,
}
#[doc = "< Wayland surface"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wl_surface {
    pub _address: u8,
}
#[doc = "< Wayland EGL window (native window)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wl_egl_window {
    pub _address: u8,
}
#[doc = "< Wayland xdg surface (window manager handle)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xdg_surface {
    pub _address: u8,
}
#[doc = "< Wayland xdg toplevel role"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xdg_toplevel {
    pub _address: u8,
}
